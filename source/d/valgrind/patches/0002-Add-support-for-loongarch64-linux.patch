From e296ae55f4848f597b12acbf6e7a1e545d836f71 Mon Sep 17 00:00:00 2001
From: Feiyang Chen <chenfeiyang@loongson.cn>
Date: Wed, 23 Mar 2022 11:31:59 +0800
Subject: [PATCH 2/4] Add support for loongarch64-linux

Add support for loongarch64-linux platform. Enable this target in
the build system.

Signed-off-by: Feiyang Chen <chenfeiyang@loongson.cn>
Signed-off-by: Shi Pujin <shipujin@loongson.cn>
---
 .gitignore                                    |   2 +
 Makefile.all.am                               |   7 +
 Makefile.tool.am                              |  12 +
 VEX/pub/libvex.h                              |   1 +
 VEX/useful/test_main.c                        |  13 +-
 cachegrind/cg_arch.c                          |   7 +
 cachegrind/cg_branchpred.c                    |   2 +-
 configure.ac                                  |  26 +-
 coregrind/Makefile.am                         |  15 +-
 coregrind/launcher-linux.c                    |  11 +-
 coregrind/m_aspacemgr/aspacemgr-common.c      |   9 +-
 coregrind/m_aspacemgr/aspacemgr-linux.c       |   3 +-
 coregrind/m_cache.c                           | 233 +++++
 coregrind/m_coredump/coredump-elf.c           |  42 +
 coregrind/m_debuginfo/d3basics.c              |   3 +
 coregrind/m_debuginfo/debuginfo.c             |  30 +-
 coregrind/m_debuginfo/priv_storage.h          |  19 +-
 coregrind/m_debuginfo/readdwarf.c             |  47 +-
 coregrind/m_debuginfo/readelf.c               |   6 +-
 coregrind/m_debuginfo/storage.c               |   9 +
 coregrind/m_debuglog.c                        |  35 +
 .../m_dispatch/dispatch-loongarch64-linux.S   | 314 +++++++
 .../loongarch-base64-valgrind-s1.xml          |  45 +
 .../loongarch-base64-valgrind-s2.xml          |  45 +
 coregrind/m_gdbserver/loongarch-base64.xml    |  45 +
 .../loongarch-fpu64-valgrind-s1.xml           |  57 ++
 .../loongarch-fpu64-valgrind-s2.xml           |  57 ++
 coregrind/m_gdbserver/loongarch-fpu64.xml     |  57 ++
 .../loongarch64-linux-valgrind.xml            |  18 +
 coregrind/m_gdbserver/loongarch64-linux.xml   |  14 +
 coregrind/m_gdbserver/target.c                |   2 +
 .../m_gdbserver/valgrind-low-loongarch64.c    | 272 ++++++
 coregrind/m_gdbserver/valgrind_low.h          |   1 +
 coregrind/m_initimg/initimg-linux.c           |  17 +-
 coregrind/m_libcassert.c                      |  20 +
 coregrind/m_libcfile.c                        |  63 +-
 coregrind/m_libcproc.c                        |  11 +-
 coregrind/m_libcsetjmp.c                      |  66 ++
 coregrind/m_machine.c                         | 194 ++++-
 coregrind/m_main.c                            |  37 +-
 coregrind/m_options.c                         |   3 +-
 coregrind/m_redir.c                           |  17 +
 coregrind/m_scheduler/scheduler.c             |   3 +
 .../m_sigframe/sigframe-loongarch64-linux.c   | 285 ++++++
 coregrind/m_signals.c                         |  51 +-
 coregrind/m_stacktrace.c                      |  94 ++
 coregrind/m_syscall.c                         |  32 +
 coregrind/m_syswrap/priv_syswrap-linux.h      |   7 +
 coregrind/m_syswrap/priv_types_n_macros.h     |   3 +-
 .../m_syswrap/syscall-loongarch64-linux.S     | 143 +++
 coregrind/m_syswrap/syswrap-generic.c         |   2 +-
 coregrind/m_syswrap/syswrap-linux.c           |  36 +-
 .../m_syswrap/syswrap-loongarch64-linux.c     | 648 ++++++++++++++
 coregrind/m_syswrap/syswrap-main.c            |  93 +-
 coregrind/m_trampoline.S                      |  48 ++
 coregrind/m_translate.c                       |   5 +
 coregrind/m_vki.c                             |   6 +-
 coregrind/pub_core_aspacemgr.h                |   3 +-
 coregrind/pub_core_basics.h                   |   8 +-
 coregrind/pub_core_debuginfo.h                |   4 +
 coregrind/pub_core_machine.h                  |  13 +
 coregrind/pub_core_mallocfree.h               |   1 +
 coregrind/pub_core_syscall.h                  |   1 +
 coregrind/pub_core_trampoline.h               |   6 +
 coregrind/pub_core_transtab.h                 |   3 +-
 coregrind/pub_core_transtab_asm.h             |   2 +-
 coregrind/vgdb-invoker-ptrace.c               |  19 +-
 drd/drd_bitmap.h                              |   2 +-
 drd/drd_load_store.c                          |   2 +
 helgrind/tests/annotate_hbefore.c             |  11 +
 helgrind/tests/tc07_hbl1.c                    |   8 +
 helgrind/tests/tc08_hbl2.c                    |   8 +
 helgrind/tests/tc11_XCHG.c                    |  18 +
 include/Makefile.am                           |   3 +
 include/pub_tool_basics.h                     |   6 +-
 include/pub_tool_guest.h                      |   3 +
 include/pub_tool_libcsetjmp.h                 |   8 +
 include/pub_tool_machine.h                    |   6 +
 include/pub_tool_redir.h                      |   2 +
 include/pub_tool_vkiscnums_asm.h              |   4 +
 include/valgrind.h.in                         | 525 +++++++++++-
 include/vki/vki-linux.h                       |   4 +
 include/vki/vki-loongarch64-linux.h           | 811 ++++++++++++++++++
 .../vki/vki-posixtypes-loongarch64-linux.h    |  76 ++
 include/vki/vki-scnums-loongarch64-linux.h    | 330 +++++++
 memcheck/mc_machine.c                         | 119 +++
 memcheck/mc_translate.c                       |   3 +
 memcheck/tests/atomic_incs.c                  |  15 +-
 memcheck/tests/unit_libcbase.c                |   4 +-
 none/tests/libvex_test.c                      |   7 +-
 tests/Makefile.am                             |   3 +-
 tests/arch_test.c                             |   5 +
 tests/loongarch64_features.c                  |  81 ++
 tests/platform_test                           |   1 +
 94 files changed, 5378 insertions(+), 90 deletions(-)
 create mode 100644 coregrind/m_dispatch/dispatch-loongarch64-linux.S
 create mode 100644 coregrind/m_gdbserver/loongarch-base64-valgrind-s1.xml
 create mode 100644 coregrind/m_gdbserver/loongarch-base64-valgrind-s2.xml
 create mode 100644 coregrind/m_gdbserver/loongarch-base64.xml
 create mode 100644 coregrind/m_gdbserver/loongarch-fpu64-valgrind-s1.xml
 create mode 100644 coregrind/m_gdbserver/loongarch-fpu64-valgrind-s2.xml
 create mode 100644 coregrind/m_gdbserver/loongarch-fpu64.xml
 create mode 100644 coregrind/m_gdbserver/loongarch64-linux-valgrind.xml
 create mode 100644 coregrind/m_gdbserver/loongarch64-linux.xml
 create mode 100644 coregrind/m_gdbserver/valgrind-low-loongarch64.c
 create mode 100644 coregrind/m_sigframe/sigframe-loongarch64-linux.c
 create mode 100644 coregrind/m_syswrap/syscall-loongarch64-linux.S
 create mode 100644 coregrind/m_syswrap/syswrap-loongarch64-linux.c
 create mode 100644 include/vki/vki-loongarch64-linux.h
 create mode 100644 include/vki/vki-posixtypes-loongarch64-linux.h
 create mode 100644 include/vki/vki-scnums-loongarch64-linux.h
 create mode 100644 tests/loongarch64_features.c

diff --git a/.gitignore b/.gitignore
index abc693c82..90a51125f 100644
--- a/.gitignore
+++ b/.gitignore
@@ -55,6 +55,7 @@
 /auxprogs/getoff-mips32-linux
 /auxprogs/getoff-mips64-linux
 /auxprogs/getoff-nanomips-linux
+/auxprogs/getoff-loongarch64-linux
 /auxprogs/getoff-amd64-solaris
 /auxprogs/getoff-x86-solaris
 /auxprogs/getoff-*-freebsd
@@ -2380,6 +2381,7 @@
 /tests/vg_regtest
 /tests/x86_amd64_features
 /tests/arm64_features
+/tests/loongarch64_features
 
 # /VEX/
 /VEX/libvex*.a
diff --git a/Makefile.all.am b/Makefile.all.am
index 7cb7e8725..fd1d4a99e 100755
--- a/Makefile.all.am
+++ b/Makefile.all.am
@@ -288,6 +288,12 @@ AM_CFLAGS_PSO_MIPS64_LINUX = @FLAG_M64@ $(AM_CFLAGS_BASE) \
 				$(AM_CFLAGS_PSO_BASE)
 AM_CCASFLAGS_MIPS64_LINUX  = @FLAG_M64@ -g
 
+AM_FLAG_M3264_LOONGARCH64_LINUX = @FLAG_M64@
+AM_CFLAGS_LOONGARCH64_LINUX     = @FLAG_M64@ $(AM_CFLAGS_BASE)
+AM_CFLAGS_PSO_LOONGARCH64_LINUX = @FLAG_M64@ $(AM_CFLAGS_BASE) \
+				$(AM_CFLAGS_PSO_BASE)
+AM_CCASFLAGS_LOONGARCH64_LINUX  = @FLAG_M64@ -g
+
 AM_FLAG_M3264_X86_SOLARIS   = @FLAG_M32@
 AM_CFLAGS_X86_SOLARIS       = @FLAG_M32@ @PREFERRED_STACK_BOUNDARY_2@ \
 				$(AM_CFLAGS_BASE) -fomit-frame-pointer @SOLARIS_UNDEF_LARGESOURCE@
@@ -348,6 +354,7 @@ PRELOAD_LDFLAGS_S390X_LINUX    = $(PRELOAD_LDFLAGS_COMMON_LINUX) @FLAG_M64@
 PRELOAD_LDFLAGS_MIPS32_LINUX   = $(PRELOAD_LDFLAGS_COMMON_LINUX) @FLAG_M32@
 PRELOAD_LDFLAGS_NANOMIPS_LINUX = $(PRELOAD_LDFLAGS_COMMON_LINUX) @FLAG_M32@
 PRELOAD_LDFLAGS_MIPS64_LINUX   = $(PRELOAD_LDFLAGS_COMMON_LINUX) @FLAG_M64@
+PRELOAD_LDFLAGS_LOONGARCH64_LINUX = $(PRELOAD_LDFLAGS_COMMON_LINUX) @FLAG_M64@
 PRELOAD_LDFLAGS_X86_SOLARIS    = $(PRELOAD_LDFLAGS_COMMON_SOLARIS) @FLAG_M32@
 PRELOAD_LDFLAGS_AMD64_SOLARIS  = $(PRELOAD_LDFLAGS_COMMON_SOLARIS) @FLAG_M64@
 
diff --git a/Makefile.tool.am b/Makefile.tool.am
index 4ce6d5ab0..7dbfbd89e 100644
--- a/Makefile.tool.am
+++ b/Makefile.tool.am
@@ -99,6 +99,10 @@ TOOL_LDFLAGS_MIPS64_LINUX = \
 	-static -nodefaultlibs -nostartfiles -u __start @FLAG_NO_BUILD_ID@ \
 	@FLAG_M64@
 
+TOOL_LDFLAGS_LOONGARCH64_LINUX = \
+	-static -nodefaultlibs -nostartfiles -u __start @FLAG_NO_BUILD_ID@ \
+	@FLAG_M64@
+
 TOOL_LDFLAGS_X86_SOLARIS = \
 	$(TOOL_LDFLAGS_COMMON_SOLARIS) @FLAG_M32@
 
@@ -167,6 +171,9 @@ LIBREPLACEMALLOC_MIPS32_LINUX = \
 LIBREPLACEMALLOC_MIPS64_LINUX = \
 	$(top_builddir)/coregrind/libreplacemalloc_toolpreload-mips64-linux.a
 
+LIBREPLACEMALLOC_LOONGARCH64_LINUX = \
+	$(top_builddir)/coregrind/libreplacemalloc_toolpreload-loongarch64-linux.a
+
 LIBREPLACEMALLOC_X86_SOLARIS = \
 	$(top_builddir)/coregrind/libreplacemalloc_toolpreload-x86-solaris.a
 
@@ -239,6 +246,11 @@ LIBREPLACEMALLOC_LDFLAGS_MIPS64_LINUX = \
 	$(LIBREPLACEMALLOC_MIPS64_LINUX) \
 	-Wl,--no-whole-archive
 
+LIBREPLACEMALLOC_LDFLAGS_LOONGARCH64_LINUX = \
+	-Wl,--whole-archive \
+	$(LIBREPLACEMALLOC_LOONGARCH64_LINUX) \
+	-Wl,--no-whole-archive
+
 LIBREPLACEMALLOC_LDFLAGS_X86_SOLARIS = \
 	-Wl,--whole-archive \
 	$(LIBREPLACEMALLOC_X86_SOLARIS) \
diff --git a/VEX/pub/libvex.h b/VEX/pub/libvex.h
index 9bf3d9905..4ff9a48d9 100644
--- a/VEX/pub/libvex.h
+++ b/VEX/pub/libvex.h
@@ -439,6 +439,7 @@ void LibVEX_default_VexArchInfo ( /*OUT*/VexArchInfo* vai );
       guest is mips32                     ==> applicable, default True
       guest is mips64                     ==> applicable, default True
       guest is arm64                      ==> applicable, default False
+      guest is loongarch64                ==> const True
 
    host_ppc_calls_use_fndescrs:
       host is ppc32-linux                 ==> False
diff --git a/VEX/useful/test_main.c b/VEX/useful/test_main.c
index cfed7a598..9c0f38ddc 100644
--- a/VEX/useful/test_main.c
+++ b/VEX/useful/test_main.c
@@ -101,7 +101,8 @@ int main ( int argc, char** argv )
    VexTranslateResult tres;
    VexControl vcon;
    VexGuestExtents vge;
-   VexArchInfo vai_x86, vai_amd64, vai_ppc32, vai_arm, vai_mips32, vai_mips64;
+   VexArchInfo vai_x86, vai_amd64, vai_ppc32, vai_arm, vai_mips32, vai_mips64,
+               vai_loongarch64;
    VexAbiInfo vbi;
    VexTranslateArgs vta;
 
@@ -190,6 +191,10 @@ int main ( int argc, char** argv )
       LibVEX_default_VexArchInfo(&vai_mips64);
       vai_mips64.endness = VexEndnessLE;
 
+      LibVEX_default_VexArchInfo(&vai_loongarch64);
+      vai_loongarch64.hwcaps = VEX_HWCAPS_LOONGARCH_ISA_64BIT;
+      vai_loongarch64.endness = VexEndnessLE;
+
       LibVEX_default_VexAbiInfo(&vbi);
       vbi.guest_stack_redzone_size = 128;
 
@@ -245,6 +250,12 @@ int main ( int argc, char** argv )
       vta.guest_bytes     = &origbuf[18 +1];
       vta.guest_bytes_addr = (Addr) &origbuf[18 +1];
 #endif
+#if 0 /* loongarch64 -> loongarch64 */
+      vta.arch_guest     = VexArchLOONGARCH64;
+      vta.archinfo_guest = vai_loongarch64;
+      vta.arch_host      = VexArchLOONGARCH64;
+      vta.archinfo_host  = vai_loongarch64;
+#endif
 
 #if 1 /* no instrumentation */
       vta.instrument1     = NULL;
diff --git a/cachegrind/cg_arch.c b/cachegrind/cg_arch.c
index 68314c9db..55f7585ee 100644
--- a/cachegrind/cg_arch.c
+++ b/cachegrind/cg_arch.c
@@ -484,6 +484,13 @@ configure_caches(cache_t *I1c, cache_t *D1c, cache_t *LLc,
    *D1c = (cache_t) {  65536, 2, 64 };
    *LLc = (cache_t) { 262144, 8, 64 };
 
+#elif defined(VGA_loongarch64)
+
+   // Set caches to default (for LOONGARCH64 - 3A5000)
+   *I1c = (cache_t) {    65536,  4, 64 };
+   *D1c = (cache_t) {    65536,  4, 64 };
+   *LLc = (cache_t) {   262144, 16, 64 };
+
 #else
 
 #error "Unknown arch"
diff --git a/cachegrind/cg_branchpred.c b/cachegrind/cg_branchpred.c
index 927b7bf21..6a972099d 100644
--- a/cachegrind/cg_branchpred.c
+++ b/cachegrind/cg_branchpred.c
@@ -44,7 +44,7 @@
    guaranteed to be zero? */
 #if defined(VGA_ppc32) || defined(VGA_ppc64be)  || defined(VGA_ppc64le) \
     || defined(VGA_mips32) || defined(VGA_mips64) || defined(VGA_nanomips) \
-    || defined(VGA_arm64)
+    || defined(VGA_arm64) || defined(VGA_loongarch64)
 #  define N_IADDR_LO_ZERO_BITS 2
 #elif defined(VGA_x86) || defined(VGA_amd64)
 #  define N_IADDR_LO_ZERO_BITS 0
diff --git a/configure.ac b/configure.ac
index 21ec7a07f..46740a2da 100755
--- a/configure.ac
+++ b/configure.ac
@@ -325,6 +325,11 @@ case "${host_cpu}" in
         ARCH_MAX="nanomips"
         ;;
 
+     loongarch64*)
+        AC_MSG_RESULT([ok (${host_cpu})])
+        ARCH_MAX="loongarch64"
+        ;;
+
      *) 
 	AC_MSG_RESULT([no (${host_cpu})])
 	AC_MSG_ERROR([Unsupported host architecture. Sorry])
@@ -978,6 +983,17 @@ case "$ARCH_MAX-$VGCONF_OS" in
         valt_load_address_sec_inner="0xUNSET"
         AC_MSG_RESULT([ok (${ARCH_MAX}-${VGCONF_OS})])
         ;;
+     loongarch64-linux)
+        VGCONF_ARCH_PRI="loongarch64"
+        VGCONF_ARCH_SEC=""
+        VGCONF_PLATFORM_PRI_CAPS="LOONGARCH64_LINUX"
+        VGCONF_PLATFORM_SEC_CAPS=""
+        valt_load_address_pri_norml="0x58000000"
+        valt_load_address_pri_inner="0x38000000"
+        valt_load_address_sec_norml="0xUNSET"
+        valt_load_address_sec_inner="0xUNSET"
+        AC_MSG_RESULT([ok (${ARCH_MAX}-${VGCONF_OS})])
+        ;;
      x86-solaris)
         VGCONF_ARCH_PRI="x86"
         VGCONF_ARCH_SEC=""
@@ -1070,6 +1086,8 @@ AM_CONDITIONAL(VGCONF_ARCHS_INCLUDE_MIPS64,
                test x$VGCONF_PLATFORM_PRI_CAPS = xMIPS64_LINUX ) 
 AM_CONDITIONAL(VGCONF_ARCHS_INCLUDE_NANOMIPS,
                test x$VGCONF_PLATFORM_PRI_CAPS = xNANOMIPS_LINUX )
+AM_CONDITIONAL(VGCONF_ARCHS_INCLUDE_LOONGARCH64,
+               test x$VGCONF_PLATFORM_PRI_CAPS = xLOONGARCH64_LINUX )
 
 # Set up VGCONF_PLATFORMS_INCLUDE_<platform>.  Either one or two of these
 # become defined.
@@ -1100,6 +1118,8 @@ AM_CONDITIONAL(VGCONF_PLATFORMS_INCLUDE_MIPS64_LINUX,
                test x$VGCONF_PLATFORM_PRI_CAPS = xMIPS64_LINUX)
 AM_CONDITIONAL(VGCONF_PLATFORMS_INCLUDE_NANOMIPS_LINUX,
                test x$VGCONF_PLATFORM_PRI_CAPS = xNANOMIPS_LINUX)
+AM_CONDITIONAL(VGCONF_PLATFORMS_INCLUDE_LOONGARCH64_LINUX,
+               test x$VGCONF_PLATFORM_PRI_CAPS = xLOONGARCH64_LINUX)
 AM_CONDITIONAL(VGCONF_PLATFORMS_INCLUDE_X86_FREEBSD,
                test x$VGCONF_PLATFORM_PRI_CAPS = xX86_FREEBSD \
                  -o x$VGCONF_PLATFORM_SEC_CAPS = xX86_FREEBSD)
@@ -1131,7 +1151,8 @@ AM_CONDITIONAL(VGCONF_OS_IS_LINUX,
                  -o x$VGCONF_PLATFORM_PRI_CAPS = xS390X_LINUX \
                  -o x$VGCONF_PLATFORM_PRI_CAPS = xMIPS32_LINUX \
                  -o x$VGCONF_PLATFORM_PRI_CAPS = xMIPS64_LINUX \
-                 -o x$VGCONF_PLATFORM_PRI_CAPS = xNANOMIPS_LINUX)
+                 -o x$VGCONF_PLATFORM_PRI_CAPS = xNANOMIPS_LINUX \
+                 -o x$VGCONF_PLATFORM_PRI_CAPS = xLOONGARCH64_LINUX)
 AM_CONDITIONAL(VGCONF_OS_IS_FREEBSD,
                test x$VGCONF_PLATFORM_PRI_CAPS = xX86_FREEBSD \
                  -o x$VGCONF_PLATFORM_PRI_CAPS = xAMD64_FREEBSD)
@@ -5054,7 +5075,8 @@ elif test x$VGCONF_PLATFORM_PRI_CAPS = xAMD64_LINUX \
        -o x$VGCONF_PLATFORM_PRI_CAPS = xPPC64_LINUX \
        -o x$VGCONF_PLATFORM_PRI_CAPS = xARM64_LINUX \
        -o x$VGCONF_PLATFORM_PRI_CAPS = xMIPS64_LINUX \
-       -o x$VGCONF_PLATFORM_PRI_CAPS = xS390X_LINUX ; then
+       -o x$VGCONF_PLATFORM_PRI_CAPS = xS390X_LINUX \
+       -o x$VGCONF_PLATFORM_PRI_CAPS = xLOONGARCH64_LINUX; then
   mflag_primary=$FLAG_M64
 elif test x$VGCONF_PLATFORM_PRI_CAPS = xX86_DARWIN ; then
   mflag_primary="$FLAG_M32 -arch i386"
diff --git a/coregrind/Makefile.am b/coregrind/Makefile.am
index f1815b411..b6948442a 100644
--- a/coregrind/Makefile.am
+++ b/coregrind/Makefile.am
@@ -387,6 +387,7 @@ COREGRIND_SOURCES_COMMON = \
 	m_dispatch/dispatch-mips32-linux.S \
 	m_dispatch/dispatch-mips64-linux.S \
 	m_dispatch/dispatch-nanomips-linux.S \
+	m_dispatch/dispatch-loongarch64-linux.S \
 	m_dispatch/dispatch-x86-freebsd.S \
 	m_dispatch/dispatch-amd64-freebsd.S \
 	m_dispatch/dispatch-x86-darwin.S \
@@ -411,6 +412,7 @@ COREGRIND_SOURCES_COMMON = \
 	m_gdbserver/valgrind-low-mips32.c \
 	m_gdbserver/valgrind-low-mips64.c \
 	m_gdbserver/valgrind-low-nanomips.c \
+	m_gdbserver/valgrind-low-loongarch64.c \
 	m_gdbserver/version.c \
 	m_initimg/initimg-linux.c \
 	m_initimg/initimg-freebsd.c \
@@ -438,6 +440,7 @@ COREGRIND_SOURCES_COMMON = \
 	m_sigframe/sigframe-mips32-linux.c \
 	m_sigframe/sigframe-mips64-linux.c \
 	m_sigframe/sigframe-nanomips-linux.c \
+	m_sigframe/sigframe-loongarch64-linux.c \
 	m_sigframe/sigframe-x86-darwin.c \
 	m_sigframe/sigframe-amd64-darwin.c \
 	m_sigframe/sigframe-solaris.c \
@@ -452,6 +455,7 @@ COREGRIND_SOURCES_COMMON = \
 	m_syswrap/syscall-mips32-linux.S \
 	m_syswrap/syscall-mips64-linux.S \
 	m_syswrap/syscall-nanomips-linux.S \
+	m_syswrap/syscall-loongarch64-linux.S \
 	m_syswrap/syscall-x86-freebsd.S \
 	m_syswrap/syscall-amd64-freebsd.S \
 	m_syswrap/syscall-x86-darwin.S \
@@ -477,6 +481,7 @@ COREGRIND_SOURCES_COMMON = \
 	m_syswrap/syswrap-mips32-linux.c \
 	m_syswrap/syswrap-mips64-linux.c \
 	m_syswrap/syswrap-nanomips-linux.c \
+	m_syswrap/syswrap-loongarch64-linux.c \
 	m_syswrap/syswrap-x86-darwin.c \
 	m_syswrap/syswrap-amd64-darwin.c \
 	m_syswrap/syswrap-xen.c \
@@ -769,7 +774,15 @@ GDBSERVER_XML_FILES = \
 	m_gdbserver/mips64-linux-valgrind.xml \
 	m_gdbserver/mips64-fpu-valgrind-s1.xml \
 	m_gdbserver/mips64-fpu-valgrind-s2.xml \
-	m_gdbserver/mips64-fpu.xml
+	m_gdbserver/mips64-fpu.xml \
+	m_gdbserver/loongarch-base64.xml \
+	m_gdbserver/loongarch-fpu64.xml \
+	m_gdbserver/loongarch64-linux.xml \
+	m_gdbserver/loongarch-base64-valgrind-s1.xml \
+	m_gdbserver/loongarch-base64-valgrind-s2.xml \
+	m_gdbserver/loongarch-fpu64-valgrind-s1.xml \
+	m_gdbserver/loongarch-fpu64-valgrind-s2.xml \
+	m_gdbserver/loongarch64-linux-valgrind.xml
 
 # so as to make sure these get copied into the install tree
 vglibdir = $(pkglibexecdir)
diff --git a/coregrind/launcher-linux.c b/coregrind/launcher-linux.c
index 715fdab81..d392cf545 100644
--- a/coregrind/launcher-linux.c
+++ b/coregrind/launcher-linux.c
@@ -67,6 +67,10 @@
 #define EM_NANOMIPS 249
 #endif
 
+#ifndef EM_LOONGARCH
+#define EM_LOONGARCH 258
+#endif
+
 #ifndef E_MIPS_ABI_O32
 #define E_MIPS_ABI_O32 0x00001000
 #endif
@@ -316,6 +320,10 @@ static const char *select_platform(const char *clientname)
                 (header.ehdr64.e_ident[EI_OSABI] == ELFOSABI_SYSV ||
                  header.ehdr64.e_ident[EI_OSABI] == ELFOSABI_LINUX)) {
                platform = "ppc64le-linux";
+            } else if (header.ehdr64.e_machine == EM_LOONGARCH &&
+                (header.ehdr64.e_ident[EI_OSABI] == ELFOSABI_SYSV ||
+                 header.ehdr64.e_ident[EI_OSABI] == ELFOSABI_LINUX)) {
+               platform = "loongarch64-linux";
             }
          } else if (header.c[EI_DATA] == ELFDATA2MSB) {
 #           if !defined(VGPV_arm_linux_android) \
@@ -417,7 +425,8 @@ int main(int argc, char** argv, char** envp)
        (0==strcmp(VG_PLATFORM,"s390x-linux"))  ||
        (0==strcmp(VG_PLATFORM,"mips32-linux")) ||
        (0==strcmp(VG_PLATFORM,"mips64-linux")) ||
-       (0==strcmp(VG_PLATFORM,"nanomips-linux")))
+       (0==strcmp(VG_PLATFORM,"nanomips-linux")) ||
+       (0==strcmp(VG_PLATFORM,"loongarch64-linux")))
       default_platform = VG_PLATFORM;
 #  elif defined(VGO_solaris)
    if ((0==strcmp(VG_PLATFORM,"x86-solaris")) ||
diff --git a/coregrind/m_aspacemgr/aspacemgr-common.c b/coregrind/m_aspacemgr/aspacemgr-common.c
index 7ad1b40ac..1eddede22 100644
--- a/coregrind/m_aspacemgr/aspacemgr-common.c
+++ b/coregrind/m_aspacemgr/aspacemgr-common.c
@@ -157,7 +157,8 @@ SysRes VG_(am_do_mmap_NO_NOTIFY)( Addr start, SizeT length, UInt prot,
 #  elif defined(VGP_amd64_linux) \
         || defined(VGP_ppc64be_linux)  || defined(VGP_ppc64le_linux) \
         || defined(VGP_s390x_linux) || defined(VGP_mips32_linux) \
-        || defined(VGP_mips64_linux) || defined(VGP_arm64_linux)
+        || defined(VGP_mips64_linux) || defined(VGP_arm64_linux) \
+        || defined(VGP_loongarch64_linux)
    res = VG_(do_syscall6)(__NR_mmap, (UWord)start, length, 
                          prot, flags, fd, offset);
 #  elif defined(VGP_x86_darwin)
@@ -262,7 +263,8 @@ SysRes ML_(am_do_relocate_nooverlap_mapping_NO_NOTIFY)(
 
 SysRes ML_(am_open) ( const HChar* pathname, Int flags, Int mode )
 {
-#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+      || defined(VGP_loongarch64_linux)
    /* ARM64 wants to use __NR_openat rather than __NR_open. */
    SysRes res = VG_(do_syscall4)(__NR_openat,
                                  VKI_AT_FDCWD, (UWord)pathname, flags, mode);
@@ -291,7 +293,8 @@ void ML_(am_close) ( Int fd )
 Int ML_(am_readlink)(const HChar* path, HChar* buf, UInt bufsiz)
 {
    SysRes res;
-#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+      || defined(VGP_loongarch64_linux)
    res = VG_(do_syscall4)(__NR_readlinkat, VKI_AT_FDCWD,
                                            (UWord)path, (UWord)buf, bufsiz);
 #  elif defined(VGO_linux) || defined(VGO_darwin) || defined(VGO_freebsd)
diff --git a/coregrind/m_aspacemgr/aspacemgr-linux.c b/coregrind/m_aspacemgr/aspacemgr-linux.c
index 4ed8e40ff..972a8628a 100644
--- a/coregrind/m_aspacemgr/aspacemgr-linux.c
+++ b/coregrind/m_aspacemgr/aspacemgr-linux.c
@@ -2778,7 +2778,8 @@ static SysRes VG_(am_mmap_file_float_valgrind_flags) ( SizeT length, UInt prot,
    req.rkind = MAny;
    req.start = 0;
    #if defined(VGA_arm) || defined(VGA_arm64) \
-      || defined(VGA_mips32) || defined(VGA_mips64) || defined(VGA_nanomips)
+      || defined(VGA_mips32) || defined(VGA_mips64) || defined(VGA_nanomips) \
+      || defined(VGA_loongarch64)
    aspacem_assert(VKI_SHMLBA >= VKI_PAGE_SIZE);
    #else
    aspacem_assert(VKI_SHMLBA == VKI_PAGE_SIZE);
diff --git a/coregrind/m_cache.c b/coregrind/m_cache.c
index 428a4df43..38fa44ea1 100644
--- a/coregrind/m_cache.c
+++ b/coregrind/m_cache.c
@@ -660,6 +660,239 @@ get_cache_info(VexArchInfo *vai)
    return True;
 }
 
+#elif defined(VGA_loongarch64)
+
+/*
+ * LoongArch method is straightforward, just extract appropriate bits via
+ * cpucfg instruction (__builtin_loongarch_cpucfg).
+ *
+ * 1. Get the properties of the cache from cpucfg16.
+ * 2. For each level of cache, get the properties from cpucfg17/18/19/20.
+ *
+ * It's a bit nasty since we have to get the total number of caches first.
+ * To avoid duplicating reads, I use "struct cache_status" to store some
+ * necessary information.
+ */
+
+#define BIT(x)        (1UL << (x))
+#define GENMASK(h, l) (((~0UL) - (1UL << (l)) + 1) & (~0UL >> (64 - 1 - (h))))
+
+#define LOONGARCH_CPUCFG16  0x10
+#define CPUCFG16_L1_IUPRE   BIT(0)
+#define CPUCFG16_L1_IUUNIFY BIT(1)
+#define CPUCFG16_L1_DPRE    BIT(2)
+#define CPUCFG16_L2_IUPRE   BIT(3)
+#define CPUCFG16_L2_IUUNIFY BIT(4)
+#define CPUCFG16_L2_DPRE    BIT(7)
+#define CPUCFG16_L3_IUPRE   BIT(10)
+#define CPUCFG16_L3_IUUNIFY BIT(11)
+#define CPUCFG16_L3_DPRE    BIT(14)
+
+#define LOONGARCH_CPUCFG17  0x11
+#define CPUCFG17_L1I_WAYS_M GENMASK(15, 0)
+#define CPUCFG17_L1I_SETS_M GENMASK(23, 16)
+#define CPUCFG17_L1I_SIZE_M GENMASK(30, 24)
+#define CPUCFG17_L1I_WAYS   0
+#define CPUCFG17_L1I_SETS   16
+#define CPUCFG17_L1I_SIZE   24
+
+#define LOONGARCH_CPUCFG18  0x12
+#define CPUCFG18_L1D_WAYS_M GENMASK(15, 0)
+#define CPUCFG18_L1D_SETS_M GENMASK(23, 16)
+#define CPUCFG18_L1D_SIZE_M GENMASK(30, 24)
+#define CPUCFG18_L1D_WAYS   0
+#define CPUCFG18_L1D_SETS   16
+#define CPUCFG18_L1D_SIZE   24
+
+#define LOONGARCH_CPUCFG19  0x13
+#define CPUCFG19_L2_WAYS_M  GENMASK(15, 0)
+#define CPUCFG19_L2_SETS_M  GENMASK(23, 16)
+#define CPUCFG19_L2_SIZE_M  GENMASK(30, 24)
+#define CPUCFG19_L2_WAYS    0
+#define CPUCFG19_L2_SETS    16
+#define CPUCFG19_L2_SIZE    24
+
+#define LOONGARCH_CPUCFG20  0x14
+#define CPUCFG20_L3_WAYS_M  GENMASK(15, 0)
+#define CPUCFG20_L3_SETS_M  GENMASK(23, 16)
+#define CPUCFG20_L3_SIZE_M  GENMASK(30, 24)
+#define CPUCFG20_L3_WAYS    0
+#define CPUCFG20_L3_SETS    16
+#define CPUCFG20_L3_SIZE    24
+
+struct cache_status {
+   Bool has_iu;
+   Bool is_u;
+   Bool has_d;
+   Bool exist;
+   UInt num;
+};
+
+static inline UInt
+cpucfg(UInt reg)
+{
+   return (UInt)__builtin_loongarch_cpucfg(reg);
+}
+
+static void
+get_status(struct cache_status status[], UInt n)
+{
+   Bool has_iu = status[n].has_iu;
+   Bool is_u   = status[n].is_u;
+   Bool has_d  = status[n].has_d;
+
+   /* has_d only works with no ucache */
+   status[n].has_d = has_d = toBool(!(has_iu && is_u) && has_d);
+
+   status[n].exist = toBool(has_iu || has_d);
+   status[n].num   = has_iu + has_d;
+}
+
+static void
+get_cache(VexCacheInfo *ci, VexCacheKind kind, UInt level,
+          UInt line_size, UInt sets, UInt ways, UInt index)
+{
+   UInt assoc = ways;
+   UInt size = sets * ways * line_size;
+   ci->caches[index] = VEX_CACHE_INIT(kind, level, size, line_size, assoc);
+}
+
+static void
+get_cache_info_for_l1(VexCacheInfo *ci, struct cache_status status[])
+{
+   UInt config;
+   UInt line_size, sets, ways;
+   UInt index = 0;
+
+   if (!status[0].exist)
+      return;
+
+   if (status[0].has_iu) {
+      config    = cpucfg(LOONGARCH_CPUCFG17);
+      line_size = 1 << ((config & CPUCFG17_L1I_SIZE_M) >> CPUCFG17_L1I_SIZE);
+      sets      = 1 << ((config & CPUCFG17_L1I_SETS_M) >> CPUCFG17_L1I_SETS);
+      ways      = ((config & CPUCFG17_L1I_WAYS_M) >> CPUCFG17_L1I_WAYS) + 1;
+      get_cache(ci, status[0].is_u ? UNIFIED_CACHE : INSN_CACHE,
+                1, line_size, sets, ways, index++);
+   }
+
+   if (status[0].has_d) {
+      config    = cpucfg(LOONGARCH_CPUCFG18);
+      line_size = 1 << ((config & CPUCFG18_L1D_SIZE_M) >> CPUCFG18_L1D_SIZE);
+      sets      = 1 << ((config & CPUCFG18_L1D_SETS_M) >> CPUCFG18_L1D_SETS);
+      ways      = ((config & CPUCFG18_L1D_WAYS_M) >> CPUCFG18_L1D_WAYS) + 1;
+      get_cache(ci, DATA_CACHE, 1, line_size, sets, ways, index++);
+   }
+
+   /* Sanity check */
+   vg_assert(index == status[0].num);
+}
+
+static void
+get_cache_info_for_l2(VexCacheInfo *ci, struct cache_status status[])
+{
+   UInt config;
+   UInt line_size, sets, ways;
+   UInt index = status[0].num;
+
+   if (!status[1].exist)
+      return;
+
+   config    = cpucfg(LOONGARCH_CPUCFG19);
+   line_size = 1 << ((config & CPUCFG19_L2_SIZE_M) >> CPUCFG19_L2_SIZE);
+   sets      = 1 << ((config & CPUCFG19_L2_SETS_M) >> CPUCFG19_L2_SETS);
+   ways      = ((config & CPUCFG19_L2_WAYS_M) >> CPUCFG19_L2_WAYS) + 1;
+
+   if (status[1].has_iu)
+      get_cache(ci, status[1].is_u ? UNIFIED_CACHE : INSN_CACHE,
+                2, line_size, sets, ways, index++);
+
+   if (status[1].has_d)
+      get_cache(ci, DATA_CACHE, 2, line_size, sets, ways, index++);
+
+   /* Sanity check */
+   vg_assert(index == status[0].num + status[1].num);
+}
+
+static void
+get_cache_info_for_l3(VexCacheInfo *ci, struct cache_status status[])
+{
+   UInt config;
+   UInt line_size, sets, ways;
+   UInt index = status[0].num + status[1].num;
+
+   if (!status[2].exist)
+      return;
+
+   config    = cpucfg(LOONGARCH_CPUCFG20);
+   line_size = 1 << ((config & CPUCFG20_L3_SIZE_M) >> CPUCFG20_L3_SIZE);
+   sets      = 1 << ((config & CPUCFG20_L3_SETS_M) >> CPUCFG20_L3_SETS);
+   ways      = ((config & CPUCFG20_L3_WAYS_M) >> CPUCFG20_L3_WAYS) + 1;
+
+   if (status[2].has_iu)
+      get_cache(ci, status[2].is_u ? UNIFIED_CACHE : INSN_CACHE,
+                3, line_size, sets, ways, index++);
+
+   if (status[2].has_d)
+      get_cache(ci, DATA_CACHE, 3, line_size, sets, ways, index++);
+
+   /* Sanity check */
+   vg_assert(index == status[0].num + status[1].num + status[2].num);
+}
+
+static Bool
+get_cache_info_from_cpucfg(VexCacheInfo *ci)
+{
+   Int i;
+   struct cache_status status[3];
+   UInt config = cpucfg(LOONGARCH_CPUCFG16);
+
+   /* NB: Bool is unsigned char! */
+   /* For l1 */
+   status[0].has_iu = toBool(config & CPUCFG16_L1_IUPRE);
+   status[0].is_u   = toBool(config & CPUCFG16_L1_IUUNIFY);
+   status[0].has_d  = toBool(config & CPUCFG16_L1_DPRE);
+   get_status(status, 0);
+
+   /* For l2 */
+   status[1].has_iu = toBool(config & CPUCFG16_L2_IUPRE);
+   status[1].is_u   = toBool(config & CPUCFG16_L2_IUUNIFY);
+   status[1].has_d  = toBool(config & CPUCFG16_L2_DPRE);
+   get_status(status, 1);
+
+   /* For l3 */
+   status[2].has_iu = toBool(config & CPUCFG16_L3_IUPRE);
+   status[2].is_u   = toBool(config & CPUCFG16_L3_IUUNIFY);
+   status[2].has_d  = toBool(config & CPUCFG16_L3_DPRE);
+   get_status(status, 2);
+
+   ci->num_levels = 0;
+   ci->num_caches = 0;
+   for (i = 0; i < 3; i++) {
+      ci->num_levels += status[i].exist;
+      ci->num_caches += status[i].num;
+   }
+
+   if (ci->num_caches == 0) {
+      VG_(debugLog)(1, "cache", "Autodetect failed\n");
+      return False;
+   }
+
+   ci->caches = VG_(malloc)("m_cache", ci->num_caches * sizeof(VexCache));
+   get_cache_info_for_l1(ci, status);
+   get_cache_info_for_l2(ci, status);
+   get_cache_info_for_l3(ci, status);
+   return True;
+}
+
+static Bool
+get_cache_info(VexArchInfo *vai)
+{
+   VexCacheInfo *ci = &vai->hwcache_info;
+   ci->icaches_maintain_coherence = True;
+   return get_cache_info_from_cpucfg(ci);
+}
+
 #else
 
 #error "Unknown arch"
diff --git a/coregrind/m_coredump/coredump-elf.c b/coregrind/m_coredump/coredump-elf.c
index 4a8c29c52..82b1b436a 100644
--- a/coregrind/m_coredump/coredump-elf.c
+++ b/coregrind/m_coredump/coredump-elf.c
@@ -489,6 +489,40 @@ static void fill_prstatus(const ThreadState *tst,
    regs[VKI_MIPS32_EF_CP0_STATUS] = arch->vex.guest_CP0_status;
    regs[VKI_MIPS32_EF_CP0_EPC]    = arch->vex.guest_PC;
 #  undef DO
+#elif defined(VGP_loongarch64_linux)
+   regs->regs[0]  = arch->vex.guest_R0;
+   regs->regs[1]  = arch->vex.guest_R1;
+   regs->regs[2]  = arch->vex.guest_R2;
+   regs->regs[3]  = arch->vex.guest_R3;
+   regs->regs[4]  = arch->vex.guest_R4;
+   regs->regs[5]  = arch->vex.guest_R5;
+   regs->regs[6]  = arch->vex.guest_R6;
+   regs->regs[7]  = arch->vex.guest_R7;
+   regs->regs[8]  = arch->vex.guest_R8;
+   regs->regs[9]  = arch->vex.guest_R9;
+   regs->regs[10] = arch->vex.guest_R10;
+   regs->regs[11] = arch->vex.guest_R11;
+   regs->regs[12] = arch->vex.guest_R12;
+   regs->regs[13] = arch->vex.guest_R13;
+   regs->regs[14] = arch->vex.guest_R14;
+   regs->regs[15] = arch->vex.guest_R15;
+   regs->regs[16] = arch->vex.guest_R16;
+   regs->regs[17] = arch->vex.guest_R17;
+   regs->regs[18] = arch->vex.guest_R18;
+   regs->regs[19] = arch->vex.guest_R19;
+   regs->regs[20] = arch->vex.guest_R20;
+   regs->regs[21] = arch->vex.guest_R21;
+   regs->regs[22] = arch->vex.guest_R22;
+   regs->regs[23] = arch->vex.guest_R23;
+   regs->regs[24] = arch->vex.guest_R24;
+   regs->regs[25] = arch->vex.guest_R25;
+   regs->regs[26] = arch->vex.guest_R26;
+   regs->regs[27] = arch->vex.guest_R27;
+   regs->regs[28] = arch->vex.guest_R28;
+   regs->regs[29] = arch->vex.guest_R29;
+   regs->regs[30] = arch->vex.guest_R30;
+   regs->regs[31] = arch->vex.guest_R31;
+   regs->csr_era  = arch->vex.guest_PC;
 #elif defined(VGP_amd64_freebsd)
    regs->rflags = LibVEX_GuestAMD64_get_rflags( &arch->vex );
    regs->rsp    = arch->vex.guest_RSP;
@@ -654,6 +688,14 @@ static void fill_fpu(const ThreadState *tst, vki_elf_fpregset_t *fpu)
 #  undef DO
 #elif defined(VGP_nanomips_linux)
 
+#elif defined(VGP_loongarch64_linux)
+#  define DO(n)  (*fpu)[n] = *(const double*)(&arch->vex.guest_X##n)
+   DO(0);  DO(1);  DO(2);  DO(3);  DO(4);  DO(5);  DO(6);  DO(7);
+   DO(8);  DO(9);  DO(10); DO(11); DO(12); DO(13); DO(14); DO(15);
+   DO(16); DO(17); DO(18); DO(19); DO(20); DO(21); DO(22); DO(23);
+   DO(24); DO(25); DO(26); DO(27); DO(28); DO(29); DO(30); DO(31);
+#  undef DO
+
 #elif defined(VGP_x86_freebsd)
 
 #elif defined(VGP_amd64_freebsd)
diff --git a/coregrind/m_debuginfo/d3basics.c b/coregrind/m_debuginfo/d3basics.c
index bcfd45615..222496ed2 100644
--- a/coregrind/m_debuginfo/d3basics.c
+++ b/coregrind/m_debuginfo/d3basics.c
@@ -555,6 +555,9 @@ static Bool get_Dwarf_Reg( /*OUT*/Addr* a, Word regno, const RegSummary* regs )
 #  elif defined(VGP_arm64_linux)
    if (regno == 31) { *a = regs->sp; return True; }
    if (regno == 29) { *a = regs->fp; return True; }
+#  elif defined(VGP_loongarch64_linux)
+   if (regno ==  3) { *a = regs->sp; return True; }
+   if (regno == 22) { *a = regs->fp; return True; }
 #  else
 #    error "Unknown platform"
 #  endif
diff --git a/coregrind/m_debuginfo/debuginfo.c b/coregrind/m_debuginfo/debuginfo.c
index 6f923c736..020f422ba 100644
--- a/coregrind/m_debuginfo/debuginfo.c
+++ b/coregrind/m_debuginfo/debuginfo.c
@@ -1269,7 +1269,7 @@ ULong VG_(di_notify_mmap)( Addr a, Bool allow_SkFileV, Int use_fd )
    is_ro_map = False;
 
 #  if defined(VGA_x86) || defined(VGA_ppc32) || defined(VGA_mips32) \
-      || defined(VGA_mips64) || defined(VGA_nanomips)
+      || defined(VGA_mips64) || defined(VGA_nanomips) || defined(VGA_loongarch64)
    is_rx_map = seg->hasR && seg->hasX;
    is_rw_map = seg->hasR && seg->hasW;
 #  elif defined(VGA_amd64) || defined(VGA_ppc64be) || defined(VGA_ppc64le)  \
@@ -3093,6 +3093,11 @@ UWord evalCfiExpr ( const XArray* exprs, Int ix,
             case Creg_ARM64_SP: return eec->uregs->sp;
             case Creg_ARM64_X30: return eec->uregs->x30;
             case Creg_ARM64_X29: return eec->uregs->x29;
+#           elif defined(VGA_loongarch64)
+            case Creg_LOONGARCH64_PC: return eec->uregs->pc;
+            case Creg_LOONGARCH64_RA: return eec->uregs->ra;
+            case Creg_LOONGARCH64_SP: return eec->uregs->sp;
+            case Creg_LOONGARCH64_FP: return eec->uregs->fp;
 #           else
 #             error "Unsupported arch"
 #           endif
@@ -3366,6 +3371,13 @@ static Addr compute_cfa ( const D3UnwindRegs* uregs,
       case CFIC_ARM64_X29REL: 
          cfa = cfsi_m->cfa_off + uregs->x29;
          break;
+#     elif defined(VGA_loongarch64)
+      case CFIC_IA_SPREL:
+         cfa = cfsi_m->cfa_off + uregs->sp;
+         break;
+      case CFIC_IA_BPREL:
+         cfa = cfsi_m->cfa_off + uregs->fp;
+         break;
 #     else
 #       error "Unsupported arch"
 #     endif
@@ -3437,6 +3449,14 @@ Addr ML_(get_CFA) ( Addr ip, Addr sp, Addr fp,
      return compute_cfa(&uregs,
                         min_accessible,  max_accessible, ce->di, ce->cfsi_m);
    }
+#elif defined(VGA_loongarch64)
+   { D3UnwindRegs uregs;
+     uregs.pc = ip;
+     uregs.sp = sp;
+     uregs.fp = fp;
+     return compute_cfa(&uregs,
+                        min_accessible,  max_accessible, ce->di, ce->cfsi_m);
+   }
 
 #  else
    return 0; /* indicates failure */
@@ -3488,6 +3508,8 @@ void VG_(ppUnwindInfo) (Addr from, Addr to)
    For arm64, the unwound registers are: X29(FP) X30(LR) SP PC.
 
    For s390, the unwound registers are: R11(FP) R14(LR) R15(SP) F0..F7 PC.
+
+   For loongarch64, the unwound registers are: FP SP PC
 */
 Bool VG_(use_CF_info) ( /*MOD*/D3UnwindRegs* uregsHere,
                         Addr min_accessible,
@@ -3511,6 +3533,8 @@ Bool VG_(use_CF_info) ( /*MOD*/D3UnwindRegs* uregsHere,
 #  elif defined(VGA_ppc32) || defined(VGA_ppc64be) || defined(VGA_ppc64le)
 #  elif defined(VGP_arm64_linux)
    ipHere = uregsHere->pc;
+#  elif defined(VGA_loongarch64)
+   ipHere = uregsHere->pc;
 #  else
 #    error "Unknown arch"
 #  endif
@@ -3656,6 +3680,10 @@ Bool VG_(use_CF_info) ( /*MOD*/D3UnwindRegs* uregsHere,
    COMPUTE(uregsPrev.sp,  uregsHere->sp,  cfsi_m->sp_how,  cfsi_m->sp_off);
    COMPUTE(uregsPrev.x30, uregsHere->x30, cfsi_m->x30_how, cfsi_m->x30_off);
    COMPUTE(uregsPrev.x29, uregsHere->x29, cfsi_m->x29_how, cfsi_m->x29_off);
+#  elif defined(VGA_loongarch64)
+   COMPUTE(uregsPrev.pc, uregsHere->ra, cfsi_m->ra_how, cfsi_m->ra_off);
+   COMPUTE(uregsPrev.sp, uregsHere->sp, cfsi_m->sp_how, cfsi_m->sp_off);
+   COMPUTE(uregsPrev.fp, uregsHere->fp, cfsi_m->fp_how, cfsi_m->fp_off);
 #  else
 #    error "Unknown arch"
 #  endif
diff --git a/coregrind/m_debuginfo/priv_storage.h b/coregrind/m_debuginfo/priv_storage.h
index 441b379d2..41224a844 100644
--- a/coregrind/m_debuginfo/priv_storage.h
+++ b/coregrind/m_debuginfo/priv_storage.h
@@ -367,6 +367,19 @@ typedef
       Int   fp_off;
    }
    DiCfSI_m;
+#elif defined(VGA_loongarch64)
+typedef
+   struct {
+      UChar cfa_how;  /* a CFIC_ value */
+      UChar ra_how;   /* a CFIR_ value */
+      UChar sp_how;   /* a CFIR_ value */
+      UChar fp_how;   /* a CFIR_ value */
+      Int   cfa_off;
+      Int   ra_off;
+      Int   sp_off;
+      Int   fp_off;
+   }
+   DiCfSI_m;
 #else
 #  error "Unknown arch"
 #endif
@@ -422,7 +435,11 @@ typedef
       Creg_S390_SP,
       Creg_S390_FP,
       Creg_S390_LR,
-      Creg_MIPS_RA
+      Creg_MIPS_RA,
+      Creg_LOONGARCH64_PC,
+      Creg_LOONGARCH64_RA,
+      Creg_LOONGARCH64_SP,
+      Creg_LOONGARCH64_FP
    }
    CfiReg;
 
diff --git a/coregrind/m_debuginfo/readdwarf.c b/coregrind/m_debuginfo/readdwarf.c
index 7b8187ee6..13363aeeb 100644
--- a/coregrind/m_debuginfo/readdwarf.c
+++ b/coregrind/m_debuginfo/readdwarf.c
@@ -2066,6 +2066,10 @@ void ML_(read_debuginfo_dwarf1) (
 #  define FP_REG         30
 #  define SP_REG         29
 #  define RA_REG_DEFAULT 31
+#elif defined(VGP_loongarch64_linux)
+#  define FP_REG         22
+#  define SP_REG         3
+#  define RA_REG_DEFAULT 1
 #else
 #  error "Unknown platform"
 #endif
@@ -2084,6 +2088,8 @@ void ML_(read_debuginfo_dwarf1) (
 # define N_CFI_REGS 128
 #elif defined(VGP_s390x_linux)
 # define N_CFI_REGS 66
+#elif defined(VGP_loongarch64_linux)
+# define N_CFI_REGS 32
 #else
 # define N_CFI_REGS 20
 #endif
@@ -2310,6 +2316,10 @@ static void initUnwindContext ( /*OUT*/UnwindContext* ctx )
          start out as RR_Same. */
       ctx->state[j].reg[29/*FP*/].tag = RR_Same;
       ctx->state[j].reg[30/*LR*/].tag = RR_Same;
+#     elif defined(VGA_loongarch64)
+      /* Registers fp and ra start out implicitly as RR_Same. */
+      ctx->state[j].reg[FP_REG].tag = RR_Same;
+      ctx->state[j].reg[RA_REG_DEFAULT].tag = RR_Same;
 #     endif
    }
 }
@@ -2392,7 +2402,8 @@ static Bool summarise_context(/*OUT*/Addr* base,
    if (ctxs->cfa_is_regoff && ctxs->cfa_reg == SP_REG) {
       si_m->cfa_off = ctxs->cfa_off;
 #     if defined(VGA_x86) || defined(VGA_amd64) || defined(VGA_s390x) \
-         || defined(VGA_mips32) || defined(VGA_nanomips) || defined(VGA_mips64)
+         || defined(VGA_mips32) || defined(VGA_nanomips) || defined(VGA_mips64) \
+         || defined(VGA_loongarch64)
       si_m->cfa_how = CFIC_IA_SPREL;
 #     elif defined(VGA_arm)
       si_m->cfa_how = CFIC_ARM_R13REL;
@@ -2406,7 +2417,8 @@ static Bool summarise_context(/*OUT*/Addr* base,
    if (ctxs->cfa_is_regoff && ctxs->cfa_reg == FP_REG) {
       si_m->cfa_off = ctxs->cfa_off;
 #     if defined(VGA_x86) || defined(VGA_amd64) || defined(VGA_s390x) \
-         || defined(VGA_mips32) || defined(VGA_nanomips) || defined(VGA_mips64)
+         || defined(VGA_mips32) || defined(VGA_nanomips) || defined(VGA_mips64) \
+         || defined(VGA_loongarch64)
       si_m->cfa_how = CFIC_IA_BPREL;
 #     elif defined(VGA_arm)
       si_m->cfa_how = CFIC_ARM_R12REL;
@@ -2786,6 +2798,30 @@ static Bool summarise_context(/*OUT*/Addr* base,
 #  elif defined(VGA_ppc32) || defined(VGA_ppc64be) || defined(VGA_ppc64le)
    /* These don't use CFI based unwinding (is that really true?) */
 
+#  elif defined(VGA_loongarch64)
+
+   /* --- entire tail of this fn specialised for loongarch64 --- */
+
+   SUMMARISE_HOW(si_m->ra_how, si_m->ra_off, ctxs->reg[ctx->ra_reg]);
+   SUMMARISE_HOW(si_m->fp_how, si_m->fp_off, ctxs->reg[FP_REG]);
+
+   /* on loongarch64, it seems the old sp value before the call is always
+      the same as the CFA.  Therefore ... */
+   si_m->sp_how = CFIR_CFAREL;
+   si_m->sp_off = 0;
+
+   /* bogus looking range?  Note, we require that the difference is
+      representable in 32 bits. */
+   if (loc_start >= ctx->loc)
+      { why = 4; goto failed; }
+   if (ctx->loc - loc_start > 10000000 /* let's say */)
+      { why = 5; goto failed; }
+
+   *base = loc_start + ctx->initloc;
+   *len  = (UInt)(ctx->loc - loc_start);
+
+   return True;
+
 #  else
 #    error "Unknown arch"
 #  endif
@@ -2885,6 +2921,13 @@ static Int copy_convert_CfiExpr_tree ( XArray*        dstxa,
             return ML_(CfiExpr_CfiReg)( dstxa, Creg_ARM64_X30 );
 #        elif defined(VGA_ppc32) || defined(VGA_ppc64be) \
             || defined(VGA_ppc64le)
+#        elif defined(VGA_loongarch64)
+         if (dwreg == SP_REG)
+            return ML_(CfiExpr_CfiReg)( dstxa, Creg_LOONGARCH64_SP );
+         if (dwreg == FP_REG)
+            return ML_(CfiExpr_CfiReg)( dstxa, Creg_LOONGARCH64_FP );
+         if (dwreg == srcuc->ra_reg)
+            return ML_(CfiExpr_CfiReg)( dstxa, Creg_LOONGARCH64_RA );
 #        else
 #           error "Unknown arch"
 #        endif
diff --git a/coregrind/m_debuginfo/readelf.c b/coregrind/m_debuginfo/readelf.c
index 7a654e151..e3dc31b8d 100644
--- a/coregrind/m_debuginfo/readelf.c
+++ b/coregrind/m_debuginfo/readelf.c
@@ -1780,7 +1780,8 @@ static HChar* readlink_path (const HChar *path)
 
    while (tries > 0) {
       SysRes res;
-#if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+#if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+    || defined(VGP_loongarch64_linux)
       res = VG_(do_syscall4)(__NR_readlinkat, VKI_AT_FDCWD,
                                               (UWord)path, (UWord)buf, bufsiz);
 #elif defined(VGO_linux) || defined(VGO_darwin) || defined(VGO_freebsd)
@@ -2705,8 +2706,9 @@ Bool ML_(read_elf_object) ( struct _DebugInfo* di )
          || defined(VGP_arm_linux) || defined (VGP_s390x_linux) \
          || defined(VGP_mips32_linux) || defined(VGP_mips64_linux) \
          || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+         || defined(VGP_loongarch64_linux) \
          || defined(VGP_x86_solaris) || defined(VGP_amd64_solaris) \
-         || defined(VGP_x86_freebsd) || defined(VGP_amd64_freebsd)
+         || defined(VGP_x86_freebsd) || defined(VGP_amd64_freebsd) \
       /* Accept .plt where mapped as rx (code) */
       if (0 == VG_(strcmp)(name, ".plt")) {
          if (inrx && !di->plt_present) {
diff --git a/coregrind/m_debuginfo/storage.c b/coregrind/m_debuginfo/storage.c
index 148de6f17..40b992efa 100644
--- a/coregrind/m_debuginfo/storage.c
+++ b/coregrind/m_debuginfo/storage.c
@@ -260,6 +260,11 @@ void ML_(ppDiCfSI) ( const XArray* /* of CfiExpr */ exprs,
    SHOW_HOW(si_m->x30_how, si_m->x30_off);
    VG_(printf)(" X29=");
    SHOW_HOW(si_m->x29_how, si_m->x29_off);
+#  elif defined(VGP_loongarch64_linux)
+   VG_(printf)(" SP=");
+   SHOW_HOW(si_m->sp_how, si_m->sp_off);
+   VG_(printf)(" FP=");
+   SHOW_HOW(si_m->fp_how, si_m->fp_off);
 #  else
 #    error "Unknown arch"
 #  endif
@@ -1010,6 +1015,10 @@ static void ppCfiReg ( CfiReg reg )
       case Creg_S390_SP:   VG_(printf)("SP"); break;
       case Creg_S390_FP:   VG_(printf)("FP"); break;
       case Creg_S390_LR:   VG_(printf)("LR"); break;
+      case Creg_LOONGARCH64_PC: VG_(printf)("PC"); break;
+      case Creg_LOONGARCH64_RA: VG_(printf)("RA"); break;
+      case Creg_LOONGARCH64_SP: VG_(printf)("SP"); break;
+      case Creg_LOONGARCH64_FP: VG_(printf)("FP"); break;
       default: vg_assert(0);
    }
 }
diff --git a/coregrind/m_debuglog.c b/coregrind/m_debuglog.c
index e4ab846f5..11d2b02db 100644
--- a/coregrind/m_debuglog.c
+++ b/coregrind/m_debuglog.c
@@ -601,6 +601,41 @@ static UInt local_sys_getpid ( void )
    return a0;
 }
 
+#elif defined(VGP_loongarch64_linux)
+
+static UInt local_sys_write_stderr ( const HChar* buf, Int n )
+{
+   ULong ret;
+   __asm__ volatile (
+      "li.w    $a0, 2  \n\t" // stderr
+      "move    $a1, %1 \n\t"
+      "move    $a2, %2 \n\t"
+      "li.w    $a7, " VG_STRINGIFY(__NR_write) " \n\t"
+      "syscall 0       \n\t"
+      "move    %0, $a0 \n\t"
+      : "=r" (ret)
+      : "r" (buf), "r" (n)
+      : "memory", "$a0", "$a1", "$a2", "$a3", "$a4", "$a5", "$a6", "$a7",
+        "$t0", "$t1", "$t2", "$t3", "$t4", "$t5", "$t6", "$t7", "$t8"
+   );
+   return ret >= 0 ? (UInt)ret : -1;
+}
+
+static UInt local_sys_getpid ( void )
+{
+   ULong ret;
+   __asm__ volatile (
+      "li.w    $a7, " VG_STRINGIFY(__NR_getpid) " \n\t"
+      "syscall 0       \n\t"
+      "move    %0, $a0 \n\t"
+      : "=r" (ret)
+      :
+      : "memory", "$a0", "$a1", "$a2", "$a3", "$a4", "$a5", "$a6", "$a7",
+        "$t0", "$t1", "$t2", "$t3", "$t4", "$t5", "$t6", "$t7", "$t8"
+   );
+   return (UInt)ret;
+}
+
 #elif defined(VGP_x86_solaris)
 static UInt local_sys_write_stderr ( const HChar* buf, Int n )
 {
diff --git a/coregrind/m_dispatch/dispatch-loongarch64-linux.S b/coregrind/m_dispatch/dispatch-loongarch64-linux.S
new file mode 100644
index 000000000..dec165294
--- /dev/null
+++ b/coregrind/m_dispatch/dispatch-loongarch64-linux.S
@@ -0,0 +1,314 @@
+
+/*--------------------------------------------------------------------*/
+/*--- The core dispatch loop, for jumping to a code address.       ---*/
+/*---                                 dispatch-loongarch64-linux.S ---*/
+/*--------------------------------------------------------------------*/
+
+/*
+  This file is part of Valgrind, a dynamic binary instrumentation
+  framework.
+
+  Copyright (C) 2021-2022 Loongson Technology Corporation Limited
+
+  This program is free software; you can redistribute it and/or
+  modify it under the terms of the GNU General Public License as
+  published by the Free Software Foundation; either version 2 of the
+  License, or (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/>.
+
+  The GNU General Public License is contained in the file COPYING.
+*/
+
+#include "pub_core_basics_asm.h"
+
+#if defined(VGP_loongarch64_linux)
+
+#include "pub_core_dispatch_asm.h"
+#include "pub_core_transtab_asm.h"
+#include "libvex_guest_offsets.h"	/* for OFFSET_loongarch64_* */
+
+
+/*------------------------------------------------------------*/
+/*---                                                      ---*/
+/*--- The dispatch loop.  VG_(disp_run_translations) is    ---*/
+/*--- used to run all translations,                        ---*/
+/*--- including no-redir ones.                             ---*/
+/*---                                                      ---*/
+/*------------------------------------------------------------*/
+
+/*----------------------------------------------------*/
+/*--- Entry and preamble (set everything up)       ---*/
+/*----------------------------------------------------*/
+
+/* signature:
+void VG_(disp_run_translations)( UWord* two_words,
+                                 void*  guest_state,
+                                 Addr   host_addr );
+*/
+
+.text
+.globl VG_(disp_run_translations)
+VG_(disp_run_translations):
+   /* a0 holds two_words   */
+   /* a1 holds guest_state */
+   /* a2 holds host_addr   */
+
+   /* New stack frame.  Stack must remain 16 aligned (at least) */
+   addi.d   $sp, $sp, -96
+
+   /* Save ra */
+   st.d     $ra, $sp, 0
+
+   /* .. and s0 - s8 */
+   st.d     $s0, $sp, 8
+   st.d     $s1, $sp, 16
+   st.d     $s2, $sp, 24
+   st.d     $s3, $sp, 32
+   st.d     $s4, $sp, 40
+   st.d     $s5, $sp, 48
+   st.d     $s6, $sp, 56
+   st.d     $s7, $sp, 64
+   st.d     $s8, $sp, 72
+
+   /* ... and fp */
+   st.d     $fp, $sp, 80
+
+   /* and a0. In postamble it will be restored such that the
+      return values can be written */
+   st.d     $a0, $sp, 88
+
+   /* Load address of guest state into s8 */
+   move     $s8, $a1
+
+   /* and jump into the code cache.  Chained translations in
+      the code cache run, until for whatever reason, they can't
+      continue.  When that happens, the translation in question
+      will jump (or call) to one of the continuation points
+      VG_(cp_...) below. */
+   ibar     0              /* Insn sync barrier */
+   jr       $a2
+   /*NOTREACHED*/
+
+/*----------------------------------------------------*/
+/*--- Postamble and exit.                          ---*/
+/*----------------------------------------------------*/
+
+postamble:
+   /* At this point, a0 and a1 contain two
+      words to be returned to the caller.  a0
+      holds a TRC value, and a1 optionally may
+      hold another word (for CHAIN_ME exits, the
+      address of the place to patch.) */
+
+   /* Restore a0 from stack to t0; holds address of two_words */
+   ld.d     $t0, $sp, 88
+   st.d     $a0, $t0, 0    /* Store a0 to two_words[0] */
+   st.d     $a1, $t0, 8    /* Store a1 to two_words[1] */
+
+   /* Restore ra */
+   ld.d     $ra, $sp, 0
+
+   /* ... and s0 - s8 */
+   ld.d     $s0, $sp, 8
+   ld.d     $s1, $sp, 16
+   ld.d     $s2, $sp, 24
+   ld.d     $s3, $sp, 32
+   ld.d     $s4, $sp, 40
+   ld.d     $s5, $sp, 48
+   ld.d     $s6, $sp, 56
+   ld.d     $s7, $sp, 64
+   ld.d     $s8, $sp, 72
+
+   /* ... and fp */
+   ld.d     $fp, $sp, 80
+
+   addi.d   $sp, $sp, 96   /* Restore sp */
+   jr       $ra
+   /*NOTREACHED*/
+
+/*----------------------------------------------------*/
+/*--- Continuation points                          ---*/
+/*----------------------------------------------------*/
+
+/* ------ Chain me to slow entry point ------ */
+.globl VG_(disp_cp_chain_me_to_slowEP)
+VG_(disp_cp_chain_me_to_slowEP):
+   /* We got called.  The return address indicates
+      where the patching needs to happen.  Collect
+      the return address and, exit back to C land,
+      handing the caller the pair (Chain_me_S, RA) */
+   li.w     $a0, VG_TRC_CHAIN_ME_TO_SLOW_EP
+   move     $a1, $ra
+   /* 4 * 4 = mkLoadImm_EXACTLY4
+          4 = jirl $ra, $t0, 0 */
+   addi.d   $a1, $a1, -20
+   b        postamble
+   /*NOTREACHED*/
+
+/* ------ Chain me to fast entry point ------ */
+.globl VG_(disp_cp_chain_me_to_fastEP)
+VG_(disp_cp_chain_me_to_fastEP):
+   /* We got called.  The return address indicates
+      where the patching needs to happen.  Collect
+      the return address and, exit back to C land,
+      handing the caller the pair (Chain_me_S, RA) */
+   li.w     $a0, VG_TRC_CHAIN_ME_TO_FAST_EP
+   move     $a1, $ra
+   /* 4 * 4 = mkLoadImm_EXACTLY4
+      4     = jirl $ra, $t0, 0 */
+   addi.d   $a1, $a1, -20
+   b        postamble
+   /*NOTREACHED*/
+
+/* ------ Indirect but boring jump ------ */
+.globl VG_(disp_cp_xindir)
+VG_(disp_cp_xindir):
+   /* Where are we going? */
+   ld.d     $t0, $s8, OFFSET_loongarch64_PC
+
+   /* Stats only */
+   la.local $t4, VG_(stats__n_xIndirs_32)
+   ld.d     $t1, $t4, 0
+   addi.d   $t1, $t1, 1
+   st.w     $t1, $t4, 0
+
+   /* LIVE: s8 (guest state ptr), t0 (guest address to go to).
+      We use 6 temporaries:
+         t6 (to point at the relevant FastCacheSet),
+         t1, t2, t3 (scratch, for swapping entries within a set)
+         t4, t5 (other scratch)
+    */
+
+   /* Try a fast lookup in the translation cache.  This is pretty much
+      a handcoded version of VG_(lookupInFastCache). */
+
+   // Compute t6 = VG_TT_FAST_HASH(guest)
+   srli.d   $t6, $t0, 2                      // g2 = guest >> 2
+   srli.d   $t5, $t0, (VG_TT_FAST_BITS + 2)  // (g2 >> VG_TT_FAST_BITS)
+   xor      $t6, $t6, $t5                    // (g2 >> VG_TT_FAST_BITS) ^ g2
+   li.w     $t5, VG_TT_FAST_MASK
+   and      $t6, $t6, $t5                    // setNo
+
+   // Compute t6 = &VG_(tt_fast)[t6]
+   la.local $t5, VG_(tt_fast)
+   slli.d   $t6, $t6, VG_FAST_CACHE_SET_BITS
+   add.d    $t6, $t6, $t5
+
+   /* LIVE: s8 (guest state ptr), t0 (guest addr), t6 (cache set) */
+0: // try way 0
+   ld.d     $t4, $t6, FCS_g0   // .guest0
+   ld.d     $t5, $t6, FCS_h0   // .host0
+   bne      $t4, $t0, 1f       // cmp against .guest0
+   // hit at way 0
+   // goto .host0
+   jr       $t5
+   /*NOTREACHED*/
+
+1: // try way 1
+   ld.d     $t4, $t6, FCS_g1
+   bne      $t4, $t0, 2f       // cmp against .guest1
+   // hit at way 1; swap upwards
+   ld.d     $t1, $t6, FCS_g0   // $t1 = old .guest0
+   ld.d     $t2, $t6, FCS_h0   // $t2 = old .host0
+   ld.d     $t3, $t6, FCS_h1   // $t3 = old .host1
+   st.d     $t0, $t6, FCS_g0   // new .guest0 = guest
+   st.d     $t3, $t6, FCS_h0   // new .host0 = old .host1
+   st.d     $t1, $t6, FCS_g1   // new .guest1 = old .guest0
+   st.d     $t2, $t6, FCS_h1   // new .host1 = old .host0
+
+   // stats only
+   la.local $t4, VG_(stats__n_xIndir_hits1_32)
+   ld.d     $t5, $t4, 0
+   addi.d   $t5, $t5, 1
+   st.w     $t5, $t4, 0
+   // goto old .host1 a.k.a. new .host0
+   jr       $t3
+   /*NOTREACHED*/
+
+2: // try way 2
+   ld.d     $t4, $t6, FCS_g2
+   bne      $t4, $t0, 3f       // cmp against .guest2
+   // hit at way 2; swap upwards
+   ld.d     $t1, $t6, FCS_g1
+   ld.d     $t2, $t6, FCS_h1
+   ld.d     $t3, $t6, FCS_h2
+   st.d     $t0, $t6, FCS_g1
+   st.d     $t3, $t6, FCS_h1
+   st.d     $t1, $t6, FCS_g2
+   st.d     $t2, $t6, FCS_h2
+
+   // stats only
+   la.local $t4, VG_(stats__n_xIndir_hits2_32)
+   ld.d     $t5, $t4, 0
+   addi.d   $t5, $t5, 1
+   st.w     $t5, $t4, 0
+   // goto old .host2 a.k.a. new .host1
+   jr       $t3
+   /*NOTREACHED*/
+
+3: // try way 3
+   ld.d     $t4, $t6, FCS_g3
+   bne      $t4, $t0, 4f       // cmp against .guest3
+   // hit at way 3; swap upwards
+   ld.d     $t1, $t6, FCS_g2
+   ld.d     $t2, $t6, FCS_h2
+   ld.d     $t3, $t6, FCS_h3
+   st.d     $t0, $t6, FCS_g2
+   st.d     $t3, $t6, FCS_h2
+   st.d     $t1, $t6, FCS_g3
+   st.d     $t2, $t6, FCS_h3
+
+   // stats only
+   la.local $t4, VG_(stats__n_xIndir_hits3_32)
+   ld.d     $t5, $t4, 0
+   addi.d   $t5, $t5, 1
+   st.w     $t5, $t4, 0
+   // goto old .host3 a.k.a. new .host2
+   jr       $t3
+   /*NOTREACHED*/
+
+4: // fast lookup failed:
+   /* stats only */
+   la.local $t4, VG_(stats__n_xIndir_misses_32)
+   ld.d     $t5, $t4, 0
+   addi.d   $t5, $t5, 1
+   st.w     $t5, $t4, 0
+
+   li.w     $a0, VG_TRC_INNER_FASTMISS
+   move     $a1, $zero
+   b        postamble
+   /*NOTREACHED*/
+
+/* ------ Assisted jump ------ */
+.globl VG_(disp_cp_xassisted)
+VG_(disp_cp_xassisted):
+   /* guest-state-pointer contains the TRC. Put the value into the
+      return register */
+   move     $a0, $s8
+   move     $a1, $zero
+   b        postamble
+
+/* ------ Event check failed ------ */
+.globl VG_(disp_cp_evcheck_fail)
+VG_(disp_cp_evcheck_fail):
+   li.w     $a0, VG_TRC_INNER_COUNTERZERO
+   move     $a1, $zero
+   b        postamble
+
+.size VG_(disp_run_translations), .-VG_(disp_run_translations)
+
+#endif // defined(VGP_loongarch64_linux)
+
+/* Let the linker know we don't need an executable stack */
+MARK_STACK_NO_EXEC
+
+/*--------------------------------------------------------------------*/
+/*--- end                             dispatch-loongarch64-linux.S ---*/
+/*--------------------------------------------------------------------*/
diff --git a/coregrind/m_gdbserver/loongarch-base64-valgrind-s1.xml b/coregrind/m_gdbserver/loongarch-base64-valgrind-s1.xml
new file mode 100644
index 000000000..cab700cca
--- /dev/null
+++ b/coregrind/m_gdbserver/loongarch-base64-valgrind-s1.xml
@@ -0,0 +1,45 @@
+<?xml version="1.0"?>
+<!-- Copyright (C) 2007-2018 Free Software Foundation, Inc.
+
+     Copying and distribution of this file, with or without modification,
+     are permitted in any medium without royalty provided the copyright
+     notice and this notice are preserved.  -->
+
+<!DOCTYPE feature SYSTEM "gdb-target.dtd">
+<feature name="org.gnu.gdb.loongarch.base">
+  <reg name="r0s1" bitsize="64" type="uint64" group="general" regnum="0"/>
+  <reg name="r1s1" bitsize="64" type="code_ptr" group="general"/>
+  <reg name="r2s1" bitsize="64" type="data_ptr" group="general"/>
+  <reg name="r3s1" bitsize="64" type="data_ptr" group="general"/>
+  <reg name="r4s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="r5s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="r6s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="r7s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="r8s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="r9s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="r10s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="r11s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="r12s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="r13s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="r14s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="r15s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="r16s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="r17s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="r18s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="r19s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="r20s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="r21s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="r22s1" bitsize="64" type="data_ptr" group="general"/>
+  <reg name="r23s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="r24s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="r25s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="r26s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="r27s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="r28s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="r29s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="r30s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="r31s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="orig_a0s1" bitsize="64" type="uint64" group="general"/>
+  <reg name="pcs1" bitsize="64" type="code_ptr" group="general"/>
+  <reg name="badvs1" bitsize="64" type="code_ptr" group="general"/>
+</feature>
diff --git a/coregrind/m_gdbserver/loongarch-base64-valgrind-s2.xml b/coregrind/m_gdbserver/loongarch-base64-valgrind-s2.xml
new file mode 100644
index 000000000..cbacbbbbe
--- /dev/null
+++ b/coregrind/m_gdbserver/loongarch-base64-valgrind-s2.xml
@@ -0,0 +1,45 @@
+<?xml version="1.0"?>
+<!-- Copyright (C) 2007-2018 Free Software Foundation, Inc.
+
+     Copying and distribution of this file, with or without modification,
+     are permitted in any medium without royalty provided the copyright
+     notice and this notice are preserved.  -->
+
+<!DOCTYPE feature SYSTEM "gdb-target.dtd">
+<feature name="org.gnu.gdb.loongarch.base">
+  <reg name="r0s2" bitsize="64" type="uint64" group="general" regnum="0"/>
+  <reg name="r1s2" bitsize="64" type="code_ptr" group="general"/>
+  <reg name="r2s2" bitsize="64" type="data_ptr" group="general"/>
+  <reg name="r3s2" bitsize="64" type="data_ptr" group="general"/>
+  <reg name="r4s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="r5s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="r6s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="r7s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="r8s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="r9s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="r10s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="r11s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="r12s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="r13s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="r14s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="r15s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="r16s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="r17s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="r18s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="r19s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="r20s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="r21s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="r22s2" bitsize="64" type="data_ptr" group="general"/>
+  <reg name="r23s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="r24s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="r25s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="r26s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="r27s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="r28s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="r29s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="r30s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="r31s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="orig_a0s2" bitsize="64" type="uint64" group="general"/>
+  <reg name="pcs2" bitsize="64" type="code_ptr" group="general"/>
+  <reg name="badvs2" bitsize="64" type="code_ptr" group="general"/>
+</feature>
diff --git a/coregrind/m_gdbserver/loongarch-base64.xml b/coregrind/m_gdbserver/loongarch-base64.xml
new file mode 100644
index 000000000..fadca8b9e
--- /dev/null
+++ b/coregrind/m_gdbserver/loongarch-base64.xml
@@ -0,0 +1,45 @@
+<?xml version="1.0"?>
+<!-- Copyright (C) 2007-2018 Free Software Foundation, Inc.
+
+     Copying and distribution of this file, with or without modification,
+     are permitted in any medium without royalty provided the copyright
+     notice and this notice are preserved.  -->
+
+<!DOCTYPE feature SYSTEM "gdb-target.dtd">
+<feature name="org.gnu.gdb.loongarch.base">
+  <reg name="r0" bitsize="64" type="uint64" group="general" regnum="0"/>
+  <reg name="r1" bitsize="64" type="code_ptr" group="general"/>
+  <reg name="r2" bitsize="64" type="data_ptr" group="general"/>
+  <reg name="r3" bitsize="64" type="data_ptr" group="general"/>
+  <reg name="r4" bitsize="64" type="uint64" group="general"/>
+  <reg name="r5" bitsize="64" type="uint64" group="general"/>
+  <reg name="r6" bitsize="64" type="uint64" group="general"/>
+  <reg name="r7" bitsize="64" type="uint64" group="general"/>
+  <reg name="r8" bitsize="64" type="uint64" group="general"/>
+  <reg name="r9" bitsize="64" type="uint64" group="general"/>
+  <reg name="r10" bitsize="64" type="uint64" group="general"/>
+  <reg name="r11" bitsize="64" type="uint64" group="general"/>
+  <reg name="r12" bitsize="64" type="uint64" group="general"/>
+  <reg name="r13" bitsize="64" type="uint64" group="general"/>
+  <reg name="r14" bitsize="64" type="uint64" group="general"/>
+  <reg name="r15" bitsize="64" type="uint64" group="general"/>
+  <reg name="r16" bitsize="64" type="uint64" group="general"/>
+  <reg name="r17" bitsize="64" type="uint64" group="general"/>
+  <reg name="r18" bitsize="64" type="uint64" group="general"/>
+  <reg name="r19" bitsize="64" type="uint64" group="general"/>
+  <reg name="r20" bitsize="64" type="uint64" group="general"/>
+  <reg name="r21" bitsize="64" type="uint64" group="general"/>
+  <reg name="r22" bitsize="64" type="data_ptr" group="general"/>
+  <reg name="r23" bitsize="64" type="uint64" group="general"/>
+  <reg name="r24" bitsize="64" type="uint64" group="general"/>
+  <reg name="r25" bitsize="64" type="uint64" group="general"/>
+  <reg name="r26" bitsize="64" type="uint64" group="general"/>
+  <reg name="r27" bitsize="64" type="uint64" group="general"/>
+  <reg name="r28" bitsize="64" type="uint64" group="general"/>
+  <reg name="r29" bitsize="64" type="uint64" group="general"/>
+  <reg name="r30" bitsize="64" type="uint64" group="general"/>
+  <reg name="r31" bitsize="64" type="uint64" group="general"/>
+  <reg name="orig_a0" bitsize="64" type="uint64" group="general"/>
+  <reg name="pc" bitsize="64" type="code_ptr" group="general"/>
+  <reg name="badv" bitsize="64" type="code_ptr" group="general"/>
+</feature>
diff --git a/coregrind/m_gdbserver/loongarch-fpu64-valgrind-s1.xml b/coregrind/m_gdbserver/loongarch-fpu64-valgrind-s1.xml
new file mode 100644
index 000000000..b5c7cab50
--- /dev/null
+++ b/coregrind/m_gdbserver/loongarch-fpu64-valgrind-s1.xml
@@ -0,0 +1,57 @@
+<?xml version="1.0"?>
+<!-- Copyright (C) 2007-2018 Free Software Foundation, Inc.
+
+     Copying and distribution of this file, with or without modification,
+     are permitted in any medium without royalty provided the copyright
+     notice and this notice are preserved.  -->
+
+<!DOCTYPE feature SYSTEM "gdb-target.dtd">
+<feature name="org.gnu.gdb.loongarch.fpu.valgrind.s1">
+
+  <union id="fpu64type">
+    <field name="f" type="ieee_single"/>
+    <field name="d" type="ieee_double"/>
+  </union>
+
+  <reg name="f0s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f1s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f2s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f3s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f4s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f5s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f6s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f7s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f8s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f9s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f10s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f11s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f12s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f13s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f14s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f15s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f16s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f17s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f18s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f19s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f20s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f21s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f22s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f23s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f24s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f25s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f26s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f27s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f28s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f29s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f30s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f31s1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="fcc0s1" bitsize="8" type="uint8" group="float"/>
+  <reg name="fcc1s1" bitsize="8" type="uint8" group="float"/>
+  <reg name="fcc2s1" bitsize="8" type="uint8" group="float"/>
+  <reg name="fcc3s1" bitsize="8" type="uint8" group="float"/>
+  <reg name="fcc4s1" bitsize="8" type="uint8" group="float"/>
+  <reg name="fcc5s1" bitsize="8" type="uint8" group="float"/>
+  <reg name="fcc6s1" bitsize="8" type="uint8" group="float"/>
+  <reg name="fcc7s1" bitsize="8" type="uint8" group="float"/>
+  <reg name="fcsrs1" bitsize="32" type="uint32" group="float"/>
+</feature>
diff --git a/coregrind/m_gdbserver/loongarch-fpu64-valgrind-s2.xml b/coregrind/m_gdbserver/loongarch-fpu64-valgrind-s2.xml
new file mode 100644
index 000000000..501660ebb
--- /dev/null
+++ b/coregrind/m_gdbserver/loongarch-fpu64-valgrind-s2.xml
@@ -0,0 +1,57 @@
+<?xml version="1.0"?>
+<!-- Copyright (C) 2007-2018 Free Software Foundation, Inc.
+
+     Copying and distribution of this file, with or without modification,
+     are permitted in any medium without royalty provided the copyright
+     notice and this notice are preserved.  -->
+
+<!DOCTYPE feature SYSTEM "gdb-target.dtd">
+<feature name="org.gnu.gdb.loongarch.fpu.valgrind.s2">
+
+  <union id="fpu64type">
+    <field name="f" type="ieee_single"/>
+    <field name="d" type="ieee_double"/>
+  </union>
+
+  <reg name="f0s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f1s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f2s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f3s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f4s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f5s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f6s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f7s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f8s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f9s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f10s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f11s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f12s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f13s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f14s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f15s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f16s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f17s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f18s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f19s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f20s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f21s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f22s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f23s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f24s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f25s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f26s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f27s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f28s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f29s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f30s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f31s2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="fcc0s2" bitsize="8" type="uint8" group="float"/>
+  <reg name="fcc1s2" bitsize="8" type="uint8" group="float"/>
+  <reg name="fcc2s2" bitsize="8" type="uint8" group="float"/>
+  <reg name="fcc3s2" bitsize="8" type="uint8" group="float"/>
+  <reg name="fcc4s2" bitsize="8" type="uint8" group="float"/>
+  <reg name="fcc5s2" bitsize="8" type="uint8" group="float"/>
+  <reg name="fcc6s2" bitsize="8" type="uint8" group="float"/>
+  <reg name="fcc7s2" bitsize="8" type="uint8" group="float"/>
+  <reg name="fcsrs2" bitsize="32" type="uint32" group="float"/>
+</feature>
diff --git a/coregrind/m_gdbserver/loongarch-fpu64.xml b/coregrind/m_gdbserver/loongarch-fpu64.xml
new file mode 100644
index 000000000..74ab55a01
--- /dev/null
+++ b/coregrind/m_gdbserver/loongarch-fpu64.xml
@@ -0,0 +1,57 @@
+<?xml version="1.0"?>
+<!-- Copyright (C) 2007-2018 Free Software Foundation, Inc.
+
+     Copying and distribution of this file, with or without modification,
+     are permitted in any medium without royalty provided the copyright
+     notice and this notice are preserved.  -->
+
+<!DOCTYPE feature SYSTEM "gdb-target.dtd">
+<feature name="org.gnu.gdb.loongarch.fpu">
+
+  <union id="fpu64type">
+    <field name="f" type="ieee_single"/>
+    <field name="d" type="ieee_double"/>
+  </union>
+
+  <reg name="f0" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f1" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f2" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f3" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f4" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f5" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f6" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f7" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f8" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f9" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f10" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f11" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f12" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f13" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f14" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f15" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f16" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f17" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f18" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f19" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f20" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f21" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f22" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f23" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f24" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f25" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f26" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f27" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f28" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f29" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f30" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="f31" bitsize="64" type="fpu64type" group="float"/>
+  <reg name="fcc0" bitsize="8" type="uint8" group="float"/>
+  <reg name="fcc1" bitsize="8" type="uint8" group="float"/>
+  <reg name="fcc2" bitsize="8" type="uint8" group="float"/>
+  <reg name="fcc3" bitsize="8" type="uint8" group="float"/>
+  <reg name="fcc4" bitsize="8" type="uint8" group="float"/>
+  <reg name="fcc5" bitsize="8" type="uint8" group="float"/>
+  <reg name="fcc6" bitsize="8" type="uint8" group="float"/>
+  <reg name="fcc7" bitsize="8" type="uint8" group="float"/>
+  <reg name="fcsr" bitsize="32" type="uint32" group="float"/>
+</feature>
diff --git a/coregrind/m_gdbserver/loongarch64-linux-valgrind.xml b/coregrind/m_gdbserver/loongarch64-linux-valgrind.xml
new file mode 100644
index 000000000..8915a72a9
--- /dev/null
+++ b/coregrind/m_gdbserver/loongarch64-linux-valgrind.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0"?>
+<!-- Copyright (C) 2007-2018 Free Software Foundation, Inc.
+
+     Copying and distribution of this file, with or without modification,
+     are permitted in any medium without royalty provided the copyright
+     notice and this notice are preserved.  -->
+
+<!DOCTYPE feature SYSTEM "gdb-target.dtd">
+<target>
+  <architecture>loongarch</architecture>
+  <osabi>GNU/Linux</osabi>
+  <xi:include href="loongarch-base64.xml"/>
+  <xi:include href="loongarch-fpu64.xml"/>
+  <xi:include href="loongarch-base64-valgrind-s1.xml"/>
+  <xi:include href="loongarch-fpu64-valgrind-s1.xml"/>
+  <xi:include href="loongarch-base64-valgrind-s2.xml"/>
+  <xi:include href="loongarch-fpu64-valgrind-s2.xml"/>
+</target>
diff --git a/coregrind/m_gdbserver/loongarch64-linux.xml b/coregrind/m_gdbserver/loongarch64-linux.xml
new file mode 100644
index 000000000..f1eed8338
--- /dev/null
+++ b/coregrind/m_gdbserver/loongarch64-linux.xml
@@ -0,0 +1,14 @@
+<?xml version="1.0"?>
+<!-- Copyright (C) 2007-2018 Free Software Foundation, Inc.
+
+     Copying and distribution of this file, with or without modification,
+     are permitted in any medium without royalty provided the copyright
+     notice and this notice are preserved.  -->
+
+<!DOCTYPE feature SYSTEM "gdb-target.dtd">
+<target>
+  <architecture>loongarch</architecture>
+  <osabi>GNU/Linux</osabi>
+  <xi:include href="loongarch-base64.xml"/>
+  <xi:include href="loongarch-fpu64.xml"/>
+</target>
diff --git a/coregrind/m_gdbserver/target.c b/coregrind/m_gdbserver/target.c
index f9f32f4aa..e97bd642e 100644
--- a/coregrind/m_gdbserver/target.c
+++ b/coregrind/m_gdbserver/target.c
@@ -867,6 +867,8 @@ void valgrind_initialize_target(void)
    mips64_init_architecture(&the_low_target);
 #elif defined(VGA_nanomips)
    nanomips_init_architecture(&the_low_target);
+#elif defined(VGA_loongarch64)
+   loongarch64_init_architecture(&the_low_target);
 #else
    #error "architecture missing in target.c valgrind_initialize_target"
 #endif
diff --git a/coregrind/m_gdbserver/valgrind-low-loongarch64.c b/coregrind/m_gdbserver/valgrind-low-loongarch64.c
new file mode 100644
index 000000000..6021c795f
--- /dev/null
+++ b/coregrind/m_gdbserver/valgrind-low-loongarch64.c
@@ -0,0 +1,272 @@
+/* Low level interface to valgrind, for the remote server for GDB integrated
+   in valgrind.
+   Copyright (C) 2021
+   Free Software Foundation, Inc.
+
+   This file is part of VALGRIND.
+   It has been inspired from files from gdbserver in gdb 13.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+#include "server.h"
+#include "target.h"
+#include "regdef.h"
+#include "regcache.h"
+
+#include "pub_core_machine.h"
+#include "pub_core_debuginfo.h"
+#include "pub_core_threadstate.h"
+#include "pub_core_transtab.h"
+#include "pub_core_gdbserver.h"
+
+#include "valgrind_low.h"
+
+#include "libvex_guest_loongarch64.h"
+
+static struct reg regs[] = {
+   { "r0",      0,    64 },
+   { "r1",      64,   64 },
+   { "r2",      128,  64 },
+   { "r3",      192,  64 },
+   { "r4",      256,  64 },
+   { "r5",      320,  64 },
+   { "r6",      384,  64 },
+   { "r7",      448,  64 },
+   { "r8",      512,  64 },
+   { "r9",      576,  64 },
+   { "r10",     640,  64 },
+   { "r11",     704,  64 },
+   { "r12",     768,  64 },
+   { "r13",     832,  64 },
+   { "r14",     896,  64 },
+   { "r15",     960,  64 },
+   { "r16",     1024, 64 },
+   { "r17",     1088, 64 },
+   { "r18",     1152, 64 },
+   { "r19",     1216, 64 },
+   { "r20",     1280, 64 },
+   { "r21",     1344, 64 },
+   { "r22",     1408, 64 },
+   { "r23",     1472, 64 },
+   { "r24",     1536, 64 },
+   { "r25",     1600, 64 },
+   { "r26",     1664, 64 },
+   { "r27",     1728, 64 },
+   { "r28",     1792, 64 },
+   { "r29",     1856, 64 },
+   { "r30",     1920, 64 },
+   { "r31",     1984, 64 },
+   { "orig_a0", 2048, 64 },
+   { "pc",      2112, 64 },
+   { "badv",    2176, 64 },
+   { "f0",      2240, 64 },
+   { "f1",      2304, 64 },
+   { "f2",      2368, 64 },
+   { "f3",      2432, 64 },
+   { "f4",      2496, 64 },
+   { "f5",      2560, 64 },
+   { "f6",      2624, 64 },
+   { "f7",      2688, 64 },
+   { "f8",      2752, 64 },
+   { "f9",      2816, 64 },
+   { "f10",     2880, 64 },
+   { "f11",     2944, 64 },
+   { "f12",     3008, 64 },
+   { "f13",     3072, 64 },
+   { "f14",     3136, 64 },
+   { "f15",     3200, 64 },
+   { "f16",     3264, 64 },
+   { "f17",     3328, 64 },
+   { "f18",     3392, 64 },
+   { "f19",     3456, 64 },
+   { "f20",     3520, 64 },
+   { "f21",     3584, 64 },
+   { "f22",     3648, 64 },
+   { "f23",     3712, 64 },
+   { "f24",     3776, 64 },
+   { "f25",     3840, 64 },
+   { "f26",     3904, 64 },
+   { "f27",     3968, 64 },
+   { "f28",     4032, 64 },
+   { "f29",     4096, 64 },
+   { "f30",     4160, 64 },
+   { "f31",     4224, 64 },
+   { "fcc0",    4288, 8  },
+   { "fcc1",    4296, 8  },
+   { "fcc2",    4304, 8  },
+   { "fcc3",    4312, 8  },
+   { "fcc4",    4320, 8  },
+   { "fcc5",    4328, 8  },
+   { "fcc6",    4336, 8  },
+   { "fcc7",    4344, 8  },
+   { "fcsr",    4352, 32 }
+};
+
+#define num_regs (sizeof (regs) / sizeof (regs[0]))
+
+static const char* expedite_regs[] = { "r3", "pc", NULL };
+
+static
+CORE_ADDR get_pc (void)
+{
+   unsigned long pc;
+
+   collect_register_by_name ("pc", &pc);
+
+   dlog(1, "stop pc is %p\n", (void*) pc);
+   return pc;
+}
+
+static
+void set_pc (CORE_ADDR newpc)
+{
+   supply_register_by_name ("pc", &newpc);
+}
+
+/* store registers in the guest state (gdbserver_to_valgrind)
+   or fetch register from the guest state (valgrind_to_gdbserver). */
+static
+void transfer_register (ThreadId tid, int abs_regno, void* buf,
+                        transfer_direction dir, int size, Bool* mod)
+{
+   ThreadState* tst = VG_(get_ThreadState)(tid);
+   int set = abs_regno / num_regs;
+   int regno = abs_regno % num_regs;
+   *mod = False;
+
+   VexGuestLOONGARCH64State* loongarch64 = (VexGuestLOONGARCH64State*) get_arch (set, tst);
+
+   switch (regno) {
+   // numbers here have to match the order of regs above
+   // Attention: gdb order does not match valgrind order.
+   case 0:  VG_(transfer) (&loongarch64->guest_R0,   buf, dir, size, mod); break;
+   case 1:  VG_(transfer) (&loongarch64->guest_R1,   buf, dir, size, mod); break;
+   case 2:  VG_(transfer) (&loongarch64->guest_R2,   buf, dir, size, mod); break;
+   case 3:  VG_(transfer) (&loongarch64->guest_R3,   buf, dir, size, mod); break;
+   case 4:  VG_(transfer) (&loongarch64->guest_R4,   buf, dir, size, mod); break;
+   case 5:  VG_(transfer) (&loongarch64->guest_R5,   buf, dir, size, mod); break;
+   case 6:  VG_(transfer) (&loongarch64->guest_R6,   buf, dir, size, mod); break;
+   case 7:  VG_(transfer) (&loongarch64->guest_R7,   buf, dir, size, mod); break;
+   case 8:  VG_(transfer) (&loongarch64->guest_R8,   buf, dir, size, mod); break;
+   case 9:  VG_(transfer) (&loongarch64->guest_R9,   buf, dir, size, mod); break;
+   case 10: VG_(transfer) (&loongarch64->guest_R10,  buf, dir, size, mod); break;
+   case 11: VG_(transfer) (&loongarch64->guest_R11,  buf, dir, size, mod); break;
+   case 12: VG_(transfer) (&loongarch64->guest_R12,  buf, dir, size, mod); break;
+   case 13: VG_(transfer) (&loongarch64->guest_R13,  buf, dir, size, mod); break;
+   case 14: VG_(transfer) (&loongarch64->guest_R14,  buf, dir, size, mod); break;
+   case 15: VG_(transfer) (&loongarch64->guest_R15,  buf, dir, size, mod); break;
+   case 16: VG_(transfer) (&loongarch64->guest_R16,  buf, dir, size, mod); break;
+   case 17: VG_(transfer) (&loongarch64->guest_R17,  buf, dir, size, mod); break;
+   case 18: VG_(transfer) (&loongarch64->guest_R18,  buf, dir, size, mod); break;
+   case 19: VG_(transfer) (&loongarch64->guest_R19,  buf, dir, size, mod); break;
+   case 20: VG_(transfer) (&loongarch64->guest_R20,  buf, dir, size, mod); break;
+   case 21: VG_(transfer) (&loongarch64->guest_R21,  buf, dir, size, mod); break;
+   case 22: VG_(transfer) (&loongarch64->guest_R22,  buf, dir, size, mod); break;
+   case 23: VG_(transfer) (&loongarch64->guest_R23,  buf, dir, size, mod); break;
+   case 24: VG_(transfer) (&loongarch64->guest_R24,  buf, dir, size, mod); break;
+   case 25: VG_(transfer) (&loongarch64->guest_R25,  buf, dir, size, mod); break;
+   case 26: VG_(transfer) (&loongarch64->guest_R26,  buf, dir, size, mod); break;
+   case 27: VG_(transfer) (&loongarch64->guest_R27,  buf, dir, size, mod); break;
+   case 28: VG_(transfer) (&loongarch64->guest_R28,  buf, dir, size, mod); break;
+   case 29: VG_(transfer) (&loongarch64->guest_R29,  buf, dir, size, mod); break;
+   case 30: VG_(transfer) (&loongarch64->guest_R30,  buf, dir, size, mod); break;
+   case 31: VG_(transfer) (&loongarch64->guest_R31,  buf, dir, size, mod); break;
+   case 32: *mod = False; break; // GDBTD?? arg0
+   case 33: VG_(transfer) (&loongarch64->guest_PC,   buf, dir, size, mod); break;
+   case 34: *mod = False; break; // GDBTD?? badvaddr
+   case 35: VG_(transfer) (&loongarch64->guest_X0,   buf, dir, size, mod); break;
+   case 36: VG_(transfer) (&loongarch64->guest_X1,   buf, dir, size, mod); break;
+   case 37: VG_(transfer) (&loongarch64->guest_X2,   buf, dir, size, mod); break;
+   case 38: VG_(transfer) (&loongarch64->guest_X3,   buf, dir, size, mod); break;
+   case 39: VG_(transfer) (&loongarch64->guest_X4,   buf, dir, size, mod); break;
+   case 40: VG_(transfer) (&loongarch64->guest_X5,   buf, dir, size, mod); break;
+   case 41: VG_(transfer) (&loongarch64->guest_X6,   buf, dir, size, mod); break;
+   case 42: VG_(transfer) (&loongarch64->guest_X7,   buf, dir, size, mod); break;
+   case 43: VG_(transfer) (&loongarch64->guest_X8,   buf, dir, size, mod); break;
+   case 44: VG_(transfer) (&loongarch64->guest_X9,   buf, dir, size, mod); break;
+   case 45: VG_(transfer) (&loongarch64->guest_X10,  buf, dir, size, mod); break;
+   case 46: VG_(transfer) (&loongarch64->guest_X11,  buf, dir, size, mod); break;
+   case 47: VG_(transfer) (&loongarch64->guest_X12,  buf, dir, size, mod); break;
+   case 48: VG_(transfer) (&loongarch64->guest_X13,  buf, dir, size, mod); break;
+   case 49: VG_(transfer) (&loongarch64->guest_X14,  buf, dir, size, mod); break;
+   case 50: VG_(transfer) (&loongarch64->guest_X15,  buf, dir, size, mod); break;
+   case 51: VG_(transfer) (&loongarch64->guest_X16,  buf, dir, size, mod); break;
+   case 52: VG_(transfer) (&loongarch64->guest_X17,  buf, dir, size, mod); break;
+   case 53: VG_(transfer) (&loongarch64->guest_X18,  buf, dir, size, mod); break;
+   case 54: VG_(transfer) (&loongarch64->guest_X19,  buf, dir, size, mod); break;
+   case 55: VG_(transfer) (&loongarch64->guest_X20,  buf, dir, size, mod); break;
+   case 56: VG_(transfer) (&loongarch64->guest_X21,  buf, dir, size, mod); break;
+   case 57: VG_(transfer) (&loongarch64->guest_X22,  buf, dir, size, mod); break;
+   case 58: VG_(transfer) (&loongarch64->guest_X23,  buf, dir, size, mod); break;
+   case 59: VG_(transfer) (&loongarch64->guest_X24,  buf, dir, size, mod); break;
+   case 60: VG_(transfer) (&loongarch64->guest_X25,  buf, dir, size, mod); break;
+   case 61: VG_(transfer) (&loongarch64->guest_X26,  buf, dir, size, mod); break;
+   case 62: VG_(transfer) (&loongarch64->guest_X27,  buf, dir, size, mod); break;
+   case 63: VG_(transfer) (&loongarch64->guest_X28,  buf, dir, size, mod); break;
+   case 64: VG_(transfer) (&loongarch64->guest_X29,  buf, dir, size, mod); break;
+   case 65: VG_(transfer) (&loongarch64->guest_X30,  buf, dir, size, mod); break;
+   case 66: VG_(transfer) (&loongarch64->guest_X31,  buf, dir, size, mod); break;
+   case 67: VG_(transfer) (&loongarch64->guest_FCC0, buf, dir, size, mod); break;
+   case 68: VG_(transfer) (&loongarch64->guest_FCC1, buf, dir, size, mod); break;
+   case 69: VG_(transfer) (&loongarch64->guest_FCC2, buf, dir, size, mod); break;
+   case 70: VG_(transfer) (&loongarch64->guest_FCC3, buf, dir, size, mod); break;
+   case 71: VG_(transfer) (&loongarch64->guest_FCC4, buf, dir, size, mod); break;
+   case 72: VG_(transfer) (&loongarch64->guest_FCC5, buf, dir, size, mod); break;
+   case 73: VG_(transfer) (&loongarch64->guest_FCC6, buf, dir, size, mod); break;
+   case 74: VG_(transfer) (&loongarch64->guest_FCC7, buf, dir, size, mod); break;
+   case 75: VG_(transfer) (&loongarch64->guest_FCSR, buf, dir, size, mod); break;
+   default: vg_assert(0);
+   }
+}
+
+static
+const char* target_xml (Bool shadow_mode)
+{
+   if (shadow_mode) {
+      return "loongarch64-linux-valgrind.xml";
+   } else {
+      return "loongarch64-linux.xml";
+   }
+}
+
+static CORE_ADDR** target_get_dtv (ThreadState* tst)
+{
+   VexGuestLOONGARCH64State* loongarch64 = (VexGuestLOONGARCH64State*)&tst->arch.vex;
+   // Top of LoongArch tcbhead structure is located 0x0 bytes before the value
+   // of $r2. Dtv is the first of two pointers in tcbhead structure.
+   // More details can be found in GLIBC/sysdeps/nptl/tls.h.
+   return (CORE_ADDR**)((CORE_ADDR)loongarch64->guest_R2
+                        - 0x0 - 2 * sizeof(CORE_ADDR));
+}
+
+static struct valgrind_target_ops low_target = {
+   num_regs,
+   3, // SP
+   regs,
+   transfer_register,
+   get_pc,
+   set_pc,
+   "loongarch64",
+   target_xml,
+   target_get_dtv
+};
+
+void loongarch64_init_architecture (struct valgrind_target_ops* target)
+{
+   *target = low_target;
+   set_register_cache (regs, num_regs);
+   gdbserver_expedite_regs = expedite_regs;
+}
diff --git a/coregrind/m_gdbserver/valgrind_low.h b/coregrind/m_gdbserver/valgrind_low.h
index d8ae3c908..3393c3241 100644
--- a/coregrind/m_gdbserver/valgrind_low.h
+++ b/coregrind/m_gdbserver/valgrind_low.h
@@ -109,5 +109,6 @@ extern void s390x_init_architecture (struct valgrind_target_ops *target);
 extern void mips32_init_architecture (struct valgrind_target_ops *target);
 extern void mips64_init_architecture (struct valgrind_target_ops *target);
 extern void nanomips_init_architecture (struct valgrind_target_ops *target);
+extern void loongarch64_init_architecture (struct valgrind_target_ops *target);
 
 #endif
diff --git a/coregrind/m_initimg/initimg-linux.c b/coregrind/m_initimg/initimg-linux.c
index 7680baa8e..dcda61e4f 100644
--- a/coregrind/m_initimg/initimg-linux.c
+++ b/coregrind/m_initimg/initimg-linux.c
@@ -914,7 +914,8 @@ Addr setup_client_stack( void*  init_sp,
             && !defined(VGP_ppc64le_linux) \
             && !defined(VGP_mips32_linux) && !defined(VGP_mips64_linux) \
             && !defined(VGP_nanomips_linux) \
-            && !defined(VGP_s390x_linux)
+            && !defined(VGP_s390x_linux) \
+            && !defined(VGP_loongarch64_linux)
          case AT_SYSINFO_EHDR: {
             /* Trash this, because we don't reproduce it */
             const NSegment* ehdrseg = VG_(am_find_nsegment)((Addr)auxv->u.a_ptr);
@@ -1345,6 +1346,20 @@ void VG_(ii_finalise_image)( IIFinaliseImageInfo iifii )
    arch->vex.guest_PC = iifii.initial_client_IP;
    arch->vex.guest_r31 = iifii.initial_client_SP;
 
+#  elif defined(VGP_loongarch64_linux)
+   vg_assert(0 == sizeof(VexGuestLOONGARCH64State) % LibVEX_GUEST_STATE_ALIGN);
+
+   /* Zero out the initial state, and set up the simulated FPU in a
+      sane way. */
+   LibVEX_GuestLOONGARCH64_initialise(&arch->vex);
+
+   /* Zero out the shadow areas. */
+   VG_(memset)(&arch->vex_shadow1, 0, sizeof(VexGuestLOONGARCH64State));
+   VG_(memset)(&arch->vex_shadow2, 0, sizeof(VexGuestLOONGARCH64State));
+
+   arch->vex.guest_R3 = iifii.initial_client_SP;
+   arch->vex.guest_PC = iifii.initial_client_IP;
+
 #  else
 #    error Unknown platform
 #  endif
diff --git a/coregrind/m_libcassert.c b/coregrind/m_libcassert.c
index 0b04bfcc1..c95253d33 100644
--- a/coregrind/m_libcassert.c
+++ b/coregrind/m_libcassert.c
@@ -264,6 +264,26 @@
         (srP)->misc.MIPS32.r31 = (UInt)ra;                \
         (srP)->misc.MIPS32.r28 = (UInt)gp;                \
       }
+#elif defined(VGP_loongarch64_linux)
+#  define GET_STARTREGS(srP)                              \
+   {                                                      \
+      ULong pc, sp, fp, ra;                               \
+      __asm__ __volatile__(                               \
+         "pcaddi %0, 0   \n\t"                            \
+         "move   %1, $sp \n\t"                            \
+         "move   %2, $fp \n\t"                            \
+         "move   %3, $ra \n\t"                            \
+         : "=r" (pc),                                     \
+           "=r" (sp),                                     \
+           "=r" (fp),                                     \
+           "=r" (ra)                                      \
+         : /* reads none */                               \
+         : /* no trashed */ );                            \
+      (srP)->r_pc = (ULong)pc;                            \
+      (srP)->r_sp = (ULong)sp;                            \
+      (srP)->misc.LOONGARCH64.r_fp = (ULong)fp;           \
+      (srP)->misc.LOONGARCH64.r_ra = (ULong)ra;           \
+   }
 #else
 #  error Unknown platform
 #endif
diff --git a/coregrind/m_libcfile.c b/coregrind/m_libcfile.c
index 5d3a349f2..bbbd4e7fb 100644
--- a/coregrind/m_libcfile.c
+++ b/coregrind/m_libcfile.c
@@ -264,7 +264,8 @@ Bool VG_(resolve_filemode) ( Int fd, Int * result )
 
 SysRes VG_(mknod) ( const HChar* pathname, Int mode, UWord dev )
 {
-#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+      || defined(VGP_loongarch64_linux)
    /* ARM64 wants to use __NR_mknodat rather than __NR_mknod. */
    SysRes res = VG_(do_syscall4)(__NR_mknodat,
                                  VKI_AT_FDCWD, (UWord)pathname, mode, dev);
@@ -290,7 +291,8 @@ SysRes VG_(mknod) ( const HChar* pathname, Int mode, UWord dev )
 
 SysRes VG_(open) ( const HChar* pathname, Int flags, Int mode )
 {
-#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+      || defined(VGP_loongarch64_linux)
    /* ARM64 wants to use __NR_openat rather than __NR_open. */
    SysRes res = VG_(do_syscall4)(__NR_openat,
                                  VKI_AT_FDCWD, (UWord)pathname, flags, mode);
@@ -384,7 +386,8 @@ Int VG_(pipe) ( Int fd[2] )
    } else {
       return -1;
    }
-#  elif defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+#  elif defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+        || defined(VGP_loongarch64_linux)
    SysRes res = VG_(do_syscall2)(__NR_pipe2, (UWord)fd, 0);
    return sr_isError(res) ? -1 : 0;
 #  elif defined(VGO_linux)
@@ -517,12 +520,19 @@ SysRes VG_(stat) ( const HChar* file_name, struct vg_stat* vgbuf )
    { struct vki_statx buf;
      res = VG_(do_syscall5)(__NR_statx, VKI_AT_FDCWD, (UWord)file_name, 0,
                             VKI_STATX_ALL, (UWord)&buf);
+#    if defined(VGP_loongarch64_linux)
+     /* On LoongArch64 Linux platform, only statx is available. */
+     if (!sr_isError(res))
+        TRANSLATE_statx_TO_vg_stat(vgbuf, &buf);
+     return res;
+#    else
      if (!(sr_isError(res) && sr_Err(res) == VKI_ENOSYS)) {
         /* Success, or any failure except ENOSYS */
         if (!sr_isError(res))
            TRANSLATE_statx_TO_vg_stat(vgbuf, &buf);
         return res;
      }
+#    endif
    }
 #  endif
 #  if defined(VGO_linux) || defined(VGO_darwin)
@@ -602,12 +612,19 @@ Int VG_(fstat) ( Int fd, struct vg_stat* vgbuf )
      const char* file_name = "";
      res = VG_(do_syscall5)(__NR_statx, fd, (RegWord)file_name,
                             VKI_AT_EMPTY_PATH, VKI_STATX_ALL, (RegWord)&buf);
+#    if defined(VGP_loongarch64_linux)
+     /* On LoongArch64 Linux platform, only statx is available. */
+     if (!sr_isError(res))
+        TRANSLATE_statx_TO_vg_stat(vgbuf, &buf);
+     return sr_isError(res) ? (-1) : 0;
+#    else
      if (!(sr_isError(res) && sr_Err(res) == VKI_ENOSYS)) {
         /* Success, or any failure except ENOSYS */
         if (!sr_isError(res))
            TRANSLATE_statx_TO_vg_stat(vgbuf, &buf);
         return sr_isError(res) ? (-1) : 0;
      }
+#    endif
    }
 #endif
 #  if defined(VGO_linux) || defined(VGO_darwin)
@@ -731,7 +748,8 @@ SysRes VG_(dup) ( Int oldfd )
 
 SysRes VG_(dup2) ( Int oldfd, Int newfd )
 {
-#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+      || defined(VGP_loongarch64_linux)
    /* We only have dup3, that means we have to mimic dup2.
       The only real difference is when oldfd == newfd.
       dup3 always returns an error, but dup2 returns only an
@@ -777,7 +795,7 @@ Int VG_(rename) ( const HChar* old_name, const HChar* new_name )
 #  if defined(VGO_solaris) || defined(VGP_arm64_linux)
    SysRes res = VG_(do_syscall4)(__NR_renameat, VKI_AT_FDCWD, (UWord)old_name,
                                  VKI_AT_FDCWD, (UWord)new_name);
-#  elif defined(VGP_nanomips_linux)
+#  elif defined(VGP_nanomips_linux) || defined(VGP_loongarch64_linux)
    SysRes res = VG_(do_syscall5)(__NR_renameat2, VKI_AT_FDCWD, (UWord)old_name,
                                  VKI_AT_FDCWD, (UWord)new_name, 0);
 
@@ -791,7 +809,8 @@ Int VG_(rename) ( const HChar* old_name, const HChar* new_name )
 
 Int VG_(unlink) ( const HChar* file_name )
 {
-#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+      || defined(VGP_loongarch64_linux)
    SysRes res = VG_(do_syscall2)(__NR_unlinkat, VKI_AT_FDCWD,
                                                 (UWord)file_name);
 #  elif defined(VGO_linux) || defined(VGO_darwin) || defined(VGO_freebsd)
@@ -870,7 +889,8 @@ const HChar *VG_(get_startup_wd) ( void )
 SysRes VG_(poll) (struct vki_pollfd *fds, Int nfds, Int timeout)
 {
    SysRes res;
-#  if defined(VGP_arm64_linux)  || defined(VGP_nanomips_linux)
+#  if defined(VGP_arm64_linux)  || defined(VGP_nanomips_linux) \
+      || defined(VGP_loongarch64_linux)
    /* ARM64 wants to use __NR_ppoll rather than __NR_poll. */
    struct vki_timespec timeout_ts;
    if (timeout >= 0) {
@@ -915,7 +935,8 @@ SSizeT VG_(readlink) (const HChar* path, HChar* buf, SizeT bufsiz)
 {
    SysRes res;
    /* res = readlink( path, buf, bufsiz ); */
-#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+      || defined(VGP_loongarch64_linux)
    res = VG_(do_syscall4)(__NR_readlinkat, VKI_AT_FDCWD,
                                            (UWord)path, (UWord)buf, bufsiz);
 #  elif defined(VGO_linux) || defined(VGO_darwin) || defined(VGO_freebsd)
@@ -994,7 +1015,8 @@ Int VG_(access) ( const HChar* path, Bool irusr, Bool iwusr, Bool ixusr )
    UWord w = (irusr ? VKI_R_OK : 0)
              | (iwusr ? VKI_W_OK : 0)
              | (ixusr ? VKI_X_OK : 0);
-#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+      || defined(VGP_loongarch64_linux)
    SysRes res = VG_(do_syscall3)(__NR_faccessat, VKI_AT_FDCWD, (UWord)path, w);
 #  elif defined(VGO_linux) || defined(VGO_darwin) || defined(VGO_freebsd)
    SysRes res = VG_(do_syscall2)(__NR_access, (UWord)path, w);
@@ -1140,7 +1162,8 @@ SysRes VG_(pread) ( Int fd, void* buf, Int count, OffT offset )
    return res;
 #  elif defined(VGP_amd64_linux) || defined(VGP_s390x_linux) \
       || defined(VGP_ppc64be_linux)  || defined(VGP_ppc64le_linux) \
-      || defined(VGP_mips64_linux) || defined(VGP_arm64_linux)
+      || defined(VGP_mips64_linux) || defined(VGP_arm64_linux) \
+      || defined(VGP_loongarch64_linux)
    res = VG_(do_syscall4)(__NR_pread64, fd, (UWord)buf, count, offset);
    return res;
 #  elif defined(VGP_amd64_freebsd)
@@ -1404,7 +1427,8 @@ Int VG_(socket) ( Int domain, Int type, Int protocol )
 
 #  elif defined(VGP_amd64_linux) || defined(VGP_arm_linux) \
         || defined(VGP_mips32_linux) || defined(VGP_mips64_linux) \
-        || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) || defined(VGO_freebsd)
+        || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+        || defined(VGO_freebsd) || defined(VGP_loongarch64_linux)
    SysRes res;
    res = VG_(do_syscall3)(__NR_socket, domain, type, protocol );
    return sr_isError(res) ? -1 : sr_Res(res);
@@ -1459,7 +1483,8 @@ Int my_connect ( Int sockfd, struct vki_sockaddr_in* serv_addr, Int addrlen )
 
 #  elif defined(VGP_amd64_linux) || defined(VGP_arm_linux) \
         || defined(VGP_mips32_linux) || defined(VGP_mips64_linux) \
-        || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) || defined(VGO_freebsd)
+        || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+        || defined(VGO_freebsd) || defined(VGP_loongarch64_linux)
    SysRes res;
    res = VG_(do_syscall3)(__NR_connect, sockfd, (UWord)serv_addr, addrlen);
    return sr_isError(res) ? -1 : sr_Res(res);
@@ -1506,7 +1531,8 @@ Int VG_(write_socket)( Int sd, const void *msg, Int count )
 
 #  elif defined(VGP_amd64_linux) || defined(VGP_arm_linux) \
         || defined(VGP_mips32_linux) || defined(VGP_mips64_linux) \
-        || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) || defined(VGO_freebsd)
+        || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+        || defined(VGO_freebsd) || defined(VGP_loongarch64_linux)
    SysRes res;
    res = VG_(do_syscall6)(__NR_sendto, sd, (UWord)msg, 
                                        count, VKI_MSG_NOSIGNAL, 0,0);
@@ -1544,7 +1570,8 @@ Int VG_(getsockname) ( Int sd, struct vki_sockaddr *name, Int *namelen)
 #  elif defined(VGP_amd64_linux) || defined(VGP_arm_linux) \
         || defined(VGP_mips64_linux) || defined(VGP_arm64_linux) \
         || defined(VGP_nanomips_linux) || defined(VGO_freebsd) \
-        || defined(VGP_mips64_linux) || defined(VGP_arm64_linux)
+        || defined(VGP_mips64_linux) || defined(VGP_arm64_linux) \
+        || defined(VGP_loongarch64_linux)
    SysRes res;
    res = VG_(do_syscall3)( __NR_getsockname,
                            (UWord)sd, (UWord)name, (UWord)namelen );
@@ -1583,7 +1610,8 @@ Int VG_(getpeername) ( Int sd, struct vki_sockaddr *name, Int *namelen)
 
 #  elif defined(VGP_amd64_linux) || defined(VGP_arm_linux) \
         || defined(VGP_mips64_linux) || defined(VGP_arm64_linux) \
-        || defined(VGP_nanomips_linux) || defined(VGO_freebsd)
+        || defined(VGP_nanomips_linux) || defined(VGO_freebsd) \
+        || defined(VGP_loongarch64_linux)
    SysRes res;
    res = VG_(do_syscall3)( __NR_getpeername,
                            (UWord)sd, (UWord)name, (UWord)namelen );
@@ -1625,7 +1653,7 @@ Int VG_(getsockopt) ( Int sd, Int level, Int optname, void *optval,
 #  elif defined(VGP_amd64_linux) || defined(VGP_arm_linux) \
         || defined(VGP_mips32_linux) || defined(VGP_mips64_linux) \
         || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
-        || defined(VGO_freebsd)
+        || defined(VGO_freebsd) || defined(VGP_loongarch64_linux)
    SysRes res;
    res = VG_(do_syscall5)( __NR_getsockopt,
                            (UWord)sd, (UWord)level, (UWord)optname, 
@@ -1669,7 +1697,8 @@ Int VG_(setsockopt) ( Int sd, Int level, Int optname, void *optval,
 
 #  elif defined(VGP_amd64_linux) || defined(VGP_arm_linux) \
         || defined(VGP_mips32_linux) || defined(VGP_mips64_linux) \
-        || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+        || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+        || defined(VGP_loongarch64_linux)
    SysRes res;
    res = VG_(do_syscall5)( __NR_setsockopt,
                            (UWord)sd, (UWord)level, (UWord)optname, 
diff --git a/coregrind/m_libcproc.c b/coregrind/m_libcproc.c
index 02f636748..bc8061d8a 100644
--- a/coregrind/m_libcproc.c
+++ b/coregrind/m_libcproc.c
@@ -698,7 +698,8 @@ Int VG_(gettid)(void)
        * the /proc/self link is pointing...
        */
 
-#     if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+#     if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+         || defined(VGP_loongarch64_linux)
       res = VG_(do_syscall4)(__NR_readlinkat, VKI_AT_FDCWD,
                              (UWord)"/proc/self",
                              (UWord)pid, sizeof(pid));
@@ -753,7 +754,8 @@ Int VG_(getpid) ( void )
 Int VG_(getpgrp) ( void )
 {
    /* ASSUMES SYSCALL ALWAYS SUCCEEDS */
-#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+      || defined(VGP_loongarch64_linux)
    return sr_Res( VG_(do_syscall1)(__NR_getpgid, 0) );
 #  elif defined(VGO_linux) || defined(VGO_darwin) || defined(VGO_freebsd)
    return sr_Res( VG_(do_syscall0)(__NR_getpgrp) );
@@ -850,7 +852,7 @@ Int VG_(getgroups)( Int size, UInt* list )
         || defined(VGO_darwin) || defined(VGP_s390x_linux)    \
         || defined(VGP_mips32_linux) || defined(VGP_arm64_linux) \
         || defined(VGO_solaris) || defined(VGP_nanomips_linux) \
-        || defined(VGO_freebsd)
+        || defined(VGO_freebsd) || defined(VGP_loongarch64_linux)
    SysRes sres;
    sres = VG_(do_syscall2)(__NR_getgroups, size, (Addr)list);
    if (sr_isError(sres))
@@ -944,7 +946,8 @@ Int VG_(fork) ( void )
       fds[0] = fds[1] = -1;
    }
 
-#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+      || defined(VGP_loongarch64_linux)
    SysRes res;
    res = VG_(do_syscall5)(__NR_clone, VKI_SIGCHLD,
                           (UWord)NULL, (UWord)NULL, (UWord)NULL, (UWord)NULL);
diff --git a/coregrind/m_libcsetjmp.c b/coregrind/m_libcsetjmp.c
index aa1749032..b9f2a9ae4 100644
--- a/coregrind/m_libcsetjmp.c
+++ b/coregrind/m_libcsetjmp.c
@@ -887,6 +887,72 @@ void VG_MINIMAL_LONGJMP(VG_MINIMAL_JMP_BUF(_env))
 
 #endif
 
+#if defined(VGP_loongarch64_linux)
+
+__asm__(
+".text                      \n\t"
+".globl VG_MINIMAL_SETJMP;  \n\t"
+"VG_MINIMAL_SETJMP:         \n\t"
+"   st.d   $ra,  $a0, 0     \n\t"
+"   st.d   $sp,  $a0, 8     \n\t"
+"   st.d   $r21, $a0, 16    \n\t"
+"   st.d   $fp,  $a0, 24    \n\t"
+"   st.d   $s0,  $a0, 32    \n\t"
+"   st.d   $s1,  $a0, 40    \n\t"
+"   st.d   $s2,  $a0, 48    \n\t"
+"   st.d   $s3,  $a0, 56    \n\t"
+"   st.d   $s4,  $a0, 64    \n\t"
+"   st.d   $s5,  $a0, 72    \n\t"
+"   st.d   $s6,  $a0, 80    \n\t"
+"   st.d   $s7,  $a0, 88    \n\t"
+"   st.d   $s8,  $a0, 96    \n\t"
+#if !defined(__loongarch_soft_float)
+"   fst.d  $f24, $a0, 104   \n\t"
+"   fst.d  $f25, $a0, 112   \n\t"
+"   fst.d  $f26, $a0, 120   \n\t"
+"   fst.d  $f27, $a0, 128   \n\t"
+"   fst.d  $f28, $a0, 136   \n\t"
+"   fst.d  $f29, $a0, 144   \n\t"
+"   fst.d  $f30, $a0, 152   \n\t"
+"   fst.d  $f30, $a0, 160   \n\t"
+#endif
+"   move   $a0, $zero       \n\t"
+"   jr     $ra              \n\t"
+"                           \n\t"
+".text                      \n\t"
+".globl VG_MINIMAL_LONGJMP; \n\t"
+"VG_MINIMAL_LONGJMP:        \n\t"
+"   ld.d   $ra,  $a0, 0     \n\t"
+"   ld.d   $sp,  $a0, 8     \n\t"
+"   ld.d   $r21, $a0, 16    \n\t"
+"   ld.d   $fp,  $a0, 24    \n\t"
+"   ld.d   $s0,  $a0, 32    \n\t"
+"   ld.d   $s1,  $a0, 40    \n\t"
+"   ld.d   $s2,  $a0, 48    \n\t"
+"   ld.d   $s3,  $a0, 56    \n\t"
+"   ld.d   $s4,  $a0, 64    \n\t"
+"   ld.d   $s5,  $a0, 72    \n\t"
+"   ld.d   $s6,  $a0, 80    \n\t"
+"   ld.d   $s7,  $a0, 88    \n\t"
+"   ld.d   $s8,  $a0, 96    \n\t"
+#if !defined(__loongarch_soft_float)
+"   fld.d  $f24, $a0, 104   \n\t"
+"   fld.d  $f25, $a0, 112   \n\t"
+"   fld.d  $f26, $a0, 120   \n\t"
+"   fld.d  $f27, $a0, 128   \n\t"
+"   fld.d  $f28, $a0, 136   \n\t"
+"   fld.d  $f29, $a0, 144   \n\t"
+"   fld.d  $f30, $a0, 152   \n\t"
+"   fld.d  $f30, $a0, 160   \n\t"
+#endif
+"   bnez   $a1,  1f         \n\t"
+"   addi.d $a1,  $a1, 1     \n\t"
+"1:                         \n\t"
+"   move   $a0,  $a1        \n\t"
+"   jr     $ra              \n\t"
+);
+#endif  /* VGP_loongarch64_linux */
+
 /*--------------------------------------------------------------------*/
 /*--- end                                                          ---*/
 /*--------------------------------------------------------------------*/
diff --git a/coregrind/m_machine.c b/coregrind/m_machine.c
index 079383651..983544bbd 100644
--- a/coregrind/m_machine.c
+++ b/coregrind/m_machine.c
@@ -152,6 +152,13 @@ void VG_(get_UnwindStartRegs) ( /*OUT*/UnwindStartRegs* regs,
       = VG_(threads)[tid].arch.vex.guest_r31;
    regs->misc.MIPS64.r28
       = VG_(threads)[tid].arch.vex.guest_r28;
+#  elif defined(VGA_loongarch64)
+   regs->r_pc = VG_(threads)[tid].arch.vex.guest_PC;
+   regs->r_sp = VG_(threads)[tid].arch.vex.guest_R3;
+   regs->misc.LOONGARCH64.r_fp
+      = VG_(threads)[tid].arch.vex.guest_R22;
+   regs->misc.LOONGARCH64.r_ra
+      = VG_(threads)[tid].arch.vex.guest_R1;
 #  else
 #    error "Unknown arch"
 #  endif
@@ -369,6 +376,39 @@ static void apply_to_GPs_of_tid(ThreadId tid, void (*f)(ThreadId,
    (*f)(tid, "x28", vex->guest_X28);
    (*f)(tid, "x29", vex->guest_X29);
    (*f)(tid, "x30", vex->guest_X30);
+#elif defined(VGA_loongarch64)
+   (*f)(tid, "r0" , vex->guest_R0 );
+   (*f)(tid, "r1" , vex->guest_R1 );
+   (*f)(tid, "r2" , vex->guest_R2 );
+   (*f)(tid, "r3" , vex->guest_R3 );
+   (*f)(tid, "r4" , vex->guest_R4 );
+   (*f)(tid, "r5" , vex->guest_R5 );
+   (*f)(tid, "r6" , vex->guest_R6 );
+   (*f)(tid, "r7" , vex->guest_R7 );
+   (*f)(tid, "r8" , vex->guest_R8 );
+   (*f)(tid, "r9" , vex->guest_R9 );
+   (*f)(tid, "r10", vex->guest_R10);
+   (*f)(tid, "r11", vex->guest_R11);
+   (*f)(tid, "r12", vex->guest_R12);
+   (*f)(tid, "r13", vex->guest_R13);
+   (*f)(tid, "r14", vex->guest_R14);
+   (*f)(tid, "r15", vex->guest_R15);
+   (*f)(tid, "r16", vex->guest_R16);
+   (*f)(tid, "r17", vex->guest_R17);
+   (*f)(tid, "r18", vex->guest_R18);
+   (*f)(tid, "r19", vex->guest_R19);
+   (*f)(tid, "r20", vex->guest_R20);
+   (*f)(tid, "r21", vex->guest_R21);
+   (*f)(tid, "r22", vex->guest_R22);
+   (*f)(tid, "r23", vex->guest_R23);
+   (*f)(tid, "r24", vex->guest_R24);
+   (*f)(tid, "r25", vex->guest_R25);
+   (*f)(tid, "r26", vex->guest_R26);
+   (*f)(tid, "r27", vex->guest_R27);
+   (*f)(tid, "r28", vex->guest_R28);
+   (*f)(tid, "r29", vex->guest_R29);
+   (*f)(tid, "r30", vex->guest_R30);
+   (*f)(tid, "r31", vex->guest_R31);
 #else
 #  error Unknown arch
 #endif
@@ -479,7 +519,7 @@ Int VG_(machine_arm_archlevel) = 4;
    testing, so we need a VG_MINIMAL_JMP_BUF. */
 #if defined(VGA_ppc32) || defined(VGA_ppc64be) || defined(VGA_ppc64le) \
     || defined(VGA_arm) || defined(VGA_s390x) || defined(VGA_mips32) \
-    || defined(VGA_mips64) || defined(VGA_arm64)
+    || defined(VGA_mips64) || defined(VGA_arm64) || defined(VGA_loongarch64)
 #include "pub_core_libcsetjmp.h"
 static VG_MINIMAL_JMP_BUF(env_unsup_insn);
 static void handler_unsup_insn ( Int x ) {
@@ -861,6 +901,105 @@ static Bool VG_(parse_cpuinfo)(void)
 
 #endif /* defined(VGP_arm64_linux) */
 
+#if defined(VGA_loongarch64)
+
+/*
+ * Initialize hwcaps by parsing /proc/cpuinfo.  Returns False if it can not
+ * determine what CPU it is (it searches only for the models that are or may be
+ * supported by Valgrind).
+ */
+static Bool VG_(parse_cpuinfo)(void)
+{
+   Int    n, fh;
+   SysRes fd;
+   SizeT  num_bytes, file_buf_size;
+   HChar  *file_buf;
+
+   const char *search_Loongson_str = "Model Name\t\t: Loongson";
+
+   /* Slurp contents of /proc/cpuinfo into FILE_BUF */
+   fd = VG_(open)("/proc/cpuinfo", 0, VKI_S_IRUSR);
+   if (sr_isError(fd))
+      return False;
+
+   fh = sr_Res(fd);
+
+   /* Determine the size of /proc/cpuinfo.
+      Work around broken-ness in /proc file system implementation.
+      fstat returns a zero size for /proc/cpuinfo although it is
+      claimed to be a regular file. */
+   num_bytes = 0;
+   file_buf_size = 1000;
+   file_buf = VG_(malloc)("cpuinfo", file_buf_size + 1);
+   while (True) {
+      n = VG_(read)(fh, file_buf, file_buf_size);
+      if (n < 0)
+         break;
+
+      num_bytes += n;
+      if (n < file_buf_size)
+         break;  /* reached EOF */
+   }
+
+   if (n < 0)
+      num_bytes = 0;  /* read error; ignore contents */
+
+   if (num_bytes > file_buf_size) {
+      VG_(free)(file_buf);
+      VG_(lseek)(fh, 0, VKI_SEEK_SET);
+      file_buf = VG_(malloc)("cpuinfo", num_bytes + 1);
+      n = VG_(read)(fh, file_buf, num_bytes);
+      if (n < 0)
+         num_bytes = 0;
+   }
+
+   file_buf[num_bytes] = '\0';
+   VG_(close)(fh);
+
+   /* Parse file */
+   vai.hwcaps = 0;
+   if (VG_(strstr)(file_buf, search_Loongson_str) == NULL) {
+      /* Did not find string in the proc file. */
+      VG_(free)(file_buf);
+      return False;
+   }
+
+   if (VG_(strstr)(file_buf, "loongarch32") != NULL)
+      vai.hwcaps |= VEX_HWCAPS_LOONGARCH_ISA_32BIT;
+   if (VG_(strstr)(file_buf, "loongarch64") != NULL)
+      vai.hwcaps |= VEX_HWCAPS_LOONGARCH_ISA_64BIT;
+
+   if (VG_(strstr)(file_buf, "cpucfg") != NULL)
+      vai.hwcaps |= VEX_HWCAPS_LOONGARCH_CPUCFG;
+   if (VG_(strstr)(file_buf, "lam") != NULL)
+      vai.hwcaps |= VEX_HWCAPS_LOONGARCH_LAM;
+   if (VG_(strstr)(file_buf, "ual") != NULL)
+      vai.hwcaps |= VEX_HWCAPS_LOONGARCH_UAL;
+   if (VG_(strstr)(file_buf, "fpu") != NULL)
+      vai.hwcaps |= VEX_HWCAPS_LOONGARCH_FP;
+   if (VG_(strstr)(file_buf, "lsx") != NULL)
+      vai.hwcaps |= VEX_HWCAPS_LOONGARCH_LSX;
+   if (VG_(strstr)(file_buf, "lasx") != NULL)
+      vai.hwcaps |= VEX_HWCAPS_LOONGARCH_LASX;
+   if (VG_(strstr)(file_buf, "complex") != NULL)
+      vai.hwcaps |= VEX_HWCAPS_LOONGARCH_COMPLEX;
+   if (VG_(strstr)(file_buf, "crypto") != NULL)
+      vai.hwcaps |= VEX_HWCAPS_LOONGARCH_CRYPTO;
+   if (VG_(strstr)(file_buf, "lvz") != NULL)
+      vai.hwcaps |= VEX_HWCAPS_LOONGARCH_LVZP;
+   if (VG_(strstr)(file_buf, "lbt_x86") != NULL)
+      vai.hwcaps |= VEX_HWCAPS_LOONGARCH_X86BT;
+   if (VG_(strstr)(file_buf, "lbt_arm") != NULL)
+      vai.hwcaps |= VEX_HWCAPS_LOONGARCH_ARMBT;
+   if (VG_(strstr)(file_buf, "lbt_mips") != NULL)
+      vai.hwcaps |= VEX_HWCAPS_LOONGARCH_MIPSBT;
+
+   VG_(free)(file_buf);
+   return True;
+}
+
+#endif /* defined(VGP_loongarch64) */
+
 Bool VG_(machine_get_hwcaps)( void )
 {
    vg_assert(hwcaps_done == False);
@@ -2231,6 +2370,54 @@ Bool VG_(machine_get_hwcaps)( void )
 
      return True;
    }
+
+#elif defined(VGA_loongarch64)
+   {
+      va = VexArchLOONGARCH64;
+      vai.endness = VexEndnessLE;
+      vai.hwcaps = 0;
+
+      if (!VG_(parse_cpuinfo)())
+         return False;
+
+      /* Same instruction set detection algorithm as for ppc32/arm... */
+      vki_sigset_t          saved_set, tmp_set;
+      vki_sigaction_fromK_t saved_sigill_act;
+      vki_sigaction_toK_t   tmp_sigill_act;
+
+      vg_assert(sizeof(vki_sigaction_fromK_t) == sizeof(vki_sigaction_toK_t));
+
+      VG_(sigemptyset)(&tmp_set);
+      VG_(sigaddset)(&tmp_set, VKI_SIGILL);
+
+      Int r;
+      r = VG_(sigprocmask)(VKI_SIG_UNBLOCK, &tmp_set, &saved_set);
+      vg_assert(r == 0);
+
+      r = VG_(sigaction)(VKI_SIGILL, NULL, &saved_sigill_act);
+      vg_assert(r == 0);
+      tmp_sigill_act = saved_sigill_act;
+
+      /* NODEFER: signal handler does not return (from the kernel's point of
+         view), hence if it is to successfully catch a signal more than once,
+         we need the NODEFER flag. */
+      tmp_sigill_act.sa_flags &= ~VKI_SA_RESETHAND;
+      tmp_sigill_act.sa_flags &= ~VKI_SA_SIGINFO;
+      tmp_sigill_act.sa_flags |=  VKI_SA_NODEFER;
+      tmp_sigill_act.ksa_handler = handler_unsup_insn;
+      VG_(sigaction)(VKI_SIGILL, &tmp_sigill_act, NULL);
+
+      VG_(convert_sigaction_fromK_to_toK)(&saved_sigill_act, &tmp_sigill_act);
+      VG_(sigaction)(VKI_SIGILL, &tmp_sigill_act, NULL);
+      VG_(sigprocmask)(VKI_SIG_SETMASK, &saved_set, NULL);
+
+      VG_(debugLog)(1, "machine", "hwcaps = 0x%x\n", vai.hwcaps);
+
+      VG_(machine_get_cache_info)(&vai);
+
+      return True;
+   }
+
 #else
 #  error "Unknown arch"
 #endif
@@ -2371,6 +2558,9 @@ Int VG_(machine_get_size_of_largest_guest_register) ( void )
 #  elif defined(VGA_mips64)
    return 8;
 
+#  elif defined(VGA_loongarch64)
+   return 8;
+
 #  else
 #    error "Unknown arch"
 #  endif
@@ -2387,7 +2577,7 @@ void* VG_(fnptr_to_fnentry)( void* f )
       || defined(VGP_s390x_linux) || defined(VGP_mips32_linux) \
       || defined(VGP_mips64_linux) || defined(VGP_arm64_linux) \
       || defined(VGP_x86_solaris) || defined(VGP_amd64_solaris) \
-      || defined(VGP_nanomips_linux)
+      || defined(VGP_nanomips_linux) || defined(VGP_loongarch64_linux)
    return f;
 #  elif defined(VGP_ppc64be_linux)
    /* ppc64-linux uses the AIX scheme, in which f is a pointer to a
diff --git a/coregrind/m_main.c b/coregrind/m_main.c
index 10b2d9be9..3e6fc55c5 100644
--- a/coregrind/m_main.c
+++ b/coregrind/m_main.c
@@ -1492,6 +1492,7 @@ Int valgrind_main ( Int argc, HChar **argv, HChar **envp )
                     "AMD Athlon or above)\n");
         VG_(printf)("   * AMD Athlon64/Opteron\n");
         VG_(printf)("   * ARM (armv7)\n");
+        VG_(printf)("   * LoongArch (3A5000 and above)\n");
         VG_(printf)("   * MIPS (mips32 and above; mips64 and above)\n");
         VG_(printf)("   * PowerPC (most; ppc405 and above)\n");
         VG_(printf)("   * System z (64bit only - s390x; z990 and above)\n");
@@ -2547,6 +2548,11 @@ static void final_tidyup(ThreadId tid)
    VG_TRACK(post_reg_write, Vg_CoreClientReq, tid,
             offsetof(VexGuestS390XState, guest_r2),
             sizeof(VG_(threads)[tid].arch.vex.guest_r2));
+#  elif defined(VGA_loongarch64)
+   VG_(threads)[tid].arch.vex.guest_R4 = to_run;
+   VG_TRACK(post_reg_write, Vg_CoreClientReq, tid,
+            offsetof(VexGuestLOONGARCH64State, guest_R4),
+            sizeof(VG_(threads)[tid].arch.vex.guest_R4));
 #else
    I_die_here : architecture missing in m_main.c
 #endif
@@ -3075,6 +3081,29 @@ asm(
     ".set pop                                           \n\t"
 ".previous                                              \n\t"
 );
+#elif defined(VGP_loongarch64_linux)
+asm("                                                           \n\t"
+    ".text                                                      \n\t"
+    ".globl _start                                              \n\t"
+    ".type _start,@function                                     \n\t"
+    "_start:                                                    \n\t"
+    /* t0 = &vgPlain_interim_stack + VG_STACK_GUARD_SZB +
+       VG_DEFAULT_STACK_ACTIVE_SZB */
+    "la.local  $t0, vgPlain_interim_stack                       \n\t"
+    "li.w      $t1, "VG_STRINGIFY(VG_STACK_GUARD_SZB)"          \n\t"
+    "add.d     $t0, $t0, $t1                                    \n\t"
+    "li.w      $t2, "VG_STRINGIFY(VG_DEFAULT_STACK_ACTIVE_SZB)" \n\t"
+    "add.d     $t0, $t0, $t2                                    \n\t"
+    /* allocate 16 bytes on the new stack in t0, and aligned */
+    "addi.d    $t0, $t0, -16                                    \n\t"
+    "bstrins.d $t0, $zero, 3, 0                                 \n\t"
+    /* a0 = sp, sp = t0, and then call _start_in_C_linux */
+    "move      $a0, $sp                                         \n\t"
+    "move      $sp, $t0                                         \n\t"
+    "la.local  $t0, _start_in_C_linux                           \n\t"
+    "jr        $t0                                              \n\t"
+    ".previous                                                  \n\t"
+);
 #else
 #  error "Unknown platform"
 #endif
@@ -3120,11 +3149,11 @@ void _start_in_C_linux ( UWord* pArgc )
 #  if defined(VGP_ppc32_linux) || defined(VGP_ppc64be_linux) \
       || defined(VGP_ppc64le_linux) || defined(VGP_arm64_linux) \
       || defined(VGP_mips32_linux)  || defined(VGP_mips64_linux) \
-      || defined(VGP_nanomips_linux)
+      || defined(VGP_nanomips_linux) || defined(VGP_loongarch64_linux)
    {
-      /* ppc32/ppc64, arm64, mips32/64 can be configured with different
-         page sizes. Determine this early. This is an ugly hack and really
-         should be moved into valgrind_main. */
+      /* ppc32/ppc64, arm64, mips32/64, loongarch64 can be configured with
+         different page sizes. Determine this early. This is an ugly hack
+         and really should be moved into valgrind_main. */
       UWord *sp = &pArgc[1+argc+1];
       while (*sp++ != 0)
          ;
diff --git a/coregrind/m_options.c b/coregrind/m_options.c
index 1483af2d9..640af7121 100644
--- a/coregrind/m_options.c
+++ b/coregrind/m_options.c
@@ -203,7 +203,8 @@ UInt   VG_(clo_unw_stack_scan_frames) = 5;
 VgSmc VG_(clo_smc_check) = Vg_SmcAllNonFile;
 #elif defined(VGA_ppc32) || defined(VGA_ppc64be) || defined(VGA_ppc64le) \
       || defined(VGA_arm) || defined(VGA_arm64) \
-      || defined(VGA_mips32) || defined(VGA_mips64) || defined(VGA_nanomips)
+      || defined(VGA_mips32) || defined(VGA_mips64) || defined(VGA_nanomips) \
+      || defined(VGA_loongarch64)
 VgSmc VG_(clo_smc_check) = Vg_SmcStack;
 #else
 #  error "Unknown arch"
diff --git a/coregrind/m_redir.c b/coregrind/m_redir.c
index cef241b4f..fa513a059 100644
--- a/coregrind/m_redir.c
+++ b/coregrind/m_redir.c
@@ -1240,6 +1240,7 @@ Bool VG_(is_soname_ld_so) (const HChar *soname)
    if (VG_STREQ(soname, VG_U_LD_LINUX_AARCH64_SO_1)) return True;
    if (VG_STREQ(soname, VG_U_LD_LINUX_ARMHF_SO_3))   return True;
    if (VG_STREQ(soname, VG_U_LD_LINUX_MIPSN8_S0_1))  return True;
+   if (VG_STREQ(soname, VG_U_LD_LINUX_LOONGARCH_LP64D_SO_1)) return True;
 #  elif defined(VGO_freebsd)
    if (VG_STREQ(soname, VG_U_LD_ELF_SO_1))   return True;
    if (VG_STREQ(soname, VG_U_LD_ELF32_SO_1))   return True;
@@ -1679,6 +1680,22 @@ void VG_(redir_initialise) ( void )
       );
    }
 
+#elif defined(VGP_loongarch64_linux)
+   /* If we're using memcheck, use these intercepts right from
+      the start, otherwise ld.so makes a lot of noise. */
+   if (0==VG_(strcmp)("Memcheck", VG_(details).name)) {
+      add_hardwired_spec(
+         "ld-linux-loongarch-lp64d.so.1", "strlen",
+         (Addr)&VG_(loongarch64_linux_REDIR_FOR_strlen),
+         complain_about_stripped_glibc_ldso
+      );
+      add_hardwired_spec(
+         "ld-linux-loongarch-lp64d.so.1", "strchr",
+         (Addr)&VG_(loongarch64_linux_REDIR_FOR_strchr),
+         complain_about_stripped_glibc_ldso
+      );
+   }
+
 #  elif defined(VGP_x86_solaris)
    /* If we're using memcheck, use these intercepts right from
       the start, otherwise ld.so makes a lot of noise. */
diff --git a/coregrind/m_scheduler/scheduler.c b/coregrind/m_scheduler/scheduler.c
index 44db8f310..efa7673be 100644
--- a/coregrind/m_scheduler/scheduler.c
+++ b/coregrind/m_scheduler/scheduler.c
@@ -1826,6 +1826,9 @@ void VG_(nuke_all_threads_except) ( ThreadId me, VgSchedReturnCode src )
 #elif defined(VGA_mips32) || defined(VGA_mips64) || defined(VGA_nanomips)
 #  define VG_CLREQ_ARGS       guest_r12
 #  define VG_CLREQ_RET        guest_r11
+#elif defined(VGA_loongarch64)
+#  define VG_CLREQ_ARGS       guest_R12
+#  define VG_CLREQ_RET        guest_R11
 #else
 #  error Unknown arch
 #endif
diff --git a/coregrind/m_sigframe/sigframe-loongarch64-linux.c b/coregrind/m_sigframe/sigframe-loongarch64-linux.c
new file mode 100644
index 000000000..eda6c885c
--- /dev/null
+++ b/coregrind/m_sigframe/sigframe-loongarch64-linux.c
@@ -0,0 +1,285 @@
+
+/*--------------------------------------------------------------------*/
+/*--- Create/destroy signal delivery frames.                       ---*/
+/*---                             sigframe-loongarch64-linux.c     ---*/
+/*--------------------------------------------------------------------*/
+
+/*
+   This file is part of Valgrind, a dynamic binary instrumentation
+   framework.
+
+   Copyright (C) 2021-2022 Loongson Technology Corporation Limited
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/>.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+#if defined(VGP_loongarch64_linux)
+
+#include "pub_core_basics.h"
+#include "pub_core_vki.h"
+#include "pub_core_vkiscnums.h"
+#include "pub_core_threadstate.h"
+#include "pub_core_aspacemgr.h"
+#include "pub_core_libcbase.h"
+#include "pub_core_libcassert.h"
+#include "pub_core_libcprint.h"
+#include "pub_core_machine.h"
+#include "pub_core_options.h"
+#include "pub_core_sigframe.h"
+#include "pub_core_signals.h"
+#include "pub_core_tooliface.h"
+#include "pub_core_trampoline.h"
+#include "priv_sigframe.h"
+
+
+/*------------------------------------------------------------*/
+/*--- Signal frame layouts                                 ---*/
+/*------------------------------------------------------------*/
+
+struct vg_sig_private {
+   UInt magicPI;
+   UInt sigNo_private;
+   VexGuestLOONGARCH64State vex_shadow1;
+   VexGuestLOONGARCH64State vex_shadow2;
+};
+
+struct rt_sigframe {
+   struct vki_siginfo rs_info;
+   struct vki_ucontext rs_uctx;
+   struct vg_sig_private priv;
+};
+
+
+/*------------------------------------------------------------*/
+/*--- Creating signal frames                               ---*/
+/*------------------------------------------------------------*/
+
+static void create_siginfo ( ThreadId tid,
+                             struct rt_sigframe *frame,
+                             const vki_siginfo_t *si)
+{
+   VG_TRACK(pre_mem_write, Vg_CoreSignal, tid, "signal frame siginfo",
+            (Addr)&frame->rs_info, sizeof(frame->rs_info));
+
+   VG_(memcpy)(&frame->rs_info, si, sizeof(vki_siginfo_t));
+
+   VG_TRACK(post_mem_write, Vg_CoreSignal, tid,
+            (Addr)&frame->rs_info, sizeof(frame->rs_info));
+}
+
+static void create_sigcontext ( ThreadState *tst,
+                                struct vki_sigcontext **sc)
+{
+   struct vki_sigcontext *sctx = *sc;
+
+   VG_TRACK(pre_mem_write, Vg_CoreSignal, tst->tid, "signal frame mcontext",
+            (Addr)sctx, sizeof(ULong) * 32);
+
+   sctx->sc_regs[1]  = tst->arch.vex.guest_R1;
+   sctx->sc_regs[2]  = tst->arch.vex.guest_R2;
+   sctx->sc_regs[3]  = tst->arch.vex.guest_R3;
+   sctx->sc_regs[4]  = tst->arch.vex.guest_R4;
+   sctx->sc_regs[5]  = tst->arch.vex.guest_R5;
+   sctx->sc_regs[6]  = tst->arch.vex.guest_R6;
+   sctx->sc_regs[7]  = tst->arch.vex.guest_R7;
+   sctx->sc_regs[8]  = tst->arch.vex.guest_R8;
+   sctx->sc_regs[9]  = tst->arch.vex.guest_R9;
+   sctx->sc_regs[10] = tst->arch.vex.guest_R10;
+   sctx->sc_regs[11] = tst->arch.vex.guest_R11;
+   sctx->sc_regs[12] = tst->arch.vex.guest_R12;
+   sctx->sc_regs[13] = tst->arch.vex.guest_R13;
+   sctx->sc_regs[14] = tst->arch.vex.guest_R14;
+   sctx->sc_regs[15] = tst->arch.vex.guest_R15;
+   sctx->sc_regs[16] = tst->arch.vex.guest_R16;
+   sctx->sc_regs[17] = tst->arch.vex.guest_R17;
+   sctx->sc_regs[18] = tst->arch.vex.guest_R18;
+   sctx->sc_regs[19] = tst->arch.vex.guest_R19;
+   sctx->sc_regs[20] = tst->arch.vex.guest_R20;
+   sctx->sc_regs[21] = tst->arch.vex.guest_R21;
+   sctx->sc_regs[22] = tst->arch.vex.guest_R22;
+   sctx->sc_regs[23] = tst->arch.vex.guest_R23;
+   sctx->sc_regs[24] = tst->arch.vex.guest_R24;
+   sctx->sc_regs[25] = tst->arch.vex.guest_R25;
+   sctx->sc_regs[26] = tst->arch.vex.guest_R26;
+   sctx->sc_regs[27] = tst->arch.vex.guest_R27;
+   sctx->sc_regs[28] = tst->arch.vex.guest_R28;
+   sctx->sc_regs[29] = tst->arch.vex.guest_R29;
+   sctx->sc_regs[30] = tst->arch.vex.guest_R30;
+   sctx->sc_regs[31] = tst->arch.vex.guest_R31;
+   sctx->sc_pc       = tst->arch.vex.guest_PC;
+}
+
+static void create_ucontext ( ThreadState *tst,
+                              ThreadId tid,
+                              struct vki_ucontext *uc,
+                              const vki_sigset_t *mask,
+                              struct vki_sigcontext **sc,
+                              const vki_siginfo_t *siginfo)
+{
+   VG_TRACK(pre_mem_write, Vg_CoreSignal, tid, "signal frame ucontext",
+            (Addr)uc, offsetof(struct vki_ucontext, uc_mcontext));
+
+   uc->uc_flags   = 0;
+   uc->uc_link    = 0;
+   uc->uc_stack   = tst->altstack;
+   uc->uc_sigmask = *mask;
+
+   VG_TRACK(post_mem_write, Vg_CoreSignal, tid, (Addr)uc,
+            offsetof(struct vki_ucontext, uc_mcontext));
+
+   create_sigcontext(tst, sc);
+}
+
+/* EXPORTED */
+void VG_(sigframe_create) ( ThreadId tid,
+                            Bool on_altstack,
+                            Addr sp_top_of_frame,
+                            const vki_siginfo_t *siginfo,
+                            const struct vki_ucontext *siguc,
+                            void *handler,
+                            UInt flags,
+                            const vki_sigset_t *mask,
+                            void *restorer )
+{
+   UInt size = sizeof(struct rt_sigframe);
+   Addr sp = VG_ROUNDDN(sp_top_of_frame - size, 16);
+
+   ThreadState *tst = VG_(get_ThreadState)(tid);
+   if (! ML_(sf_maybe_extend_stack)(tst, sp, size, flags))
+      return;
+
+   struct rt_sigframe *frame = (struct rt_sigframe *)sp;
+   create_siginfo(tid, frame, siginfo);
+
+   struct vki_ucontext *uctx = &frame->rs_uctx;
+   struct vki_sigcontext *sctx = &(frame->rs_uctx.uc_mcontext);
+   create_ucontext(tst, tid, uctx, mask, &sctx, siginfo);
+
+   /*
+      Arguments to signal handler:
+
+         a0 = signal number
+         a1 = pointer to siginfo
+         a2 = pointer to ucontext
+
+      csr_era point to the signal handler, $r3 (sp) points to
+      the struct rt_sigframe.
+	 */
+
+   Int sigNo = siginfo->si_signo;
+   tst->arch.vex.guest_R4 = sigNo;
+   tst->arch.vex.guest_R5 = (Addr) &frame->rs_info;
+   tst->arch.vex.guest_R6 = (Addr) &frame->rs_uctx;
+   tst->arch.vex.guest_R3 = (Addr) frame;
+   tst->arch.vex.guest_R1 = (Addr) &VG_(loongarch64_linux_SUBST_FOR_rt_sigreturn);
+
+   struct vg_sig_private *priv = &frame->priv;
+   priv->magicPI       = 0x31415927;
+   priv->sigNo_private = sigNo;
+   priv->vex_shadow1   = tst->arch.vex_shadow1;
+   priv->vex_shadow2   = tst->arch.vex_shadow2;
+
+   /* Set the thread so it will next run the handler. */
+   VG_TRACK(post_reg_write, Vg_CoreSignal, tid, VG_O_STACK_PTR, sizeof(Addr));
+
+   if (VG_(clo_trace_signals))
+      VG_(printf)("handler = %p\n", handler);
+
+   tst->arch.vex.guest_PC = (Addr) handler;
+   /* This thread needs to be marked runnable, but we leave that
+      the caller to do. */
+}
+
+
+/*------------------------------------------------------------*/
+/*--- Destroying signal frames                             ---*/
+/*------------------------------------------------------------*/
+
+static void restore_regs ( ThreadState *tst,
+                           struct vki_sigcontext *mc)
+{
+   tst->arch.vex.guest_R1  = mc->sc_regs[1];
+   tst->arch.vex.guest_R2  = mc->sc_regs[2];
+   tst->arch.vex.guest_R3  = mc->sc_regs[3];
+   tst->arch.vex.guest_R4  = mc->sc_regs[4];
+   tst->arch.vex.guest_R5  = mc->sc_regs[5];
+   tst->arch.vex.guest_R6  = mc->sc_regs[6];
+   tst->arch.vex.guest_R7  = mc->sc_regs[7];
+   tst->arch.vex.guest_R8  = mc->sc_regs[8];
+   tst->arch.vex.guest_R9  = mc->sc_regs[9];
+   tst->arch.vex.guest_R10 = mc->sc_regs[10];
+   tst->arch.vex.guest_R11 = mc->sc_regs[11];
+   tst->arch.vex.guest_R12 = mc->sc_regs[12];
+   tst->arch.vex.guest_R13 = mc->sc_regs[13];
+   tst->arch.vex.guest_R14 = mc->sc_regs[14];
+   tst->arch.vex.guest_R15 = mc->sc_regs[15];
+   tst->arch.vex.guest_R16 = mc->sc_regs[16];
+   tst->arch.vex.guest_R17 = mc->sc_regs[17];
+   tst->arch.vex.guest_R18 = mc->sc_regs[18];
+   tst->arch.vex.guest_R19 = mc->sc_regs[19];
+   tst->arch.vex.guest_R20 = mc->sc_regs[20];
+   tst->arch.vex.guest_R21 = mc->sc_regs[21];
+   tst->arch.vex.guest_R22 = mc->sc_regs[22];
+   tst->arch.vex.guest_R23 = mc->sc_regs[23];
+   tst->arch.vex.guest_R24 = mc->sc_regs[24];
+   tst->arch.vex.guest_R25 = mc->sc_regs[25];
+   tst->arch.vex.guest_R26 = mc->sc_regs[26];
+   tst->arch.vex.guest_R27 = mc->sc_regs[27];
+   tst->arch.vex.guest_R28 = mc->sc_regs[28];
+   tst->arch.vex.guest_R29 = mc->sc_regs[29];
+   tst->arch.vex.guest_R30 = mc->sc_regs[30];
+   tst->arch.vex.guest_R31 = mc->sc_regs[31];
+   tst->arch.vex.guest_PC  = mc->sc_pc;
+}
+
+/* EXPORTED */
+void VG_(sigframe_destroy)( ThreadId tid, Bool isRT )
+{
+   vg_assert(VG_(is_valid_tid)(tid));
+
+   ThreadState *tst = VG_(get_ThreadState)(tid);
+   Addr sp = tst->arch.vex.guest_R3;
+   struct rt_sigframe *frame = (struct rt_sigframe *)sp;
+   struct vki_ucontext *uc = &frame->rs_uctx;
+
+   tst->sig_mask = uc->uc_sigmask;
+   tst->tmp_sig_mask = uc->uc_sigmask;
+
+   struct vki_sigcontext *mc = &uc->uc_mcontext;
+   restore_regs(tst, mc);
+
+   struct vg_sig_private *priv = &frame->priv;
+   vg_assert(priv->magicPI == 0x31415927);
+   tst->arch.vex_shadow1 = priv->vex_shadow1;
+   tst->arch.vex_shadow2 = priv->vex_shadow2;
+
+   UInt frame_size = sizeof(*frame);
+   VG_TRACK(die_mem_stack_signal, sp, frame_size);
+
+   if (VG_(clo_trace_signals))
+      VG_(message)(Vg_DebugMsg,
+         "VG_(signal_return) (thread %u): isRT=%d valid magic; PC=%#llx\n",
+         tid, isRT, tst->arch.vex.guest_PC);
+
+   Int sigNo = priv->sigNo_private;
+   VG_TRACK( post_deliver_signal, tid, sigNo );
+}
+
+#endif /* defined(VGP_loongarch64_linux) */
+
+/*--------------------------------------------------------------------*/
+/*--- end                             sigframe-loongarch64-linux.c ---*/
+/*--------------------------------------------------------------------*/
diff --git a/coregrind/m_signals.c b/coregrind/m_signals.c
index c1bae2509..1e1c26344 100644
--- a/coregrind/m_signals.c
+++ b/coregrind/m_signals.c
@@ -628,6 +628,22 @@ VgHashTable *ht_sigchld_ignore = NULL;
         (srP)->misc.MIPS32.r28 = (uc)->uc_mcontext.sc_regs[28]; \
       }
 
+#elif defined(VGP_loongarch64_linux)
+#  define VG_UCONTEXT_INSTR_PTR(uc)      (((uc)->uc_mcontext.sc_pc))
+#  define VG_UCONTEXT_STACK_PTR(uc)      ((uc)->uc_mcontext.sc_regs[3])
+#  define VG_UCONTEXT_FRAME_PTR(uc)      ((uc)->uc_mcontext.sc_regs[22])
+#  define VG_UCONTEXT_SYSCALL_NUM(uc)    ((uc)->uc_mcontext.sc_regs[11])
+#  define VG_UCONTEXT_SYSCALL_SYSRES(uc)                              \
+      /* Convert the value in uc_mcontext.regs[4] into a SysRes. */   \
+      VG_(mk_SysRes_loongarch64_linux)((uc)->uc_mcontext.sc_regs[4])
+
+#  define VG_UCONTEXT_TO_UnwindStartRegs(srP, uc)                     \
+      { (srP)->r_pc = (uc)->uc_mcontext.sc_pc;                        \
+        (srP)->r_sp = (uc)->uc_mcontext.sc_regs[3];                   \
+        (srP)->misc.LOONGARCH64.r_fp = (uc)->uc_mcontext.sc_regs[22]; \
+        (srP)->misc.LOONGARCH64.r_ra = (uc)->uc_mcontext.sc_regs[1];  \
+      }
+
 #elif defined(VGP_x86_solaris)
 #  define VG_UCONTEXT_INSTR_PTR(uc)       ((Addr)(uc)->uc_mcontext.gregs[VKI_EIP])
 #  define VG_UCONTEXT_STACK_PTR(uc)       ((Addr)(uc)->uc_mcontext.gregs[VKI_UESP])
@@ -899,8 +915,10 @@ void calculate_SKSS_from_SCSS ( SKSS* dst )
       if (skss_handler != VKI_SIG_IGN && skss_handler != VKI_SIG_DFL)
          skss_flags |= VKI_SA_SIGINFO;
 
+#     if !defined(VGP_loongarch64_linux)
       /* use our own restorer */
       skss_flags |= VKI_SA_RESTORER;
+#     endif
 
       /* Create SKSS entry for this signal. */
       if (sig != VKI_SIGKILL && sig != VKI_SIGSTOP)
@@ -1052,6 +1070,15 @@ extern void my_sigreturn(void);
    "   li $t4, " #name "\n" \
    "   syscall[32]\n" \
    ".previous\n"
+
+#elif defined(VGP_loongarch64_linux)
+#  define _MY_SIGRETURN(name) \
+   ".text\n" \
+   "my_sigreturn:\n" \
+   "   li.w $a7, " #name "\n" \
+   "   syscall 0\n" \
+   ".previous\n"
+
 #elif defined(VGP_x86_solaris) || defined(VGP_amd64_solaris)
 /* Not used on Solaris. */
 #  define _MY_SIGRETURN(name) \
@@ -1111,7 +1138,8 @@ static void handle_SCSS_change ( Bool force_update )
       ksa.sa_flags    = skss.skss_per_sig[sig].skss_flags;
 #     if !defined(VGP_ppc32_linux) && \
          !defined(VGP_x86_darwin) && !defined(VGP_amd64_darwin) && \
-         !defined(VGP_mips32_linux) && !defined(VGO_solaris) && !defined(VGO_freebsd)
+         !defined(VGP_mips32_linux) && !defined(VGO_solaris) && \
+         !defined(VGO_freebsd) && !defined(VGP_loongarch64_linux)
       ksa.sa_restorer = my_sigreturn;
 #     endif
       /* Re above ifdef (also the assertion below), PaulM says:
@@ -1159,7 +1187,7 @@ static void handle_SCSS_change ( Bool force_update )
             !defined(VGP_x86_darwin) && !defined(VGP_amd64_darwin) && \
             !defined(VGP_mips32_linux) && !defined(VGP_mips64_linux) && \
             !defined(VGP_nanomips_linux) && !defined(VGO_solaris) && \
-            !defined(VGO_freebsd)
+            !defined(VGO_freebsd) && !defined(VGP_loongarch64_linux)
          vg_assert(ksa_old.sa_restorer == my_sigreturn);
 #        endif
          VG_(sigaddset)( &ksa_old.sa_mask, VKI_SIGKILL );
@@ -1280,7 +1308,7 @@ SysRes VG_(do_sys_sigaction) ( Int signo,
       old_act->sa_flags    = scss.scss_per_sig[signo].scss_flags;
       old_act->sa_mask     = scss.scss_per_sig[signo].scss_mask;
 #     if !defined(VGO_darwin) && !defined(VGO_freebsd) && \
-         !defined(VGO_solaris)
+         !defined(VGO_solaris) && !defined(VGP_loongarch64_linux)
       old_act->sa_restorer = scss.scss_per_sig[signo].scss_restorer;
 #     endif
    }
@@ -1293,7 +1321,7 @@ SysRes VG_(do_sys_sigaction) ( Int signo,
 
       scss.scss_per_sig[signo].scss_restorer = NULL;
 #     if !defined(VGO_darwin) && !defined(VGO_freebsd) && \
-         !defined(VGO_solaris)
+         !defined(VGO_solaris) && !defined(VGP_loongarch64_linux)
       scss.scss_per_sig[signo].scss_restorer = new_act->sa_restorer;
 #     endif
 
@@ -1653,7 +1681,7 @@ void VG_(kill_self)(Int sigNo)
    sa.ksa_handler = VKI_SIG_DFL;
    sa.sa_flags = 0;
 #  if !defined(VGO_darwin) && !defined(VGO_freebsd) && \
-      !defined(VGO_solaris)
+      !defined(VGO_solaris) && !defined(VGP_loongarch64_linux)
    sa.sa_restorer = 0;
 #  endif
    VG_(sigemptyset)(&sa.sa_mask);
@@ -2296,8 +2324,9 @@ void VG_(synth_sigtrap)(ThreadId tid)
 // Synthesise a SIGFPE.
 void VG_(synth_sigfpe)(ThreadId tid, UInt code)
 {
-// Only tested on mips32, mips64, s390x and nanomips.
-#if !defined(VGA_mips32) && !defined(VGA_mips64) && !defined(VGA_s390x) && !defined(VGA_nanomips)
+// Only tested on mips32, mips64, s390x, nanomips and loongarch64.
+#if !defined(VGA_mips32) && !defined(VGA_mips64) && !defined(VGA_s390x) \
+    && !defined(VGA_nanomips) && !defined(VGA_loongarch64)
    vg_assert(0);
 #else
    vki_siginfo_t info;
@@ -3067,7 +3096,7 @@ void pp_ksigaction ( vki_sigaction_toK_t* sa )
                sa->ksa_handler, 
                (UInt)sa->sa_flags, 
 #              if !defined(VGO_darwin) && !defined(VGO_freebsd) && \
-                  !defined(VGO_solaris)
+                  !defined(VGO_solaris) && !defined(VGP_loongarch64_linux)
                   sa->sa_restorer
 #              else
                   (void*)0
@@ -3090,7 +3119,7 @@ void VG_(set_default_handler)(Int signo)
    sa.ksa_handler = VKI_SIG_DFL;
    sa.sa_flags = 0;
 #  if !defined(VGO_darwin) && !defined(VGO_freebsd) && \
-      !defined(VGO_solaris)
+      !defined(VGO_solaris) && !defined(VGP_loongarch64_linux)
    sa.sa_restorer = 0;
 #  endif
    VG_(sigemptyset)(&sa.sa_mask);
@@ -3212,7 +3241,7 @@ void VG_(sigstartup_actions) ( void )
 	 tsa.ksa_handler = (void *)sync_signalhandler;
 	 tsa.sa_flags = VKI_SA_SIGINFO;
 #        if !defined(VGO_darwin) && !defined(VGO_freebsd) && \
-            !defined(VGO_solaris)
+            !defined(VGO_solaris) && !defined(VGP_loongarch64_linux)
 	 tsa.sa_restorer = 0;
 #        endif
 	 VG_(sigfillset)(&tsa.sa_mask);
@@ -3240,7 +3269,7 @@ void VG_(sigstartup_actions) ( void )
 
       scss.scss_per_sig[i].scss_restorer = NULL;
 #     if !defined(VGO_darwin) && !defined(VGO_freebsd) && \
-         !defined(VGO_solaris)
+         !defined(VGO_solaris) && !defined(VGP_loongarch64_linux)
       scss.scss_per_sig[i].scss_restorer = sa.sa_restorer;
 #     endif
 
diff --git a/coregrind/m_stacktrace.c b/coregrind/m_stacktrace.c
index 0ec6f5993..0f89b6316 100644
--- a/coregrind/m_stacktrace.c
+++ b/coregrind/m_stacktrace.c
@@ -1505,6 +1505,100 @@ UInt VG_(get_StackTrace_wrk) ( ThreadId tid_if_known,
 
 #endif
 
+/* ---------------------- loongarch64 ----------------------- */
+
+#if defined(VGP_loongarch64_linux)
+UInt VG_(get_StackTrace_wrk) ( ThreadId tid_if_known,
+                               /*OUT*/Addr* ips, UInt max_n_ips,
+                               /*OUT*/Addr* sps, /*OUT*/Addr* fps,
+                               const UnwindStartRegs* startRegs,
+                               Addr fp_max_orig )
+{
+   Bool  debug = False;
+   Int   i;
+   Addr  fp_max;
+   UInt  n_found = 0;
+   const Int cmrf = VG_(clo_merge_recursive_frames);
+
+   vg_assert(sizeof(Addr) == sizeof(UWord));
+   vg_assert(sizeof(Addr) == sizeof(void*));
+
+   D3UnwindRegs uregs;
+   uregs.pc = startRegs->r_pc;
+   uregs.sp = startRegs->r_sp;
+   uregs.fp = startRegs->misc.LOONGARCH64.r_fp;
+   uregs.ra = startRegs->misc.LOONGARCH64.r_ra;
+   Addr fp_min = uregs.sp - VG_STACK_REDZONE_SZB;
+
+   /* Snaffle IPs from the client's stack into ips[0 .. max_n_ips-1],
+      stopping when the trail goes cold, which we guess to be
+      when FP is not a reasonable stack location. */
+
+   fp_max = VG_PGROUNDUP(fp_max_orig);
+   if (fp_max >= sizeof(Addr))
+      fp_max -= sizeof(Addr);
+
+   if (debug)
+      VG_(printf)("\nmax_n_ips=%u fp_min=0x%lx fp_max_orig=0x%lx, "
+                  "fp_max=0x%lx pc=0x%lx sp=0x%lx fp=0x%lx ra=0x%lx\n",
+                  max_n_ips, fp_min, fp_max_orig, fp_max,
+                  uregs.pc, uregs.sp, uregs.fp, uregs.ra);
+
+   if (sps) sps[0] = uregs.sp;
+   if (fps) fps[0] = uregs.fp;
+   ips[0] = uregs.pc;
+   i = 1;
+
+   /* Loop unwinding the stack, using CFI. */
+   while (True) {
+      if (debug)
+         VG_(printf)("i: %d, pc: 0x%lx, sp: 0x%lx, fp: 0x%lx, ra: 0x%lx\n",
+                     i, uregs.pc, uregs.sp, uregs.fp, uregs.ra);
+      if (i >= max_n_ips)
+         break;
+
+      if (VG_(use_CF_info)( &uregs, fp_min, fp_max )) {
+         if (sps) sps[i] = uregs.sp;
+         if (fps) fps[i] = uregs.fp;
+         ips[i++] = uregs.pc - 1;
+         if (debug)
+            VG_(printf)(
+               "USING CFI: pc: 0x%lx, sp: 0x%lx, fp: 0x%lx, ra: 0x%lx\n",
+               uregs.pc, uregs.sp, uregs.fp, uregs.ra);
+         uregs.pc = uregs.pc - 1;
+         RECURSIVE_MERGE(cmrf,ips,i);
+         continue;
+      }
+
+      /* A problem on the first frame? Lets assume it was a bad jump.
+         We will use the link register and the current stack and frame
+         pointers and see if we can use the CFI in the next round. */
+      if (i == 1) {
+         uregs.pc = uregs.ra;
+         uregs.ra = 0;
+
+         if (sps) sps[i] = uregs.sp;
+         if (fps) fps[i] = uregs.fp;
+         ips[i++] = uregs.pc - 1;
+         if (debug)
+            VG_(printf)(
+               "USING bad-jump: pc: 0x%lx, sp: 0x%lx, fp: 0x%lx, ra: 0x%lx\n",
+               uregs.pc, uregs.sp, uregs.fp, uregs.ra);
+         uregs.pc = uregs.pc - 1;
+         RECURSIVE_MERGE(cmrf,ips,i);
+         continue;
+      }
+
+      /* No luck.  We have to give up. */
+      break;
+   }
+
+   n_found = i;
+   return n_found;
+}
+
+#endif
+
 /*------------------------------------------------------------*/
 /*---                                                      ---*/
 /*--- END platform-dependent unwinder worker functions     ---*/
diff --git a/coregrind/m_syscall.c b/coregrind/m_syscall.c
index 1e49ed412..84d30b921 100644
--- a/coregrind/m_syscall.c
+++ b/coregrind/m_syscall.c
@@ -204,6 +204,17 @@ SysRes VG_(mk_SysRes_arm64_linux) ( Long val ) {
    return res;
 }
 
+SysRes VG_(mk_SysRes_loongarch64_linux) ( UWord val ) {
+   SysRes res;
+   res._isError = val >= -4095 && val <= -1;
+   if (res._isError) {
+      res._val = (UWord)(-val);
+   } else {
+      res._val = (UWord)val;
+   }
+   return res;
+}
+
 /* Generic constructors. */
 SysRes VG_(mk_SysRes_Success) ( UWord res ) {
    SysRes r;
@@ -1034,6 +1045,22 @@ asm (
    ".previous                              \n\t"
 );
 
+#elif defined(VGP_loongarch64_linux)
+extern UWord do_syscall_WRK (UWord a1, UWord a2, UWord a3, /* $a0, $a1, $a2 */
+                             UWord a4, UWord a5, UWord a6, /* $a3, $a4, $a5 */
+                             UWord syscall_no);            /* $a6 */
+asm (
+   ".text                                  \n\t"
+   ".globl do_syscall_WRK                  \n\t"
+   ".type  do_syscall_WRK, @function       \n\t"
+   "do_syscall_WRK:                        \n\t"
+   "   move    $a7, $a6                    \n\t"           /* a7 = syscall_no */
+   "   syscall 0                           \n\t"
+   "   jr      $ra                         \n\t"
+   ".size do_syscall_WRK, .-do_syscall_WRK \n\t"
+   ".previous                              \n\t"
+);
+
 #elif defined(VGP_x86_solaris)
 
 extern ULong
@@ -1274,6 +1301,11 @@ SysRes VG_(do_syscall) ( UWord sysno, RegWord a1, RegWord a2, RegWord a3,
    do_syscall_WRK(a1, a2, a3, a4, a5, a6, sysno, &reg_a0);
    return VG_(mk_SysRes_nanomips_linux)(reg_a0);
 
+#elif defined(VGP_loongarch64_linux)
+   UWord val = 0;
+   val = do_syscall_WRK(a1, a2, a3, a4, a5, a6, sysno);
+   return VG_(mk_SysRes_loongarch64_linux)(val);
+
 #  elif defined(VGP_x86_solaris)
    UInt val, val2, err = False;
    Bool restart;
diff --git a/coregrind/m_syswrap/priv_syswrap-linux.h b/coregrind/m_syswrap/priv_syswrap-linux.h
index d50cdcc98..1b75d586a 100644
--- a/coregrind/m_syswrap/priv_syswrap-linux.h
+++ b/coregrind/m_syswrap/priv_syswrap-linux.h
@@ -515,6 +515,13 @@ extern UInt do_syscall_clone_nanomips_linux ( Word (*fn) (void *),  /* a0 - 4 */
                                               Int*  child_tid,      /* a4 - 8 */
                                               Int*  parent_tid,     /* a5 - 9 */
                                               void* tls_ptr);       /* a6 - 10 */
+extern UInt do_syscall_clone_loongarch64_linux ( Word (*fn) (void *), /* a0 */
+                                                 void* stack,         /* a1 */
+                                                 Int   flags,         /* a2 */
+                                                 void* arg,           /* a3 */
+                                                 Int*  child_tid,     /* a4 */
+                                                 Int*  parent_tid,    /* a5 */
+                                                 void* tls_ptr);      /* a6 */
 #endif   // __PRIV_SYSWRAP_LINUX_H
 
 /*--------------------------------------------------------------------*/
diff --git a/coregrind/m_syswrap/priv_types_n_macros.h b/coregrind/m_syswrap/priv_types_n_macros.h
index dd241839a..11a9d5e1b 100644
--- a/coregrind/m_syswrap/priv_types_n_macros.h
+++ b/coregrind/m_syswrap/priv_types_n_macros.h
@@ -94,7 +94,8 @@ typedef
          || defined(VGP_ppc32_linux) \
          || defined(VGP_arm_linux) || defined(VGP_s390x_linux) \
          || defined(VGP_arm64_linux) \
-         || defined(VGP_nanomips_linux)
+         || defined(VGP_nanomips_linux) \
+         || defined(VGP_loongarch64_linux)
       Int o_arg1;
       Int o_arg2;
       Int o_arg3;
diff --git a/coregrind/m_syswrap/syscall-loongarch64-linux.S b/coregrind/m_syswrap/syscall-loongarch64-linux.S
new file mode 100644
index 000000000..5c18041ac
--- /dev/null
+++ b/coregrind/m_syswrap/syscall-loongarch64-linux.S
@@ -0,0 +1,143 @@
+
+/*--------------------------------------------------------------------*/
+/*--- Support for doing system calls.  syscall-loongarch64-linux.S ---*/
+/*--------------------------------------------------------------------*/
+
+/*
+   This file is part of Valgrind, a dynamic binary instrumentation
+   framework.
+
+   Copyright (C) 2021-2022 Loongson Technology Corporation Limited
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/>.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+#include "pub_core_basics_asm.h"
+
+#if defined(VGP_loongarch64_linux)
+
+#include "pub_core_vkiscnums_asm.h"
+#include "libvex_guest_offsets.h"
+
+/*----------------------------------------------------------------*/
+/*
+   Perform a syscall for the client. This will run a syscall
+   with the client's specific per-thread signal mask.
+
+   The structure of this function is such that, if the syscall is
+   interrupted by a signal, we can determine exactly what
+   execution state we were in with respect to the execution of
+   the syscall by examining the value of PC in the signal
+   handler. This means that we can always do the appropriate
+   thing to precisely emulate the kernel's signal/syscall
+   interactions.
+
+   The syscall number is taken from the argument, even though it
+   should also be in guest_state->guest_R11. The syscall result
+   is written back to guest_state->guest_R4 on completion.
+
+   VG_(fixup_guest_state_after_syscall_interrupted) does the
+   thread state fixup in the case where we were interrupted by a
+   signal.
+
+   Prototype:
+
+   UWord ML_(do_syscall_for_client_WRK)(
+             Int syscallno,                 // $r4 - a0
+             void* guest_state,             // $r5 - a1
+             const vki_sigset_t *sysmask,   // $r6 - a2
+             const vki_sigset_t *postmask,  // $r7 - a3
+             Int nsigwords)                 // $r8 - a4
+*/
+
+/* from vki-loongarch64-linux.h */
+#define VKI_SIG_SETMASK 2
+
+.globl ML_(do_syscall_for_client_WRK)
+ML_(do_syscall_for_client_WRK):
+
+   /* Save regs on stack */
+   addi.d  $sp, $sp, -24
+   st.d    $a1, $sp, 0                      /* guest_state */
+   st.d    $a3, $sp, 8                      /* postmask */
+   st.d    $a4, $sp, 16                     /* sigsetSzB */
+
+1: li.w    $a7, __NR_rt_sigprocmask
+   li.w    $a0, VKI_SIG_SETMASK
+   move    $a1, $a2                         /* syscall_mask */
+   move    $a2, $a3                         /* postmask */
+   move    $a3, $a4                         /* sigsetSzB */
+   syscall 0
+
+   bnez    $a0, 5f
+
+   /* Actually do the client syscall */
+   ld.d    $a6, $sp, 0                      /* guest_state */
+
+   ld.d    $a0, $a6, OFFSET_loongarch64_R4  /* a0 */
+   ld.d    $a1, $a6, OFFSET_loongarch64_R5  /* a1 */
+   ld.d    $a2, $a6, OFFSET_loongarch64_R6  /* a2 */
+   ld.d    $a3, $a6, OFFSET_loongarch64_R7  /* a3 */
+   ld.d    $a4, $a6, OFFSET_loongarch64_R8  /* a4 */
+   ld.d    $a5, $a6, OFFSET_loongarch64_R9  /* a5 */
+
+   ld.d    $a7, $a6, OFFSET_loongarch64_R11 /* syscallno */
+
+2: syscall 0
+
+   /* Saving return values into guest state */
+3: st.d    $a0, $a6, OFFSET_loongarch64_R4  /* a0 */
+
+4: li.w    $a7, __NR_rt_sigprocmask
+   li.w    $a0, VKI_SIG_SETMASK
+   ld.d    $a1, $sp, 8                      /* postmask */
+   move    $a2, $zero                       /* 0 (zero) */
+   ld.d    $a3, $sp, 16                     /* sigsetSzB */
+   syscall 0
+
+   beqz    $a0, 6f
+
+5: /* error */
+   li.w    $a0, 0x8000
+
+6: /* Restore sp and return */
+   addi.d  $sp, $sp, 24
+   jr      $ra
+
+.section .rodata
+/* export the ranges so that
+   VG_(fixup_guest_state_after_syscall_interrupted) can do the
+   right thing */
+
+.globl ML_(blksys_setup)
+.globl ML_(blksys_restart)
+.globl ML_(blksys_complete)
+.globl ML_(blksys_committed)
+.globl ML_(blksys_finished)
+ML_(blksys_setup):      .quad 1b
+ML_(blksys_restart):    .quad 2b
+ML_(blksys_complete):   .quad 3b
+ML_(blksys_committed):  .quad 4b
+ML_(blksys_finished):   .quad 5b
+
+#endif // defined(VGP_loongarch64_linux)
+
+/* Let the linker know we don't need an executable stack */
+MARK_STACK_NO_EXEC
+
+/*--------------------------------------------------------------------*/
+/*--- end                              syscall-loongarch64-linux.S ---*/
+/*--------------------------------------------------------------------*/
diff --git a/coregrind/m_syswrap/syswrap-generic.c b/coregrind/m_syswrap/syswrap-generic.c
index 7827988ca..5a8fdee62 100644
--- a/coregrind/m_syswrap/syswrap-generic.c
+++ b/coregrind/m_syswrap/syswrap-generic.c
@@ -3536,7 +3536,7 @@ POST(sys_newfstat)
 #endif
 
 #if !defined(VGO_solaris) && !defined(VGP_arm64_linux) && \
-    !defined(VGP_nanomips_linux)
+    !defined(VGP_nanomips_linux) && !defined(VGP_loongarch64_linux)
 static vki_sigset_t fork_saved_mask;
 
 // In Linux, the sys_fork() function varies across architectures, but we
diff --git a/coregrind/m_syswrap/syswrap-linux.c b/coregrind/m_syswrap/syswrap-linux.c
index 45413fdd9..d18ddea0d 100644
--- a/coregrind/m_syswrap/syswrap-linux.c
+++ b/coregrind/m_syswrap/syswrap-linux.c
@@ -310,6 +310,16 @@ static void run_a_thread_NORETURN ( Word tidW )
          : "r" (VgTs_Empty), "n" (__NR_exit), "m" (tst->os_state.exitcode)
          : "memory" , "$t4", "$a0"
       );
+#elif defined(VGP_loongarch64_linux)
+      asm volatile (
+         "st.w    %1,  %0 \n\t"     /* set tst->status = VgTs_Empty */
+         "li.w    $a7, %2 \n\t"     /* set a7 = __NR_exit */
+         "ld.w    $a0, %3 \n\t"     /* set a0 = tst->os_state.exitcode */
+         "syscall 0       \n\t"     /* exit(tst->os_state.exitcode) */
+         : "=m" (tst->status)
+         : "r" (VgTs_Empty), "n" (__NR_exit), "m" (tst->os_state.exitcode)
+         : "memory", "a0", "a7"
+      );
 #else
 # error Unknown platform
 #endif
@@ -535,6 +545,13 @@ static SysRes clone_new_thread ( Word (*fn)(void *),
       (ML_(start_thread_NORETURN), stack, flags, ctst,
        child_tidptr, parent_tidptr, NULL);
    res = VG_ (mk_SysRes_nanomips_linux) (ret);
+#elif defined(VGP_loongarch64_linux)
+   UInt ret = 0;
+   ctst->arch.vex.guest_R4 = 0;
+   ret = do_syscall_clone_loongarch64_linux
+      (ML_(start_thread_NORETURN), stack, flags, ctst,
+       child_tidptr, parent_tidptr, NULL);
+   res = VG_(mk_SysRes_loongarch64_linux)(ret);
 #else
 # error Unknown platform
 #endif
@@ -597,6 +614,8 @@ static SysRes setup_child_tls (ThreadId ctid, Addr tlsaddr)
 #elif defined(VGP_mips32_linux) || defined(VGP_nanomips_linux)
    ctst->arch.vex.guest_ULR = tlsaddr;
    ctst->arch.vex.guest_r27 = tlsaddr;
+#elif defined(VGP_loongarch64_linux)
+   ctst->arch.vex.guest_R2 = tlsaddr;
 #else
 # error Unknown platform
 #endif
@@ -755,7 +774,7 @@ static SysRes ML_(do_fork_clone) ( ThreadId tid, UInt flags,
     || defined(VGP_ppc64be_linux) || defined(VGP_ppc64le_linux)	\
     || defined(VGP_arm_linux) || defined(VGP_mips32_linux) \
     || defined(VGP_mips64_linux) || defined(VGP_arm64_linux) \
-    || defined(VGP_nanomips_linux)
+    || defined(VGP_nanomips_linux) || defined(VGP_loongarch64_linux)
    res = VG_(do_syscall5)( __NR_clone, flags, 
                            (UWord)NULL, (UWord)parent_tidptr, 
                            (UWord)NULL, (UWord)child_tidptr );
@@ -828,7 +847,8 @@ PRE(sys_clone)
 #define PRA_CHILD_TIDPTR PRA5
 #define ARG_TLS          ARG4
 #define PRA_TLS          PRA4
-#elif defined(VGP_amd64_linux) || defined(VGP_s390x_linux)
+#elif defined(VGP_amd64_linux) || defined(VGP_s390x_linux) \
+      || defined(VGP_loongarch64_linux)
 #define ARG_CHILD_TIDPTR ARG4
 #define PRA_CHILD_TIDPTR PRA4
 #define ARG_TLS          ARG5
@@ -4360,9 +4380,11 @@ PRE(sys_sigaction)
       PRE_MEM_READ( "sigaction(act->sa_handler)", (Addr)&sa->ksa_handler, sizeof(sa->ksa_handler));
       PRE_MEM_READ( "sigaction(act->sa_mask)", (Addr)&sa->sa_mask, sizeof(sa->sa_mask));
       PRE_MEM_READ( "sigaction(act->sa_flags)", (Addr)&sa->sa_flags, sizeof(sa->sa_flags));
+#if !defined(VGP_loongarch64_linux)
       if (ML_(safe_to_deref)(sa,sizeof(struct vki_old_sigaction))
           && (sa->sa_flags & VKI_SA_RESTORER))
          PRE_MEM_READ( "sigaction(act->sa_restorer)", (Addr)&sa->sa_restorer, sizeof(sa->sa_restorer));
+#endif
    }
 
    if (ARG3 != 0) {
@@ -4392,7 +4414,9 @@ PRE(sys_sigaction)
 
          new.ksa_handler = oldnew->ksa_handler;
          new.sa_flags = oldnew->sa_flags;
+#if !defined(VGP_loongarch64_linux)
          new.sa_restorer = oldnew->sa_restorer;
+#endif
          convert_sigset_to_rt(&oldnew->sa_mask, &new.sa_mask);
          newp = &new;
       }
@@ -4405,7 +4429,9 @@ PRE(sys_sigaction)
 
          oldold->ksa_handler = oldp->ksa_handler;
          oldold->sa_flags = oldp->sa_flags;
+#if !defined(VGP_loongarch64_linux)
          oldold->sa_restorer = oldp->sa_restorer;
+#endif
          oldold->sa_mask = oldp->sa_mask.sig[0];
       }
   }
@@ -4478,10 +4504,13 @@ PRE(sys_rt_sigaction)
       PRE_MEM_READ( "rt_sigaction(act->sa_handler)", (Addr)&sa->ksa_handler, sizeof(sa->ksa_handler));
       PRE_MEM_READ( "rt_sigaction(act->sa_mask)", (Addr)&sa->sa_mask, sizeof(sa->sa_mask));
       PRE_MEM_READ( "rt_sigaction(act->sa_flags)", (Addr)&sa->sa_flags, sizeof(sa->sa_flags));
+#if !defined(VGP_loongarch64_linux)
       if (ML_(safe_to_deref)(sa,sizeof(vki_sigaction_toK_t))
           && (sa->sa_flags & VKI_SA_RESTORER))
          PRE_MEM_READ( "rt_sigaction(act->sa_restorer)", (Addr)&sa->sa_restorer, sizeof(sa->sa_restorer));
+#endif
    }
+
    if (ARG3 != 0)
       PRE_MEM_WRITE( "rt_sigaction(oldact)", ARG3, sizeof(vki_sigaction_fromK_t));
 
@@ -6844,7 +6873,8 @@ POST(sys_lookup_dcookie)
 #endif
 
 #if defined(VGP_amd64_linux) || defined(VGP_s390x_linux)        \
-      || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+      || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+      || defined(VGP_loongarch64_linux)
 PRE(sys_lookup_dcookie)
 {
    *flags |= SfMayBlock;
diff --git a/coregrind/m_syswrap/syswrap-loongarch64-linux.c b/coregrind/m_syswrap/syswrap-loongarch64-linux.c
new file mode 100644
index 000000000..aadeb9e97
--- /dev/null
+++ b/coregrind/m_syswrap/syswrap-loongarch64-linux.c
@@ -0,0 +1,648 @@
+
+/*---------------------------------------------------------------------*/
+/*--- Platform-specific syscalls stuff. syswrap-loongarch64-linux.c ---*/
+/*---------------------------------------------------------------------*/
+
+/*
+   This file is part of Valgrind, a dynamic binary instrumentation
+   framework.
+
+   Copyright (C) 2021-2022 Loongson Technology Corporation Limited
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/>.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+#if defined(VGP_loongarch64_linux)
+
+#include "pub_core_basics.h"
+#include "pub_core_vki.h"
+#include "pub_core_vkiscnums.h"
+#include "pub_core_threadstate.h"
+#include "pub_core_aspacemgr.h"
+#include "pub_core_libcbase.h"
+#include "pub_core_libcassert.h"
+#include "pub_core_libcprint.h"
+#include "pub_core_libcsignal.h"
+#include "pub_core_options.h"
+#include "pub_core_scheduler.h"
+#include "pub_core_sigframe.h"      // For VG_(sigframe_destroy)()
+#include "pub_core_syscall.h"
+#include "pub_core_syswrap.h"
+#include "pub_core_tooliface.h"
+
+#include "priv_types_n_macros.h"
+#include "priv_syswrap-generic.h"   /* for decls of generic wrappers */
+#include "priv_syswrap-linux.h"     /* for decls of linux-ish wrappers */
+#include "priv_syswrap-main.h"
+
+
+/* ---------------------------------------------------------------------
+   clone() handling
+   ------------------------------------------------------------------ */
+
+/* Call f(arg1), but first switch stacks, using 'stack' as the new
+   stack, and use 'retaddr' as f's return-to address.  Also, clear all
+   the integer registers before entering f. */
+__attribute__((noreturn))
+void ML_(call_on_new_stack_0_1) ( Addr stack,
+                                  Addr retaddr,
+                                  void (*f) (Word),
+                                  Word arg1 );
+asm (
+".text\n"
+".globl vgModuleLocal_call_on_new_stack_0_1 \n\t"
+"vgModuleLocal_call_on_new_stack_0_1:       \n\t"
+"   move $sp, $a0                           \n\t" /* sp = stack */
+"   move $ra, $a1                           \n\t" /* ra = retaddr */
+"   move $t0, $a2                           \n\t" /* t0 = f */
+"   move $a0, $a3                           \n\t" /* a0 = arg1 */
+"   move $a1, $zero                         \n\t" /* zero all GP regs */
+"   move $a2, $zero                         \n\t"
+"   move $a3, $zero                         \n\t"
+"   move $a4, $zero                         \n\t"
+"   move $a5, $zero                         \n\t"
+"   move $a6, $zero                         \n\t"
+"   move $a7, $zero                         \n\t"
+/* don't zero out t0 */
+"   move $t1, $zero                         \n\t"
+"   move $t2, $zero                         \n\t"
+"   move $t3, $zero                         \n\t"
+"   move $t4, $zero                         \n\t"
+"   move $t5, $zero                         \n\t"
+"   move $t6, $zero                         \n\t"
+"   move $t7, $zero                         \n\t"
+"   move $t8, $zero                         \n\t"
+"   jr   $t0                                \n\t" /* jump to f */
+".previous                                  \n\t"
+);
+
+/*
+   Perform a clone system call.  clone is strange because it has
+   fork()-like return-twice semantics, so it needs special
+   handling here.
+
+   Upon entry, we have:
+
+      Word   (*fn)(void*) in a0
+      void*  child_stack  in a1
+      int    flags        in a2
+      void*  arg          in a3
+      pid_t* child_tid    in a4
+      pid_t* parent_tid   in a5
+      void*  tls_ptr      in a6
+
+	System call requires:
+
+      unsigned long clone_flags   in a0
+      unsigned long newsp         in a1
+		int*          parent_tidptr in a2
+		int*          child_tidptr  in a3
+		unsigned long tls           in a4
+      int           __NR_clone    in a7
+*/
+
+#define __NR_CLONE VG_STRINGIFY(__NR_clone)
+#define __NR_EXIT  VG_STRINGIFY(__NR_exit)
+
+// See priv_syswrap-linux.h for arg profile.
+asm(
+".text                                     \n\t"
+".globl do_syscall_clone_loongarch64_linux \n\t"
+"do_syscall_clone_loongarch64_linux:       \n\t"
+/* Save ra */
+"   addi.d  $sp, $sp, -16                  \n\t"
+"   st.d    $ra, $sp, 0                    \n\t"
+
+/* Save fn and arg */
+"   addi.d  $a1, $a1, -16                  \n\t"
+"   st.d    $a0, $a1, 0                    \n\t" /* fn */
+"   st.d    $a3, $a1, 8                    \n\t" /* arg */
+
+/* Call sys_clone */
+"   move    $a0, $a2                       \n\t" /* flags */
+"   move    $a2, $a5                       \n\t" /* parent */
+"   move    $a3, $a4                       \n\t" /* child */
+"   move    $a4, $a6                       \n\t" /* tls */
+"   li.w    $a7, " __NR_CLONE "            \n\t"
+"   syscall 0                              \n\t"
+
+/* If we are a child? */
+"   bnez    $a0, 1f                        \n\t"
+
+/* Restore fn and arg */
+"   ld.d    $a1, $sp, 0                    \n\t" /* fn */
+"   ld.d    $a0, $sp, 8                    \n\t" /* arg */
+
+/* Call fn(arg) */
+"   jr      $a1                            \n\t"
+
+/* Call exit(a0) */
+"   li.w    $a7, " __NR_EXIT"              \n\t"
+"   syscall 0                              \n\t"
+
+/* If we are parent or error, just return to caller */
+"1:                                        \n\t"
+"   ld.d    $ra, $sp, 0                    \n\t"
+"   addi.d  $sp, $sp, 16                   \n\t"
+"   jr      $ra                            \n\t"
+".previous                                 \n\t"
+);
+
+#undef __NR_CLONE
+#undef __NR_EXIT
+
+/* ---------------------------------------------------------------------
+   More thread stuff
+   ------------------------------------------------------------------ */
+
+// loongarch64 doesn't have any architecture specific thread stuff that
+// needs to be cleaned up
+void VG_(cleanup_thread) ( ThreadArchState* arch )
+{
+}
+
+/* ---------------------------------------------------------------------
+   PRE/POST wrappers for loongarch64/Linux-specific syscalls
+   ------------------------------------------------------------------ */
+
+#define PRE(name)       DEFN_PRE_TEMPLATE(loongarch64_linux, name)
+#define POST(name)      DEFN_POST_TEMPLATE(loongarch64_linux, name)
+
+/* Add prototypes for the wrappers declared here, so that gcc doesn't
+   harass us for not having prototypes.  Really this is a kludge --
+   the right thing to do is to make these wrappers 'static' since they
+   aren't visible outside this file, but that requires even more macro
+   magic. */
+DECL_TEMPLATE(loongarch64_linux, sys_ptrace);
+DECL_TEMPLATE(loongarch64_linux, sys_mmap);
+DECL_TEMPLATE(loongarch64_linux, sys_rt_sigreturn);
+
+PRE(sys_ptrace)
+{
+   PRINT("sys_ptrace ( %ld, %ld, %lx, %lx )",
+         SARG1, SARG2, ARG3, ARG4);
+   PRE_REG_READ4(int, "ptrace",
+                 long, request,
+                 long, pid,
+                 unsigned long, addr,
+                 unsigned long, data);
+   switch (ARG1) {
+      case VKI_PTRACE_PEEKTEXT:
+      case VKI_PTRACE_PEEKDATA:
+      case VKI_PTRACE_PEEKUSR:
+         PRE_MEM_WRITE("ptrace(peek)", ARG4, sizeof(long));
+         break;
+      case VKI_PTRACE_GETEVENTMSG:
+         PRE_MEM_WRITE("ptrace(geteventmsg)", ARG4, sizeof(unsigned long));
+         break;
+      case VKI_PTRACE_GETSIGINFO:
+         PRE_MEM_WRITE("ptrace(getsiginfo)", ARG4, sizeof(vki_siginfo_t));
+         break;
+      case VKI_PTRACE_SETSIGINFO:
+         PRE_MEM_READ("ptrace(setsiginfo)", ARG4, sizeof(vki_siginfo_t));
+         break;
+      case VKI_PTRACE_GETREGSET:
+         ML_(linux_PRE_getregset)(tid, ARG3, ARG4);
+         break;
+      default:
+         break;
+   }
+}
+
+POST(sys_ptrace)
+{
+   switch (ARG1) {
+      case VKI_PTRACE_TRACEME:
+         ML_(linux_POST_traceme)(tid);
+         break;
+      case VKI_PTRACE_PEEKTEXT:
+      case VKI_PTRACE_PEEKDATA:
+      case VKI_PTRACE_PEEKUSR:
+         POST_MEM_WRITE (ARG4, sizeof(long));
+         break;
+      case VKI_PTRACE_GETEVENTMSG:
+         POST_MEM_WRITE (ARG4, sizeof(unsigned long));
+      break;
+      case VKI_PTRACE_GETSIGINFO:
+         POST_MEM_WRITE (ARG4, sizeof(vki_siginfo_t));
+         break;
+      case VKI_PTRACE_GETREGSET:
+         ML_(linux_POST_getregset)(tid, ARG3, ARG4);
+         break;
+      default:
+      break;
+   }
+}
+
+PRE(sys_mmap)
+{
+   SysRes r;
+
+   PRINT("sys_mmap ( %#lx, %lu, %lu, %#lx, %lu, %lu )",
+         ARG1, ARG2, ARG3, ARG4, ARG5, ARG6 );
+   PRE_REG_READ6(long, "mmap",
+                 unsigned long, addr, unsigned long, len,
+                 unsigned long, prot, unsigned long, flags,
+                 unsigned long, fd,   vki_off_t,     offset);
+
+   r = ML_(generic_PRE_sys_mmap)( tid, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6 );
+   SET_STATUS_from_SysRes(r);
+}
+
+PRE(sys_rt_sigreturn)
+{
+   /* See comments on PRE(sys_rt_sigreturn) in syswrap-loongarch64-linux.c for
+      an explanation of what follows. */
+   ThreadState* tst;
+   PRINT("rt_sigreturn ( )");
+
+   vg_assert(VG_(is_valid_tid)(tid));
+   vg_assert(tid >= 1 && tid < VG_N_THREADS);
+   vg_assert(VG_(is_running_thread)(tid));
+
+   tst = VG_(get_ThreadState)(tid);
+
+   /* This is only so that the PC is (might be) useful to report if
+      something goes wrong in the sigreturn */
+   ML_(fixup_guest_state_to_restart_syscall)(&tst->arch);
+
+   /* Restore register state from frame and remove it */
+   VG_(sigframe_destroy)(tid, True);
+
+   /* Tell the driver not to update the guest state with the "result",
+      and set a bogus result to keep it happy. */
+   *flags |= SfNoWriteResult;
+   SET_STATUS_Success(0);
+
+   /* Check to see if any signals arose as a result of this. */
+   *flags |= SfPollAfter;
+}
+
+#undef PRE
+#undef POST
+
+/* ---------------------------------------------------------------------
+   The loongarch64/Linux syscall table
+   ------------------------------------------------------------------ */
+
+#define PLAX_(sysno, name)    WRAPPER_ENTRY_X_(loongarch64_linux, sysno, name)
+#define PLAXY(sysno, name)    WRAPPER_ENTRY_XY(loongarch64_linux, sysno, name)
+
+// This table maps from __NR_xxx syscall numbers (from
+// linux/include/uapi/asm-generic/unistd.h) to the appropriate PRE/POST
+// sys_foo() wrappers on loongarch64 (as per sys_call_table in
+// linux/arch/loongarch/kernel/syscall.c).
+//
+// For those syscalls not handled by Valgrind, the annotation indicate its
+// arch/OS combination, eg. */* (generic), */Linux (Linux only), ?/?
+// (unknown).
+
+static SyscallTableEntry syscall_main_table[] = {
+   LINXY(__NR_io_setup,                sys_io_setup),                // 0
+   LINX_(__NR_io_destroy,              sys_io_destroy),              // 1
+   LINX_(__NR_io_submit,               sys_io_submit),               // 2
+   LINXY(__NR_io_cancel,               sys_io_cancel),               // 3
+   LINXY(__NR_io_getevents,            sys_io_getevents),            // 4
+   LINX_(__NR_setxattr,                sys_setxattr),                // 5
+   LINX_(__NR_lsetxattr,               sys_lsetxattr),               // 6
+   LINX_(__NR_fsetxattr,               sys_fsetxattr),               // 7
+   LINXY(__NR_getxattr,                sys_getxattr),                // 8
+   LINXY(__NR_lgetxattr,               sys_lgetxattr),               // 9
+   LINXY(__NR_fgetxattr,               sys_fgetxattr),               // 10
+   LINXY(__NR_listxattr,               sys_listxattr),               // 11
+   LINXY(__NR_llistxattr,              sys_llistxattr),              // 12
+   LINXY(__NR_flistxattr,              sys_flistxattr),              // 13
+   LINX_(__NR_removexattr,             sys_removexattr),             // 14
+   LINX_(__NR_lremovexattr,            sys_lremovexattr),            // 15
+   LINX_(__NR_fremovexattr,            sys_fremovexattr),            // 16
+   GENXY(__NR_getcwd,                  sys_getcwd),                  // 17
+   LINXY(__NR_lookup_dcookie,          sys_lookup_dcookie),          // 18
+   LINXY(__NR_eventfd2,                sys_eventfd2),                // 19
+   LINXY(__NR_epoll_create1,           sys_epoll_create1),           // 20
+   LINX_(__NR_epoll_ctl,               sys_epoll_ctl),               // 21
+   LINXY(__NR_epoll_pwait,             sys_epoll_pwait),             // 22
+   GENXY(__NR_dup,                     sys_dup),                     // 23
+   LINXY(__NR_dup3,                    sys_dup3),                    // 24
+   LINXY(__NR3264_fcntl,               sys_fcntl),                   // 25
+   LINXY(__NR_inotify_init1,           sys_inotify_init1),           // 26
+   LINX_(__NR_inotify_add_watch,       sys_inotify_add_watch),       // 27
+   LINX_(__NR_inotify_rm_watch,        sys_inotify_rm_watch),        // 28
+   LINXY(__NR_ioctl,                   sys_ioctl),                   // 29
+   LINX_(__NR_ioprio_set,              sys_ioprio_set),              // 30
+   LINX_(__NR_ioprio_get,              sys_ioprio_get),              // 31
+   GENX_(__NR_flock,                   sys_flock),                   // 32
+   LINX_(__NR_mknodat,                 sys_mknodat),                 // 33
+   LINX_(__NR_mkdirat,                 sys_mkdirat),                 // 34
+   LINX_(__NR_unlinkat,                sys_unlinkat),                // 35
+   LINX_(__NR_symlinkat,               sys_symlinkat),               // 36
+   LINX_(__NR_linkat,                  sys_linkat),                  // 37
+   //   (__NR_renameat,                sys_renameat),                // 38
+   LINX_(__NR_umount2,                 sys_umount),                  // 39
+   LINX_(__NR_mount,                   sys_mount),                   // 40
+   LINX_(__NR_pivot_root,              sys_pivot_root),              // 41
+   //   (__NR_nfsservctl,              sys_ni_syscall),              // 42
+   GENXY(__NR3264_statfs,              sys_statfs),                  // 43
+   GENXY(__NR3264_fstatfs,             sys_fstatfs),                 // 44
+   GENX_(__NR3264_truncate,            sys_truncate),                // 45
+   GENX_(__NR3264_ftruncate,           sys_ftruncate),               // 46
+   LINX_(__NR_fallocate,               sys_fallocate),               // 47
+   LINX_(__NR_faccessat,               sys_faccessat),               // 48
+   GENX_(__NR_chdir,                   sys_chdir),                   // 49
+   GENX_(__NR_fchdir,                  sys_fchdir),                  // 50
+   GENX_(__NR_chroot,                  sys_chroot),                  // 51
+   GENX_(__NR_fchmod,                  sys_fchmod),                  // 52
+   LINX_(__NR_fchmodat,                sys_fchmodat),                // 53
+   LINX_(__NR_fchownat,                sys_fchownat),                // 54
+   GENX_(__NR_fchown,                  sys_fchown),                  // 55
+   LINXY(__NR_openat,                  sys_openat),                  // 56
+   GENX_(__NR_close,                   sys_close),                   // 57
+   LINX_(__NR_vhangup,                 sys_vhangup),                 // 58
+   LINXY(__NR_pipe2,                   sys_pipe2),                   // 59
+   LINX_(__NR_quotactl,                sys_quotactl),                // 60
+   GENXY(__NR_getdents64,              sys_getdents64),              // 61
+   LINX_(__NR3264_lseek,               sys_lseek),                   // 62
+   GENXY(__NR_read,                    sys_read),                    // 63
+   GENX_(__NR_write,                   sys_write),                   // 64
+   GENXY(__NR_readv,                   sys_readv),                   // 65
+   GENX_(__NR_writev,                  sys_writev),                  // 66
+   GENXY(__NR_pread64,                 sys_pread64),                 // 67
+   GENX_(__NR_pwrite64,                sys_pwrite64),                // 68
+   LINXY(__NR_preadv,                  sys_preadv),                  // 69
+   LINX_(__NR_pwritev,                 sys_pwritev),                 // 70
+   LINXY(__NR3264_sendfile,            sys_sendfile),                // 71
+   LINXY(__NR_pselect6,                sys_pselect6),                // 72
+   LINXY(__NR_ppoll,                   sys_ppoll),                   // 73
+   LINXY(__NR_signalfd4,               sys_signalfd4),               // 74
+   LINX_(__NR_vmsplice,                sys_vmsplice),                // 75
+   LINX_(__NR_splice,                  sys_splice),                  // 76
+   LINX_(__NR_tee,                     sys_tee),                     // 77
+   LINX_(__NR_readlinkat,              sys_readlinkat),              // 78
+   //   (__NR3264_fstatat,             sys_newfstatat),              // 79
+   //   (__NR3264_fstat,               sys_newfstat),                // 80
+   GENX_(__NR_sync,                    sys_sync),                    // 81
+   GENX_(__NR_fsync,                   sys_fsync),                   // 82
+   GENX_(__NR_fdatasync,               sys_fdatasync),               // 83
+   LINX_(__NR_sync_file_range,         sys_sync_file_range),         // 84
+   LINXY(__NR_timerfd_create,          sys_timerfd_create),          // 85
+   LINXY(__NR_timerfd_settime,         sys_timerfd_settime),         // 86
+   LINXY(__NR_timerfd_gettime,         sys_timerfd_gettime),         // 87
+   LINX_(__NR_utimensat,               sys_utimensat),               // 88
+   GENX_(__NR_acct,                    sys_acct),                    // 89
+   LINXY(__NR_capget,                  sys_capget),                  // 90
+   LINX_(__NR_capset,                  sys_capset),                  // 91
+   LINX_(__NR_personality,             sys_personality),             // 92
+   GENX_(__NR_exit,                    sys_exit),                    // 93
+   LINX_(__NR_exit_group,              sys_exit_group),              // 94
+   LINXY(__NR_waitid,                  sys_waitid),                  // 95
+   LINX_(__NR_set_tid_address,         sys_set_tid_address),         // 96
+   LINX_(__NR_unshare,                 sys_unshare),                 // 97
+   LINXY(__NR_futex,                   sys_futex),                   // 98
+   LINX_(__NR_set_robust_list,         sys_set_robust_list),         // 99
+   LINXY(__NR_get_robust_list,         sys_get_robust_list),         // 100
+   GENXY(__NR_nanosleep,               sys_nanosleep),               // 101
+   GENXY(__NR_getitimer,               sys_getitimer),               // 102
+   GENXY(__NR_setitimer,               sys_setitimer),               // 103
+   //   (__NR_kexec_load,              sys_kexec_load),              // 104
+   LINX_(__NR_init_module,             sys_init_module),             // 105
+   LINX_(__NR_delete_module,           sys_delete_module),           // 106
+   LINXY(__NR_timer_create,            sys_timer_create),            // 107
+   LINXY(__NR_timer_gettime,           sys_timer_gettime),           // 108
+   LINX_(__NR_timer_getoverrun,        sys_timer_getoverrun),        // 109
+   LINXY(__NR_timer_settime,           sys_timer_settime),           // 110
+   LINX_(__NR_timer_delete,            sys_timer_delete),            // 111
+   LINX_(__NR_clock_settime,           sys_clock_settime),           // 112
+   LINXY(__NR_clock_gettime,           sys_clock_gettime),           // 113
+   LINXY(__NR_clock_getres,            sys_clock_getres),            // 114
+   LINXY(__NR_clock_nanosleep,         sys_clock_nanosleep),         // 115
+   LINXY(__NR_syslog,                  sys_syslog),                  // 116
+   PLAXY(__NR_ptrace,                  sys_ptrace),                  // 117
+   LINXY(__NR_sched_setparam,          sys_sched_setparam),          // 118
+   LINX_(__NR_sched_setscheduler,      sys_sched_setscheduler),      // 119
+   LINX_(__NR_sched_getscheduler,      sys_sched_getscheduler),      // 120
+   LINXY(__NR_sched_getparam,          sys_sched_getparam),          // 121
+   LINX_(__NR_sched_setaffinity,       sys_sched_setaffinity),       // 122
+   LINXY(__NR_sched_getaffinity,       sys_sched_getaffinity),       // 123
+   LINX_(__NR_sched_yield,             sys_sched_yield),             // 124
+   LINX_(__NR_sched_get_priority_max,  sys_sched_get_priority_max),  // 125
+   LINX_(__NR_sched_get_priority_min,  sys_sched_get_priority_min),  // 126
+   LINXY(__NR_sched_rr_get_interval,   sys_sched_rr_get_interval),   // 127
+   //   (__NR_restart_syscall,         sys_restart_syscall),         // 128
+   GENX_(__NR_kill,                    sys_kill),                    // 129
+   LINXY(__NR_tkill,                   sys_tkill),                   // 130
+   LINX_(__NR_tgkill,                  sys_tgkill),                  // 131
+   GENXY(__NR_sigaltstack,             sys_sigaltstack),             // 132
+   LINX_(__NR_rt_sigsuspend,           sys_rt_sigsuspend),           // 133
+   LINXY(__NR_rt_sigaction,            sys_rt_sigaction),            // 134
+   LINXY(__NR_rt_sigprocmask,          sys_rt_sigprocmask),          // 135
+   LINXY(__NR_rt_sigpending,           sys_rt_sigpending),           // 136
+   LINXY(__NR_rt_sigtimedwait,         sys_rt_sigtimedwait),         // 137
+   LINXY(__NR_rt_sigqueueinfo,         sys_rt_sigqueueinfo),         // 138
+   PLAX_(__NR_rt_sigreturn,            sys_rt_sigreturn),            // 139
+   GENX_(__NR_setpriority,             sys_setpriority),             // 140
+   GENX_(__NR_getpriority,             sys_getpriority),             // 141
+   //   (__NR_reboot,                  sys_reboot),                  // 142
+   GENX_(__NR_setregid,                sys_setregid),                // 143
+   GENX_(__NR_setgid,                  sys_setgid),                  // 144
+   GENX_(__NR_setreuid,                sys_setreuid),                // 145
+   GENX_(__NR_setuid,                  sys_setuid),                  // 146
+   LINX_(__NR_setresuid,               sys_setresuid),               // 147
+   LINXY(__NR_getresuid,               sys_getresuid),               // 148
+   LINX_(__NR_setresgid,               sys_setresgid),               // 149
+   LINXY(__NR_getresgid,               sys_getresgid),               // 150
+   LINX_(__NR_setfsuid,                sys_setfsuid),                // 151
+   LINX_(__NR_setfsgid,                sys_setfsgid),                // 152
+   GENXY(__NR_times,                   sys_times),                   // 153
+   GENX_(__NR_setpgid,                 sys_setpgid),                 // 154
+   GENX_(__NR_getpgid,                 sys_getpgid),                 // 155
+   GENX_(__NR_getsid,                  sys_getsid),                  // 156
+   GENX_(__NR_setsid,                  sys_setsid),                  // 157
+   GENXY(__NR_getgroups,               sys_getgroups),               // 158
+   GENX_(__NR_setgroups,               sys_setgroups),               // 159
+   GENXY(__NR_uname,                   sys_newuname),                // 160
+   GENX_(__NR_sethostname,             sys_sethostname),             // 161
+   //   (__NR_setdomainname,           sys_setdomainname),           // 162
+   //   (__NR_getrlimit,               sys_old_getrlimit),           // 163
+   //   (__NR_setrlimit,               sys_setrlimit),               // 164
+   GENXY(__NR_getrusage,               sys_getrusage),               // 165
+   GENX_(__NR_umask,                   sys_umask),                   // 166
+   LINXY(__NR_prctl,                   sys_prctl),                   // 167
+   LINXY(__NR_getcpu,                  sys_getcpu),                  // 168
+   GENXY(__NR_gettimeofday,            sys_gettimeofday),            // 169
+   GENX_(__NR_settimeofday,            sys_settimeofday),            // 170
+   LINXY(__NR_adjtimex,                sys_adjtimex),                // 171
+   GENX_(__NR_getpid,                  sys_getpid),                  // 172
+   GENX_(__NR_getppid,                 sys_getppid),                 // 173
+   GENX_(__NR_getuid,                  sys_getuid),                  // 174
+   GENX_(__NR_geteuid,                 sys_geteuid),                 // 175
+   GENX_(__NR_getgid,                  sys_getgid),                  // 176
+   GENX_(__NR_getegid,                 sys_getegid),                 // 177
+   LINX_(__NR_gettid,                  sys_gettid),                  // 178
+   LINXY(__NR_sysinfo,                 sys_sysinfo),                 // 179
+   LINXY(__NR_mq_open,                 sys_mq_open),                 // 180
+   LINX_(__NR_mq_unlink,               sys_mq_unlink),               // 181
+   LINX_(__NR_mq_timedsend,            sys_mq_timedsend),            // 182
+   LINXY(__NR_mq_timedreceive,         sys_mq_timedreceive),         // 183
+   LINX_(__NR_mq_notify,               sys_mq_notify),               // 184
+   LINXY(__NR_mq_getsetattr,           sys_mq_getsetattr),           // 185
+   LINX_(__NR_msgget,                  sys_msgget),                  // 186
+   LINXY(__NR_msgctl,                  sys_msgctl),                  // 187
+   LINXY(__NR_msgrcv,                  sys_msgrcv),                  // 188
+   LINX_(__NR_msgsnd,                  sys_msgsnd),                  // 189
+   LINX_(__NR_semget,                  sys_semget),                  // 190
+   LINXY(__NR_semctl,                  sys_semctl),                  // 191
+   LINX_(__NR_semtimedop,              sys_semtimedop),              // 192
+   LINX_(__NR_semop,                   sys_semop),                   // 193
+   LINX_(__NR_shmget,                  sys_shmget),                  // 194
+   LINXY(__NR_shmctl,                  sys_shmctl),                  // 195
+   LINXY(__NR_shmat,                   sys_shmat),                   // 196
+   LINXY(__NR_shmdt,                   sys_shmdt),                   // 197
+   LINXY(__NR_socket,                  sys_socket),                  // 198
+   LINXY(__NR_socketpair,              sys_socketpair),              // 199
+   LINX_(__NR_bind,                    sys_bind),                    // 200
+   LINX_(__NR_listen,                  sys_listen),                  // 201
+   LINXY(__NR_accept,                  sys_accept),                  // 202
+   LINX_(__NR_connect,                 sys_connect),                 // 203
+   LINXY(__NR_getsockname,             sys_getsockname),             // 204
+   LINXY(__NR_getpeername,             sys_getpeername),             // 205
+   LINX_(__NR_sendto,                  sys_sendto),                  // 206
+   LINXY(__NR_recvfrom,                sys_recvfrom),                // 207
+   LINX_(__NR_setsockopt,              sys_setsockopt),              // 208
+   LINXY(__NR_getsockopt,              sys_getsockopt),              // 209
+   LINX_(__NR_shutdown,                sys_shutdown),                // 210
+   LINX_(__NR_sendmsg,                 sys_sendmsg),                 // 211
+   LINXY(__NR_recvmsg,                 sys_recvmsg),                 // 212
+   LINX_(__NR_readahead,               sys_readahead),               // 213
+   GENX_(__NR_brk,                     sys_brk),                     // 214
+   GENXY(__NR_munmap,                  sys_munmap),                  // 215
+   GENX_(__NR_mremap,                  sys_mremap),                  // 216
+   LINX_(__NR_add_key,                 sys_add_key),                 // 217
+   LINX_(__NR_request_key,             sys_request_key),             // 218
+   LINXY(__NR_keyctl,                  sys_keyctl),                  // 219
+   LINX_(__NR_clone,                   sys_clone),                   // 220
+   GENX_(__NR_execve,                  sys_execve),                  // 221
+   PLAX_(__NR3264_mmap,                sys_mmap),                    // 222
+   LINX_(__NR3264_fadvise64,           sys_fadvise64),               // 223
+   //   (__NR_swapon,                  sys_swapon),                  // 224
+   //   (__NR_swapoff,                 sys_swapoff),                 // 225
+   GENXY(__NR_mprotect,                sys_mprotect),                // 226
+   GENX_(__NR_msync,                   sys_msync),                   // 227
+   GENX_(__NR_mlock,                   sys_mlock),                   // 228
+   GENX_(__NR_munlock,                 sys_munlock),                 // 229
+   GENX_(__NR_mlockall,                sys_mlockall),                // 230
+   LINX_(__NR_munlockall,              sys_munlockall),              // 231
+   GENXY(__NR_mincore,                 sys_mincore),                 // 232
+   GENX_(__NR_madvise,                 sys_madvise),                 // 233
+   //   (__NR_remap_file_pages,        sys_remap_file_pages),        // 234
+   LINX_(__NR_mbind,                   sys_mbind),                   // 235
+   LINXY(__NR_get_mempolicy,           sys_get_mempolicy),           // 236
+   LINX_(__NR_set_mempolicy,           sys_set_mempolicy),           // 237
+   //   (__NR_migrate_pages,           sys_migrate_pages),           // 238
+   LINXY(__NR_move_pages,              sys_move_pages),              // 239
+   LINXY(__NR_rt_tgsigqueueinfo,       sys_rt_tgsigqueueinfo),       // 240
+   LINXY(__NR_perf_event_open,         sys_perf_event_open),         // 241
+   LINXY(__NR_accept4,                 sys_accept4),                 // 242
+   LINXY(__NR_recvmmsg,                sys_recvmmsg),                // 243
+
+   GENXY(__NR_wait4,                   sys_wait4),                   // 260
+   LINXY(__NR_prlimit64,               sys_prlimit64),               // 261
+   LINXY(__NR_fanotify_init,           sys_fanotify_init),           // 262
+   LINX_(__NR_fanotify_mark,           sys_fanotify_mark),           // 263
+   LINXY(__NR_name_to_handle_at,       sys_name_to_handle_at),       // 264
+   LINXY(__NR_open_by_handle_at,       sys_open_by_handle_at),       // 265
+   LINXY(__NR_clock_adjtime,           sys_clock_adjtime),           // 266
+   LINX_(__NR_syncfs,                  sys_syncfs),                  // 267
+   LINX_(__NR_setns,                   sys_setns),                   // 268
+   LINXY(__NR_sendmmsg,                sys_sendmmsg),                // 269
+   LINXY(__NR_process_vm_readv,        sys_process_vm_readv),        // 270
+   LINX_(__NR_process_vm_writev,       sys_process_vm_writev),       // 271
+   LINX_(__NR_kcmp,                    sys_kcmp),                    // 272
+   LINX_(__NR_finit_module,            sys_finit_module),            // 273
+   LINX_(__NR_sched_setattr,           sys_sched_setattr),           // 274
+   LINXY(__NR_sched_getattr,           sys_sched_getattr),           // 275
+   LINX_(__NR_renameat2,               sys_renameat2),               // 276
+   //   (__NR_seccomp,                 sys_seccomp),                 // 277
+   LINXY(__NR_getrandom,               sys_getrandom),               // 278
+   LINXY(__NR_memfd_create,            sys_memfd_create),            // 279
+   LINXY(__NR_bpf,                     sys_bpf),                     // 280
+   LINX_(__NR_execveat,                sys_execveat),                // 281
+   //   (__NR_userfaultfd,             sys_userfaultfd),             // 282
+   LINX_(__NR_membarrier,              sys_membarrier),              // 283
+   GENX_(__NR_mlock2,                  sys_mlock2),                  // 284
+   LINX_(__NR_copy_file_range,         sys_copy_file_range),         // 285
+   LINXY(__NR_preadv2,                 sys_preadv2),                 // 286
+   LINX_(__NR_pwritev2,                sys_pwritev2),                // 287
+   //   (__NR_pkey_mprotect,           sys_pkey_mprotect),           // 288
+   //   (__NR_pkey_alloc,              sys_pkey_alloc),              // 289
+   //   (__NR_pkey_free,               sys_pkey_free),               // 290
+   LINXY(__NR_statx,                   sys_statx),                   // 291
+   //   (__NR_io_pgetevents,           sys_io_pgetevents),           // 292
+   //   (__NR_rseq,                    sys_rseq),                    // 293
+   //   (__NR_kexec_file_load,         sys_kexec_file_load),         // 294
+
+   //   (__NR_pidfd_send_signal,       sys_pidfd_send_signal),       // 424
+   LINXY(__NR_io_uring_setup,          sys_io_uring_setup),          // 425
+   LINXY(__NR_io_uring_enter,          sys_io_uring_enter),          // 426
+   LINXY(__NR_io_uring_register,       sys_io_uring_register),       // 427
+   //   (__NR_open_tree,               sys_open_tree),               // 428
+   //   (__NR_move_mount,              sys_move_mount),              // 429
+   //   (__NR_fsopen,                  sys_fsopen),                  // 430
+   //   (__NR_fsconfig,                sys_fsconfig),                // 431
+   //   (__NR_fsmount,                 sys_fsmount),                 // 432
+   //   (__NR_fspick,                  sys_fspick),                  // 433
+   //   (__NR_pidfd_open,              sys_pidfd_open),              // 434
+   GENX_(__NR_clone3,                  sys_ni_syscall),              // 435
+   LINXY(__NR_close_range,             sys_close_range),             // 436
+   LINXY(__NR_openat2,                 sys_openat2),                 // 437
+   LINXY(__NR_pidfd_getfd,             sys_pidfd_getfd),             // 438
+   LINX_(__NR_faccessat2,              sys_faccessat2),              // 439
+   //   (__NR_process_madvise,         sys_process_madvise),         // 440
+   LINXY(__NR_epoll_pwait2,            sys_epoll_pwait2),            // 441
+   //   (__NR_mount_setattr,           sys_mount_setattr),           // 442
+   //   (__NR_quotactl_fd,             sys_quotactl_fd),             // 443
+   //   (__NR_landlock_create_ruleset, sys_landlock_create_ruleset), // 444
+   //   (__NR_landlock_add_rule,       sys_landlock_add_rule),       // 445
+   //   (__NR_landlock_restrict_self,  sys_landlock_restrict_self),  // 446
+   //   (__NR_memfd_secret,            sys_memfd_secret),            // 447
+   //   (__NR_process_mrelease,        sys_process_mrelease),        // 448
+   //   (__NR_futex_waitv,             sys_futex_waitv)              // 449
+   //   (__NR_set_mempolicy_home_node, sys_set_mempolicy_home_node)  // 450
+   //   (__NR_cachestat,               sys_cachestat)                // 451
+   LINX_(__NR_fchmodat2,               sys_fchmodat2)                // 452
+};
+
+SyscallTableEntry* ML_(get_linux_syscall_entry) ( UInt sysno )
+{
+   const UInt syscall_main_table_size
+      = sizeof(syscall_main_table) / sizeof(syscall_main_table[0]);
+
+   /* Is it in the contiguous initial section of the table? */
+   if (sysno < syscall_main_table_size) {
+      SyscallTableEntry* sys = &syscall_main_table[sysno];
+      if (sys->before == NULL)
+         return NULL; /* no entry */
+      else
+         return sys;
+   }
+
+   /* Can't find a wrapper */
+   return NULL;
+}
+
+#endif  /* defined(VGP_loongarch64_linux) */
+
+/*--------------------------------------------------------------------*/
+/*--- end                              syswrap-loongarch64-linux.c ---*/
+/*--------------------------------------------------------------------*/
diff --git a/coregrind/m_syswrap/syswrap-main.c b/coregrind/m_syswrap/syswrap-main.c
index eae3f8a62..d6af620ef 100644
--- a/coregrind/m_syswrap/syswrap-main.c
+++ b/coregrind/m_syswrap/syswrap-main.c
@@ -60,20 +60,21 @@
 /* Useful info which needs to be recorded somewhere:
    Use of registers in syscalls is:
 
-          NUM   ARG1 ARG2 ARG3 ARG4 ARG5 ARG6 ARG7 ARG8 RESULT
+               NUM   ARG1 ARG2 ARG3 ARG4 ARG5 ARG6 ARG7 ARG8 RESULT
    LINUX:
-   x86    eax   ebx  ecx  edx  esi  edi  ebp  n/a  n/a  eax       (== NUM)
-   amd64  rax   rdi  rsi  rdx  r10  r8   r9   n/a  n/a  rax       (== NUM)
-   ppc32  r0    r3   r4   r5   r6   r7   r8   n/a  n/a  r3+CR0.SO (== ARG1)
-   ppc64  r0    r3   r4   r5   r6   r7   r8   n/a  n/a  r3+CR0.SO (== ARG1)
-   arm    r7    r0   r1   r2   r3   r4   r5   n/a  n/a  r0        (== ARG1)
-   mips32 v0    a0   a1   a2   a3 stack stack n/a  n/a  v0        (== NUM)
-   mips64 v0    a0   a1   a2   a3   a4   a5   a6   a7   v0        (== NUM)
-   arm64  x8    x0   x1   x2   x3   x4   x5   n/a  n/a  x0 ??     (== ARG1??)
+   x86         eax   ebx  ecx  edx  esi  edi  ebp  n/a  n/a  eax       (== NUM)
+   amd64       rax   rdi  rsi  rdx  r10  r8   r9   n/a  n/a  rax       (== NUM)
+   ppc32       r0    r3   r4   r5   r6   r7   r8   n/a  n/a  r3+CR0.SO (== ARG1)
+   ppc64       r0    r3   r4   r5   r6   r7   r8   n/a  n/a  r3+CR0.SO (== ARG1)
+   arm         r7    r0   r1   r2   r3   r4   r5   n/a  n/a  r0        (== ARG1)
+   mips32      v0    a0   a1   a2   a3 stack stack n/a  n/a  v0        (== NUM)
+   mips64      v0    a0   a1   a2   a3   a4   a5   a6   a7   v0        (== NUM)
+   arm64       x8    x0   x1   x2   x3   x4   x5   n/a  n/a  x0 ??     (== ARG1??)
+   loongarch64 r11   r4   r5   r6   r7   r8   r9   n/a  n/a  r4        (== ARG1)
 
    FreeBSD:
-   x86    eax +4   +8   +12  +16  +20  +24  +28  +32  edx:eax, eflags.c
-   amd64  rax rdi  rsi  rdx  rcx  r8   r9   +8   +16  rdx:rax, rflags.c
+   x86         eax   +4   +8   +12  +16  +20  +24  +28  +32  edx:eax, eflags.c
+   amd64       rax   rdi  rsi  rdx  rcx  r8   r9   +8   +16  rdx:rax, rflags.c
 
    On s390x the svc instruction is used for system calls. The system call
    number is encoded in the instruction (8 bit immediate field). Since Linux
@@ -703,6 +704,17 @@ void getSyscallArgsFromGuestState ( /*OUT*/SyscallArgs*       canonical,
    canonical->arg6  = gst->guest_r9;    // a5
    canonical->arg7  = gst->guest_r10;   // a6
    canonical->arg8  = gst->guest_r11;   // a7
+
+#elif defined(VGP_loongarch64_linux)
+   VexGuestLOONGARCH64State* gst = (VexGuestLOONGARCH64State*)gst_vanilla;
+   canonical->sysno = gst->guest_R11;   // a7
+   canonical->arg1  = gst->guest_R4;    // a0
+   canonical->arg2  = gst->guest_R5;    // a1
+   canonical->arg3  = gst->guest_R6;    // a2
+   canonical->arg4  = gst->guest_R7;    // a3
+   canonical->arg5  = gst->guest_R8;    // a4
+   canonical->arg6  = gst->guest_R9;    // a5
+
 #elif defined(VGP_x86_darwin)
    VexGuestX86State* gst = (VexGuestX86State*)gst_vanilla;
    UWord *stack = (UWord *)gst->guest_ESP;
@@ -1126,6 +1138,16 @@ void putSyscallArgsIntoGuestState ( /*IN*/ SyscallArgs*       canonical,
    gst->guest_r10 = canonical->arg7;
    gst->guest_r11 = canonical->arg8;
 
+#elif defined(VGP_loongarch64_linux)
+   VexGuestLOONGARCH64State* gst = (VexGuestLOONGARCH64State*)gst_vanilla;
+   gst->guest_R11 = canonical->sysno;
+   gst->guest_R4  = canonical->arg1;
+   gst->guest_R5  = canonical->arg2;
+   gst->guest_R6  = canonical->arg3;
+   gst->guest_R7  = canonical->arg4;
+   gst->guest_R8  = canonical->arg5;
+   gst->guest_R9  = canonical->arg6;
+
 #elif defined(VGP_x86_solaris)
    VexGuestX86State* gst = (VexGuestX86State*)gst_vanilla;
    UWord *stack = (UWord *)gst->guest_ESP;
@@ -1240,6 +1262,13 @@ void getSyscallStatusFromGuestState ( /*OUT*/SyscallStatus*     canonical,
    RegWord  a0 = gst->guest_r4;    // a0
    canonical->sres = VG_(mk_SysRes_nanomips_linux)(a0);
    canonical->what = SsComplete;
+
+#  elif defined(VGP_loongarch64_linux)
+   VexGuestLOONGARCH64State* gst = (VexGuestLOONGARCH64State*)gst_vanilla;
+   ULong                     a0  = gst->guest_R4;    // a0
+   canonical->sres = VG_(mk_SysRes_loongarch64_linux)(a0);
+   canonical->what = SsComplete;
+
 #  elif defined(VGP_amd64_freebsd)
    /* duplicates logic in m_signals.VG_UCONTEXT_SYSCALL_SYSRES */
    VexGuestAMD64State* gst = (VexGuestAMD64State*)gst_vanilla;
@@ -1608,6 +1637,20 @@ void putSyscallStatusIntoGuestState ( /*IN*/ ThreadId tid,
    VG_TRACK( post_reg_write, Vg_CoreSysCall, tid,
              OFFSET_mips32_r4, sizeof(UWord) );
 
+#  elif defined(VGP_loongarch64_linux)
+   VexGuestLOONGARCH64State* gst = (VexGuestLOONGARCH64State*)gst_vanilla;
+   vg_assert(canonical->what == SsComplete);
+   if (sr_isError(canonical->sres)) {
+      /* This isn't exactly right, in that really a Failure with res
+         not in the range 1 .. 4095 is unrepresentable in the
+         Linux-loongarch64 scheme.  Oh well. */
+      gst->guest_R4 = - (Long)sr_Err(canonical->sres);
+   } else {
+      gst->guest_R4 = sr_Res(canonical->sres);
+   }
+   VG_TRACK( post_reg_write, Vg_CoreSysCall, tid,
+             OFFSET_loongarch64_R4, sizeof(UWord) );
+
 #  elif defined(VGP_x86_solaris)
    VexGuestX86State* gst = (VexGuestX86State*)gst_vanilla;
    SysRes sres = canonical->sres;
@@ -1857,6 +1900,15 @@ void getSyscallArgLayout ( /*OUT*/SyscallArgLayout* layout )
    layout->s_arg7   = sizeof(UWord) * 1;
    layout->s_arg8   = sizeof(UWord) * 2;
 
+#elif defined(VGP_loongarch64_linux)
+   layout->o_sysno  = OFFSET_loongarch64_R11;
+   layout->o_arg1   = OFFSET_loongarch64_R4;
+   layout->o_arg2   = OFFSET_loongarch64_R5;
+   layout->o_arg3   = OFFSET_loongarch64_R6;
+   layout->o_arg4   = OFFSET_loongarch64_R7;
+   layout->o_arg5   = OFFSET_loongarch64_R8;
+   layout->o_arg6   = OFFSET_loongarch64_R9;
+
 #else
 #  error "getSyscallLayout: unknown arch"
 #endif
@@ -2901,6 +2953,25 @@ void ML_(fixup_guest_state_to_restart_syscall) ( ThreadArchState* arch )
          arch->vex.guest_PC -= 2;
       }
    }
+
+#elif defined(VGP_loongarch64_linux)
+   arch->vex.guest_PC -= 4;             // sizeof(loongarch instr)
+
+   /* Make sure our caller is actually sane, and we're really backing
+      back over a syscall.
+
+      syscall 0 == 00 2B 00 00
+   */
+   {
+      UChar *p = (UChar *)(Addr)(arch->vex.guest_PC);
+      if (p[0] != 0x00 || p[1] != 0x00 || p[2] != 0x2B || p[3] != 0x00)
+         VG_(message)(Vg_DebugMsg,
+                      "?! restarting over syscall at %#llx %02x %02x %02x %02x\n",
+                      (ULong)arch->vex.guest_PC, p[0], p[1], p[2], p[3]);
+
+      vg_assert(p[0] == 0x00 && p[1] == 0x00 && p[2] == 0x2B && p[3] == 0x00);
+   }
+
 #elif defined(VGP_x86_solaris)
    arch->vex.guest_EIP -= 2;   // sizeof(int $0x91) or sizeof(syscall)
 
diff --git a/coregrind/m_trampoline.S b/coregrind/m_trampoline.S
index da9697232..f02d53f08 100644
--- a/coregrind/m_trampoline.S
+++ b/coregrind/m_trampoline.S
@@ -1520,6 +1520,53 @@ VG_(trampoline_stuff_end):
 #	undef UD2_1024
 #	undef UD2_PAGE
 
+/*------------------- loongarch64-linux -------------------*/
+#else
+#if defined(VGP_loongarch64_linux)
+
+.global VG_(trampoline_stuff_start)
+VG_(trampoline_stuff_start):
+
+.global VG_(loongarch64_linux_SUBST_FOR_rt_sigreturn)
+VG_(loongarch64_linux_SUBST_FOR_rt_sigreturn):
+        li.w $a7, __NR_rt_sigreturn
+        syscall 0
+        .long 0 /*illegal insn*/
+
+/* There's no particular reason that this needs to be handwritten
+   assembly, but since that's what this file contains, here's a
+   simple strlen() and strchr() implementations.
+*/
+
+.global VG_(loongarch64_linux_REDIR_FOR_strlen)
+.type   VG_(loongarch64_linux_REDIR_FOR_strlen), @function
+VG_(loongarch64_linux_REDIR_FOR_strlen):
+      move   $t0, $a0
+   strlen_loop:
+      ld.bu  $t1, $a0, 0
+      addi.d $a0, $a0, 1
+      bne    $t1, $zero, strlen_loop
+      sub.d  $a0, $a0, $t0
+      addi.d $a0, $a0, -1
+      jr     $ra
+.size VG_(loongarch64_linux_REDIR_FOR_strlen), .-VG_(loongarch64_linux_REDIR_FOR_strlen)
+
+.global VG_(loongarch64_linux_REDIR_FOR_strchr)
+.type   VG_(loongarch64_linux_REDIR_FOR_strchr), @function
+VG_(loongarch64_linux_REDIR_FOR_strchr):
+   strchr_loop:
+      ld.bu  $t0, $a0, 0
+      beq    $t0, $a1, strchr_end
+      addi.d $a0, $a0, 1
+      bne    $t0, $zero, strchr_loop
+      move   $a0, $zero
+   strchr_end:
+      jr     $ra
+.size VG_(loongarch64_linux_REDIR_FOR_strchr), .-VG_(loongarch64_linux_REDIR_FOR_strchr)
+
+.global VG_(trampoline_stuff_end)
+VG_(trampoline_stuff_end):
+
 /*---------------- x86-solaris ----------------*/
 #else
 #if defined(VGP_x86_solaris)
@@ -1719,6 +1766,7 @@ VG_(trampoline_stuff_end):
 #endif
 #endif
 #endif
+#endif
 
 /* Let the linker know we don't need an executable stack */
 MARK_STACK_NO_EXEC
diff --git a/coregrind/m_translate.c b/coregrind/m_translate.c
index 0dd36082d..1ae200b15 100644
--- a/coregrind/m_translate.c
+++ b/coregrind/m_translate.c
@@ -1750,6 +1750,11 @@ Bool VG_(translate) ( ThreadId tid,
            vex_archinfo.arm64_requires_fallback_LLSC;
 #  endif
 
+#  if defined(VGP_loongarch64_linux)
+   /* For now, we only use fallback LLSC */
+   vex_abiinfo.guest__use_fallback_LLSC = True;
+#  endif
+
    /* Set up closure args. */
    closure.tid    = tid;
    closure.nraddr = nraddr;
diff --git a/coregrind/m_vki.c b/coregrind/m_vki.c
index 0cc1882a1..11c5fe316 100644
--- a/coregrind/m_vki.c
+++ b/coregrind/m_vki.c
@@ -37,13 +37,13 @@
    describing the kernel interface, so this file is nearly empty. */
 
 
-/* ppc32/64, arm64 and mips32/64 (linux) determine page size at startup,
-   hence m_vki is the logical place to store that info. */
+/* ppc32/64, arm64, mips32/64 and loongarch64 (linux) determine page size
+   at startup, hence m_vki is the logical place to store that info. */
 
 #if defined(VGP_ppc32_linux) || defined(VGP_ppc64be_linux) \
     || defined(VGP_ppc64le_linux) || defined(VGP_arm64_linux) \
     || defined(VGP_mips32_linux)  || defined(VGP_mips64_linux) \
-    || defined(VGP_nanomips_linux)
+    || defined(VGP_nanomips_linux) || defined(VGP_loongarch64_linux)
 unsigned long VKI_PAGE_SHIFT = 12;
 unsigned long VKI_PAGE_SIZE  = 1UL << 12;
 #endif
diff --git a/coregrind/pub_core_aspacemgr.h b/coregrind/pub_core_aspacemgr.h
index b867108a2..a2b41f374 100644
--- a/coregrind/pub_core_aspacemgr.h
+++ b/coregrind/pub_core_aspacemgr.h
@@ -335,7 +335,8 @@ extern Bool VG_(am_relocate_nooverlap_client)( /*OUT*/Bool* need_discard,
 #if defined(VGP_ppc32_linux) \
     || defined(VGP_ppc64be_linux) || defined(VGP_ppc64le_linux)	\
     || defined(VGP_mips32_linux) || defined(VGP_mips64_linux) \
-    || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+    || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+    || defined(VGP_loongarch64_linux)
 # define VG_STACK_GUARD_SZB  65536  // 1 or 16 pages
 #else
 # define VG_STACK_GUARD_SZB  8192   // 2 pages
diff --git a/coregrind/pub_core_basics.h b/coregrind/pub_core_basics.h
index abc5a066a..132545166 100644
--- a/coregrind/pub_core_basics.h
+++ b/coregrind/pub_core_basics.h
@@ -55,8 +55,8 @@
 
 typedef
    struct {
-      ULong r_pc; /* x86:EIP, amd64:RIP, ppc:CIA, arm:R15, mips:pc */
-      ULong r_sp; /* x86:ESP, amd64:RSP, ppc:R1,  arm:R13, mips:sp */
+      ULong r_pc; /* x86:EIP, amd64:RIP, ppc:CIA, arm:R15, mips:pc, loongarch64:pc */
+      ULong r_sp; /* x86:ESP, amd64:RSP, ppc:R1,  arm:R13, mips:sp, loongarch64:sp */
       union {
          struct {
             UInt r_ebp;
@@ -102,6 +102,10 @@ typedef
             ULong r31;  /* Return address of the last subroutine call */
             ULong r28;
          } MIPS64;
+         struct {
+            ULong r_fp; /* Stack frame pointer or static variable */
+            ULong r_ra; /* Return address of the last subroutine call */
+         } LOONGARCH64;
       } misc;
    }
    UnwindStartRegs;
diff --git a/coregrind/pub_core_debuginfo.h b/coregrind/pub_core_debuginfo.h
index 4d6ebda81..115afffc9 100644
--- a/coregrind/pub_core_debuginfo.h
+++ b/coregrind/pub_core_debuginfo.h
@@ -137,6 +137,10 @@ typedef
 typedef
    struct { Addr pc; Addr sp; Addr fp; Addr ra; }
    D3UnwindRegs;
+#elif defined(VGA_loongarch64)
+typedef
+   struct { Addr pc; Addr ra; Addr sp; Addr fp; }
+   D3UnwindRegs;
 #else
 #  error "Unsupported arch"
 #endif
diff --git a/coregrind/pub_core_machine.h b/coregrind/pub_core_machine.h
index a9b7dd8b1..4793d599c 100644
--- a/coregrind/pub_core_machine.h
+++ b/coregrind/pub_core_machine.h
@@ -126,6 +126,11 @@
 #  define VG_ELF_MACHINE      EM_NANOMIPS
 #  define VG_ELF_CLASS        ELFCLASS32
 #  undef  VG_PLAT_USES_PPCTOC
+#elif defined(VGP_loongarch64_linux)
+#  define VG_ELF_DATA2XXX     ELFDATA2LSB
+#  define VG_ELF_MACHINE      EM_LOONGARCH
+#  define VG_ELF_CLASS        ELFCLASS64
+#  undef  VG_PLAT_USES_PPCTOC
 #else
 #  error Unknown platform
 #endif
@@ -163,6 +168,10 @@
 #  define VG_INSTR_PTR        guest_PC
 #  define VG_STACK_PTR        guest_r29
 #  define VG_FRAME_PTR        guest_r30
+#elif defined(VGA_loongarch64)
+#  define VG_INSTR_PTR        guest_PC
+#  define VG_STACK_PTR        guest_R3
+#  define VG_FRAME_PTR        guest_R22
 #else
 #  error Unknown arch
 #endif
@@ -234,6 +243,10 @@ void VG_(get_UnwindStartRegs) ( /*OUT*/UnwindStartRegs* regs,
    s390x: initially:  call VG_(machine_get_hwcaps)
 
           then safe to use VG_(machine_get_VexArchInfo)
+   -------------
+   loongarch64: initially: call VG_(machine_get_hwcaps)
+
+          then safe to use VG_(machine_get_VexArchInfo)
 
    VG_(machine_get_hwcaps) may use signals (although it attempts to
    leave signal state unchanged) and therefore should only be
diff --git a/coregrind/pub_core_mallocfree.h b/coregrind/pub_core_mallocfree.h
index b5922ca50..d285caa1a 100644
--- a/coregrind/pub_core_mallocfree.h
+++ b/coregrind/pub_core_mallocfree.h
@@ -78,6 +78,7 @@ typedef Int ArenaId;
       defined(VGP_ppc64le_linux)  || \
       defined(VGP_s390x_linux)    || \
       (defined(VGP_mips64_linux) && !defined(VGABI_N32)) || \
+      defined(VGP_loongarch64_linux) || \
       defined(VGP_x86_freebsd)    || \
       defined(VGP_amd64_freebsd)  || \
       defined(VGP_x86_darwin)     || \
diff --git a/coregrind/pub_core_syscall.h b/coregrind/pub_core_syscall.h
index 6c4f82591..5d7ff4435 100644
--- a/coregrind/pub_core_syscall.h
+++ b/coregrind/pub_core_syscall.h
@@ -105,6 +105,7 @@ extern SysRes VG_(mk_SysRes_mips32_linux)( UWord v0, UWord v1,
 extern SysRes VG_(mk_SysRes_mips64_linux)( ULong v0, ULong v1,
                                            ULong a3 );
 extern SysRes VG_(mk_SysRes_nanomips_linux)( UWord a0);
+extern SysRes VG_(mk_SysRes_loongarch64_linux)( UWord a0 );
 extern SysRes VG_(mk_SysRes_x86_solaris) ( Bool isErr, UInt val, UInt val2 );
 extern SysRes VG_(mk_SysRes_amd64_solaris) ( Bool isErr, ULong val, ULong val2 );
 extern SysRes VG_(mk_SysRes_Error)       ( UWord val );
diff --git a/coregrind/pub_core_trampoline.h b/coregrind/pub_core_trampoline.h
index 54c575a72..3700acb1d 100644
--- a/coregrind/pub_core_trampoline.h
+++ b/coregrind/pub_core_trampoline.h
@@ -171,6 +171,12 @@ extern Char* VG_(nanomips_linux_REDIR_FOR_index)( const Char*, Int );
 extern UInt  VG_(nanomips_linux_REDIR_FOR_strlen)( void* );
 #endif
 
+#if defined(VGP_loongarch64_linux)
+extern Addr  VG_(loongarch64_linux_SUBST_FOR_rt_sigreturn);
+extern UInt  VG_(loongarch64_linux_REDIR_FOR_strlen)( void* );
+extern Char* VG_(loongarch64_linux_REDIR_FOR_strchr)( const Char*, Int );
+#endif
+
 #if defined(VGP_x86_solaris)
 extern SizeT VG_(x86_solaris_REDIR_FOR_strcmp)(const HChar *, const HChar *);
 extern SizeT VG_(x86_solaris_REDIR_FOR_strlen)(const HChar *);
diff --git a/coregrind/pub_core_transtab.h b/coregrind/pub_core_transtab.h
index 6cc11f658..fe9392626 100644
--- a/coregrind/pub_core_transtab.h
+++ b/coregrind/pub_core_transtab.h
@@ -81,7 +81,8 @@ static inline UWord VG_TT_FAST_HASH ( Addr guest ) {
 }
 
 #elif defined(VGA_ppc32) || defined(VGA_ppc64be) || defined(VGA_ppc64le) \
-      || defined(VGA_mips32) || defined(VGA_mips64) || defined(VGA_arm64)
+      || defined(VGA_mips32) || defined(VGA_mips64) || defined(VGA_arm64) \
+      || defined(VGA_loongarch64)
 static inline UWord VG_TT_FAST_HASH ( Addr guest ) {
    // Instructions are 4-byte aligned.
    UWord merged = ((UWord)guest) >> 2;
diff --git a/coregrind/pub_core_transtab_asm.h b/coregrind/pub_core_transtab_asm.h
index 8b585f17d..e73c89ae3 100644
--- a/coregrind/pub_core_transtab_asm.h
+++ b/coregrind/pub_core_transtab_asm.h
@@ -83,7 +83,7 @@
 #if defined(VGA_amd64) || defined(VGA_arm64) \
     || defined(VGA_ppc64be) || defined(VGA_ppc64le) \
     || (defined(VGA_mips64) && defined(VGABI_64)) \
-    || defined(VGA_s390x)
+    || defined(VGA_s390x) || defined(VGA_loongarch64)
   // And all other 64-bit hosts
 # define VG_FAST_CACHE_SET_BITS 6
   // These FCS_{g,h}{0,1,2,3} are the values of
diff --git a/coregrind/vgdb-invoker-ptrace.c b/coregrind/vgdb-invoker-ptrace.c
index 78a6a168c..798fe5f8e 100644
--- a/coregrind/vgdb-invoker-ptrace.c
+++ b/coregrind/vgdb-invoker-ptrace.c
@@ -50,9 +50,10 @@
 // Rather we use PTRACE_GETREGS or PTRACE_PEEKUSER.
 
 // The only platform on which we must use PTRACE_GETREGSET is arm64.
+// We use PTRACE_GETREGSET on loongarch64 as well.
 // The resulting vgdb cannot work in a bi-arch setup.
 // -1 means we will check that PTRACE_GETREGSET works.
-#  if defined(VGA_arm64)
+#  if defined(VGA_arm64) || defined(VGA_loongarch64)
 #define USE_PTRACE_GETREGSET
 #  endif
 #endif
@@ -529,6 +530,9 @@ static struct user_regs_struct user_save;
 #    else
 static struct user_pt_regs user_save;
 #    endif
+#  elif defined(VGA_loongarch64)
+/* loongarch64 is extra special, glibc only defined user_regs_struct. */
+static struct user_regs_struct user_save;
 #  else
 static struct user user_save;
 #  endif
@@ -805,6 +809,9 @@ Bool invoker_invoke_gdbserver (pid_t pid)
 #    else
    struct user_pt_regs user_mod;
 #    endif
+#  elif defined(VGA_loongarch64)
+/* loongarch64 is extra special, glibc only defined user_regs_struct. */
+   struct user_regs_struct user_mod;
 #  else
    struct user user_mod;
 #  endif
@@ -874,6 +881,8 @@ Bool invoker_invoke_gdbserver (pid_t pid)
    sp = p[29];
 #elif defined(VGA_mips64)
    sp = user_mod.regs[29];
+#elif defined(VGA_loongarch64)
+   sp = user_mod.regs[3];
 #else
    I_die_here : (sp) architecture missing in vgdb-invoker-ptrace.c
 #endif
@@ -961,6 +970,8 @@ Bool invoker_invoke_gdbserver (pid_t pid)
 
 #elif defined(VGA_mips64)
       assert(0); // cannot vgdb a 32 bits executable with a 64 bits exe
+#elif defined(VGA_loongarch64)
+      assert(0); // cannot vgdb a 32 bits executable with a 64 bits exe
 #else
       I_die_here : architecture missing in vgdb-invoker-ptrace.c
 #endif
@@ -1068,6 +1079,12 @@ Bool invoker_invoke_gdbserver (pid_t pid)
       user_mod.regs[31] = bad_return;
       user_mod.regs[34] = shared64->invoke_gdbserver;
       user_mod.regs[25] = shared64->invoke_gdbserver;
+#elif defined(VGA_loongarch64)
+      /* put check arg in register a0 */
+      user_mod.regs[4] = check;
+      /* put NULL return address in ra */
+      user_mod.regs[1] = bad_return;
+      user_mod.csr_era = shared64->invoke_gdbserver;
 #else
       I_die_here: architecture missing in vgdb-invoker-ptrace.c
 #endif
diff --git a/drd/drd_bitmap.h b/drd/drd_bitmap.h
index 3b71d749a..1f11f23c4 100644
--- a/drd/drd_bitmap.h
+++ b/drd/drd_bitmap.h
@@ -140,7 +140,7 @@ Addr make_address(const UWord a1, const UWord a0)
 #define BITS_PER_BITS_PER_UWORD 5
 #elif defined(VGA_amd64) || defined(VGA_ppc64be) || defined(VGA_ppc64le) \
       || defined(VGA_s390x) || (defined(VGA_mips64) && !defined(VGABI_N32)) \
-      || defined(VGA_arm64)
+      || defined(VGA_arm64) || defined(VGA_loongarch64)
 #define BITS_PER_BITS_PER_UWORD 6
 #else
 #error Unknown platform.
diff --git a/drd/drd_load_store.c b/drd/drd_load_store.c
index 04bb3bd0f..da6283b91 100644
--- a/drd/drd_load_store.c
+++ b/drd/drd_load_store.c
@@ -53,6 +53,8 @@
 #define STACK_POINTER_OFFSET OFFSET_mips32_r29
 #elif defined(VGA_mips64)
 #define STACK_POINTER_OFFSET OFFSET_mips64_r29
+#elif defined(VGA_loongarch64)
+#define STACK_POINTER_OFFSET OFFSET_loongarch64_R3
 #else
 #error Unknown architecture.
 #endif
diff --git a/helgrind/tests/annotate_hbefore.c b/helgrind/tests/annotate_hbefore.c
index 259d3b64c..bc11c287c 100644
--- a/helgrind/tests/annotate_hbefore.c
+++ b/helgrind/tests/annotate_hbefore.c
@@ -314,6 +314,17 @@ UWord do_acasW ( UWord* addr, UWord expected, UWord nyu )
    return success;
 }
 
+#elif defined(VGA_loongarch64)
+
+// loongarch64
+/* return 1 if success, 0 if failure */
+UWord do_acasW ( UWord* addr, UWord expected, UWord nyu )
+{
+   /* TODO */
+   assert(0);
+   return 0;
+}
+
 #endif
 
 void atomic_incW ( UWord* w )
diff --git a/helgrind/tests/tc07_hbl1.c b/helgrind/tests/tc07_hbl1.c
index 54297dee6..58f2fbc45 100644
--- a/helgrind/tests/tc07_hbl1.c
+++ b/helgrind/tests/tc07_hbl1.c
@@ -18,6 +18,7 @@
 #undef PLAT_arm64_linux
 #undef PLAT_s390x_linux
 #undef PLAT_mips32_linux
+#undef PLAT_loongarch64_linux
 #undef PLAT_x86_solaris
 #undef PLAT_amd64_solaris
 
@@ -47,6 +48,8 @@
 #  define PLAT_mips32_linux 1
 #elif defined(__linux__) && defined(__nanomips__)
 #  define PLAT_nanomips_linux 1
+#elif defined(__linux__) && defined(__loongarch__) && (__loongarch_grlen == 64)
+#  define PLAT_loongarch64_linux 1
 #elif defined(__sun__) && defined(__i386__)
 #  define PLAT_x86_solaris 1
 #elif defined(__sun__) && defined(__x86_64__)
@@ -131,6 +134,11 @@
       : /*out*/ : /*in*/ "r"(&(_lval))              \
       : /*trash*/ "$t0", "$t1", "memory"            \
    )
+#elif defined(PLAT_loongarch64_linux)
+   /* TODO */
+#include <assert.h>
+#  define INC(_lval,_lqual)                         \
+     assert(0);
 #else
 #  error "Fix Me for this platform"
 #endif
diff --git a/helgrind/tests/tc08_hbl2.c b/helgrind/tests/tc08_hbl2.c
index c3a2ec794..2758231a9 100644
--- a/helgrind/tests/tc08_hbl2.c
+++ b/helgrind/tests/tc08_hbl2.c
@@ -35,6 +35,7 @@
 #undef PLAT_s390x_linux
 #undef PLAT_mips32_linux
 #undef PLAT_mips64_linux
+#undef PLAT_loongarch64_linux
 #undef PLAT_x86_solaris
 #undef PLAT_amd64_solaris
 
@@ -68,6 +69,8 @@
 #endif
 #elif defined(__linux__) && defined(__nanomips__)
 #  define PLAT_nanomips_linux 1
+#elif defined(__linux__) && defined(__loongarch__) && (__loongarch_grlen == 64)
+#  define PLAT_loongarch64_linux 1
 #elif defined(__sun__) && defined(__i386__)
 #  define PLAT_x86_solaris 1
 #elif defined(__sun__) && defined(__x86_64__)
@@ -151,6 +154,11 @@
       : /*out*/ : /*in*/ "r"(&(_lval))              \
       : /*trash*/ "$t0", "$t1", "memory"            \
    )
+#elif defined(PLAT_loongarch64_linux)
+   /* TODO Implement. */
+#include <assert.h>
+#  define INC(_lval,_lqual)                         \
+     assert(0);
 #else
 #  error "Fix Me for this platform"
 #endif
diff --git a/helgrind/tests/tc11_XCHG.c b/helgrind/tests/tc11_XCHG.c
index 08e34a0b5..64b3d2bf3 100644
--- a/helgrind/tests/tc11_XCHG.c
+++ b/helgrind/tests/tc11_XCHG.c
@@ -20,6 +20,7 @@
 #undef PLAT_arm_linux
 #undef PLAT_s390x_linux
 #undef PLAT_mips32_linux
+#undef PLAT_loongarch64_linux
 #undef PLAT_x86_solaris
 #undef PLAT_amd64_solaris
 
@@ -49,6 +50,8 @@
 #  define PLAT_mips32_linux 1
 #elif defined(__linux__) && defined(__nanomips__)
 #  define PLAT_nanomips_linux 1
+#elif defined(__linux__) && defined(__loongarch__) && (__loongarch_grlen == 64)
+#  define PLAT_loongarch64_linux 1
 #elif defined(__sun__) && defined(__i386__)
 #  define PLAT_x86_solaris 1
 #elif defined(__sun__) && defined(__x86_64__)
@@ -146,6 +149,21 @@
 #  define XCHG_M_R_with_redundant_LOCK(_addr,_lval) \
       XCHG_M_R(_addr,_lval)
 
+#elif defined(PLAT_loongarch64_linux)
+#  define XCHG_M_R(_addr,_lval)                              \
+   __asm__ __volatile__(                                     \
+      "move $t0, %2 \n\t"                                    \
+      "ll.w $t1, %1 \n\t"                                    \
+      "sc.w $t0, %1 \n\t"                                    \
+      "move %0, $t1 \n\t"                                    \
+      : /*out*/ "=r"(_lval), "+ZC"(_addr)                    \
+      : /*in*/  "r"(_lval)                                   \
+      : "$t0", "$t1", "memory"                               \
+   )
+
+#  define XCHG_M_R_with_redundant_LOCK(_addr,_lval)          \
+      XCHG_M_R(_addr,_lval)
+
 #else
 #  error "Unsupported architecture"
 
diff --git a/include/Makefile.am b/include/Makefile.am
index 972d394b8..abfa2c915 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -63,6 +63,7 @@ nobase_pkginclude_HEADERS = \
 	vki/vki-posixtypes-mips32-linux.h \
 	vki/vki-posixtypes-mips64-linux.h \
 	vki/vki-posixtypes-nanomips-linux.h \
+	vki/vki-posixtypes-loongarch64-linux.h \
 	vki/vki-amd64-linux.h		\
 	vki/vki-arm64-linux.h		\
 	vki/vki-ppc32-linux.h		\
@@ -75,6 +76,7 @@ nobase_pkginclude_HEADERS = \
 	vki/vki-mips32-linux.h		\
 	vki/vki-mips64-linux.h		\
 	vki/vki-nanomips-linux.h	\
+	vki/vki-loongarch64-linux.h	\
 	vki/vki-scnums-amd64-linux.h	\
 	vki/vki-scnums-arm64-linux.h	\
 	vki/vki-scnums-ppc32-linux.h	\
@@ -86,6 +88,7 @@ nobase_pkginclude_HEADERS = \
 	vki/vki-scnums-mips32-linux.h	\
 	vki/vki-scnums-mips64-linux.h	\
 	vki/vki-scnums-nanomips-linux.h	\
+	vki/vki-scnums-loongarch64-linux.h \
 	vki/vki-scnums-darwin.h         \
 	vki/vki-scnums-solaris.h	\
 	vki/vki-scnums-shared-linux.h	\
diff --git a/include/pub_tool_basics.h b/include/pub_tool_basics.h
index bf5a5ba7f..da90ea726 100644
--- a/include/pub_tool_basics.h
+++ b/include/pub_tool_basics.h
@@ -437,7 +437,8 @@ static inline Bool sr_EQ ( UInt sysno, SysRes sr1, SysRes sr2 ) {
 
 #if defined(VGA_x86) || defined(VGA_amd64) || defined (VGA_arm) \
     || ((defined(VGA_mips32) || defined(VGA_mips64) || defined(VGA_nanomips)) \
-    && defined (_MIPSEL)) || defined(VGA_arm64)  || defined(VGA_ppc64le)
+    && defined (_MIPSEL)) || defined(VGA_arm64)  || defined(VGA_ppc64le) \
+    || defined (VGA_loongarch64)
 #  define VG_LITTLEENDIAN 1
 #elif defined(VGA_ppc32) || defined(VGA_ppc64be) || defined(VGA_s390x) \
       || ((defined(VGA_mips32) || defined(VGA_mips64) || defined(VGA_nanomips)) \
@@ -485,7 +486,8 @@ static inline Bool sr_EQ ( UInt sysno, SysRes sr1, SysRes sr2 ) {
       || defined(VGA_ppc64be) || defined(VGA_ppc64le) \
       || defined(VGA_arm) || defined(VGA_s390x) \
       || defined(VGA_mips32) || defined(VGA_mips64) \
-      || defined(VGA_arm64) || defined(VGA_nanomips)
+      || defined(VGA_arm64) || defined(VGA_nanomips) \
+      || defined(VGA_loongarch64)
 #  define VG_REGPARM(n)            /* */
 #else
 #  error Unknown arch
diff --git a/include/pub_tool_guest.h b/include/pub_tool_guest.h
index 08a72efac..87e8cc2bc 100644
--- a/include/pub_tool_guest.h
+++ b/include/pub_tool_guest.h
@@ -62,6 +62,9 @@
 #elif defined(VGA_mips64)
 #  include "libvex_guest_mips64.h"
    typedef VexGuestMIPS64State VexGuestArchState;
+#elif defined(VGA_loongarch64)
+#  include "libvex_guest_loongarch64.h"
+   typedef VexGuestLOONGARCH64State VexGuestArchState;
 #else
 #  error Unknown arch
 #endif
diff --git a/include/pub_tool_libcsetjmp.h b/include/pub_tool_libcsetjmp.h
index ee9e1dc8b..f4e447733 100644
--- a/include/pub_tool_libcsetjmp.h
+++ b/include/pub_tool_libcsetjmp.h
@@ -142,6 +142,14 @@ UWord VG_MINIMAL_SETJMP(VG_MINIMAL_JMP_BUF(_env));
 __attribute__((noreturn))
 void VG_MINIMAL_LONGJMP(VG_MINIMAL_JMP_BUF(_env));
 
+#elif defined(VGP_loongarch64_linux)
+
+#define VG_MINIMAL_JMP_BUF(_name)        ULong _name [13+8+1]
+__attribute__((returns_twice))
+UWord VG_MINIMAL_SETJMP(VG_MINIMAL_JMP_BUF(_env));
+__attribute__((noreturn))
+void  VG_MINIMAL_LONGJMP(VG_MINIMAL_JMP_BUF(_env));
+
 #else
 
 /* The default implementation. */
diff --git a/include/pub_tool_machine.h b/include/pub_tool_machine.h
index 9bdd4f514..12377f97a 100644
--- a/include/pub_tool_machine.h
+++ b/include/pub_tool_machine.h
@@ -108,6 +108,12 @@
 #  define VG_CLREQ_SZB             20
 #  define VG_STACK_REDZONE_SZB      0
 
+#elif defined(VGP_loongarch64_linux)
+#  define VG_MIN_INSTR_SZB          4
+#  define VG_MAX_INSTR_SZB          8
+#  define VG_CLREQ_SZB             20
+#  define VG_STACK_REDZONE_SZB      0
+
 #else
 #  error Unknown platform
 #endif
diff --git a/include/pub_tool_redir.h b/include/pub_tool_redir.h
index f88d3b571..d1bb8cbce 100644
--- a/include/pub_tool_redir.h
+++ b/include/pub_tool_redir.h
@@ -321,6 +321,8 @@
 
 #define  VG_U_LD_LINUX_MIPSN8_S0_1  "ld-linux-mipsn8.so.1"
 
+#define  VG_U_LD_LINUX_LOONGARCH_LP64D_SO_1 "ld-linux-loongarch-lp64d.so.1"
+
 #endif
 
 /* --- Sonames for FreeBSD ELF linkers, plus unencoded versions. --- */
diff --git a/include/pub_tool_vkiscnums_asm.h b/include/pub_tool_vkiscnums_asm.h
index 3d1545999..3f210a0e3 100644
--- a/include/pub_tool_vkiscnums_asm.h
+++ b/include/pub_tool_vkiscnums_asm.h
@@ -75,6 +75,10 @@
 #  include "vki/vki-scnums-shared-linux.h"
 #  include "vki/vki-scnums-mips64-linux.h"
 
+#elif defined(VGP_loongarch64_linux)
+#  include "vki/vki-scnums-shared-linux.h"
+#  include "vki/vki-scnums-loongarch64-linux.h"
+
 #elif defined(VGP_x86_freebsd) || defined(VGP_amd64_freebsd)
 #  include "vki/vki-scnums-freebsd.h"
 
diff --git a/include/valgrind.h.in b/include/valgrind.h.in
index 45f6522f3..3e1967af5 100644
--- a/include/valgrind.h.in
+++ b/include/valgrind.h.in
@@ -125,6 +125,7 @@
 #undef PLAT_mips32_linux
 #undef PLAT_mips64_linux
 #undef PLAT_nanomips_linux
+#undef PLAT_loongarch64_linux
 #undef PLAT_x86_solaris
 #undef PLAT_amd64_solaris
 
@@ -169,6 +170,8 @@
 #  define PLAT_mips32_linux 1
 #elif defined(__linux__) && defined(__nanomips__)
 #  define PLAT_nanomips_linux 1
+#elif defined(__linux__) && defined(__loongarch__) && (__loongarch_grlen == 64)
+#  define PLAT_loongarch64_linux 1
 #elif defined(__sun) && defined(__i386__)
 #  define PLAT_x86_solaris 1
 #elif defined(__sun) && defined(__x86_64__)
@@ -1125,7 +1128,75 @@ typedef
                     );                                              \
  } while (0)
 
-#endif
+#endif /* PLAT_nanomips_linux */
+
+/* --------------------- loongarch64-linux --------------------- */
+#if defined(PLAT_loongarch64_linux)
+
+typedef
+   struct {
+      unsigned long nraddr; /* where's the code? */
+   }
+   OrigFn;
+
+#define __SPECIAL_INSTRUCTION_PREAMBLE                              \
+                       "srli.d $zero, $zero, 3  \n\t"               \
+                       "srli.d $zero, $zero, 13 \n\t"               \
+                       "srli.d $zero, $zero, 29 \n\t"               \
+                       "srli.d $zero, $zero, 19 \n\t"
+
+#define VALGRIND_DO_CLIENT_REQUEST_EXPR(                            \
+        _zzq_default, _zzq_request,                                 \
+        _zzq_arg1, _zzq_arg2, _zzq_arg3, _zzq_arg4, _zzq_arg5)      \
+   __extension__                                                    \
+   ({                                                               \
+      volatile unsigned long int _zzq_args[6];                      \
+      volatile unsigned long int _zzq_result;                       \
+      _zzq_args[0] = (unsigned long int)(_zzq_request);             \
+      _zzq_args[1] = (unsigned long int)(_zzq_arg1);                \
+      _zzq_args[2] = (unsigned long int)(_zzq_arg2);                \
+      _zzq_args[3] = (unsigned long int)(_zzq_arg3);                \
+      _zzq_args[4] = (unsigned long int)(_zzq_arg4);                \
+      _zzq_args[5] = (unsigned long int)(_zzq_arg5);                \
+      __asm__ volatile("move $a7, %1     \n\t" /*default*/          \
+                       "move $t0, %2     \n\t" /*ptr*/              \
+                       __SPECIAL_INSTRUCTION_PREAMBLE               \
+                       /* $a7 = client_request ( $t0 ) */           \
+                       "or $t1, $t1, $t1 \n\t"                      \
+                       "move %0, $a7     \n\t" /*result*/           \
+                       : "=r" (_zzq_result)                         \
+                       : "r" (_zzq_default), "r" (&_zzq_args[0])    \
+                       : "$a7", "$t0", "memory");                   \
+      _zzq_result;                                                  \
+   })
+
+#define VALGRIND_GET_NR_CONTEXT(_zzq_rlval)                         \
+   {                                                                \
+      volatile OrigFn* _zzq_orig = &(_zzq_rlval);                   \
+      volatile unsigned long int __addr;                            \
+      __asm__ volatile(__SPECIAL_INSTRUCTION_PREAMBLE               \
+                       /* $a7 = guest_NRADDR */                     \
+                       "or $t2, $t2, $t2 \n\t"                      \
+                       "move %0, $a7     \n\t" /*result*/           \
+                       : "=r" (__addr)                              \
+                       :                                            \
+                       : "$a7");                                    \
+      _zzq_orig->nraddr = __addr;                                   \
+   }
+
+#define VALGRIND_CALL_NOREDIR_T8                                    \
+                       __SPECIAL_INSTRUCTION_PREAMBLE               \
+                       /* call-noredir $t8 */                       \
+                       "or $t3, $t3, $t3 \n\t"
+
+#define VALGRIND_VEX_INJECT_IR()                                    \
+   do {                                                             \
+      __asm__ volatile(__SPECIAL_INSTRUCTION_PREAMBLE               \
+                       "or $t4, $t4, $t4 \n\t"                      \
+                      );                                            \
+   } while (0)
+
+#endif /* PLAT_loongarch64_linux */
 /* Insert assembly code for other platforms here... */
 
 #endif /* NVALGRIND */
@@ -6603,6 +6674,457 @@ typedef
 
 #endif /* PLAT_mips64_linux */
 
+/* --------------------- loongarch64-linux --------------------- */
+
+#if defined(PLAT_loongarch64_linux)
+
+/* These regs are trashed by the hidden call. */
+#define __CALLER_SAVED_REGS                                        \
+   "$ra", "$a0", "$a1", "$a2", "$a3", "$a4", "$a5", "$a6", "$a7",  \
+   "$t0", "$t1", "$t2", "$t3", "$t4", "$t5", "$t6", "$t7", "$t8",  \
+   "$f0",  "$f1",  "$f2",  "$f3",  "$f4",  "$f5",  "$f6",  "$f7",  \
+   "$f8",  "$f9",  "$f10", "$f11", "$f12", "$f13", "$f14", "$f15", \
+   "$f16", "$f17", "$f18", "$f19", "$f20", "$f21", "$f22", "$f23"
+
+/* $s0 is callee-saved, so we can use it to save and restore SP around
+   the hidden call. */
+#define VALGRIND_ALIGN_STACK            \
+      "move      $s0, $sp         \n\t" \
+      "bstrins.d $sp, $zero, 3, 0 \n\t"
+#define VALGRIND_RESTORE_STACK          \
+      "move      $sp, $s0         \n\t"
+
+/* These CALL_FN_ macros assume that on loongarch64-linux,
+   sizeof(unsigned long) == 8. */
+
+#define CALL_FN_W_v(lval, orig)                                   \
+   do {                                                           \
+      volatile OrigFn        _orig = (orig);                      \
+      volatile unsigned long _argvec[1];                          \
+      volatile unsigned long _res;                                \
+      _argvec[0] = (unsigned long)_orig.nraddr;                   \
+      __asm__ volatile(                                           \
+         VALGRIND_ALIGN_STACK                                     \
+         "ld.d $t8, %1, 0 \n\t"  /* target->t8 */                 \
+         VALGRIND_CALL_NOREDIR_T8                                 \
+         VALGRIND_RESTORE_STACK                                   \
+         "move %0, $a0    \n\t"                                   \
+         : /*out*/   "=r" (_res)                                  \
+         : /*in*/    "r" (&_argvec[0])                            \
+         : /*trash*/ "memory", __CALLER_SAVED_REGS, "$s0"         \
+      );                                                          \
+      lval = (__typeof__(lval)) _res;                             \
+   } while (0)
+
+#define CALL_FN_W_W(lval, orig, arg1)                             \
+   do {                                                           \
+      volatile OrigFn        _orig = (orig);                      \
+      volatile unsigned long _argvec[2];                          \
+      volatile unsigned long _res;                                \
+      _argvec[0] = (unsigned long)_orig.nraddr;                   \
+      _argvec[1] = (unsigned long)(arg1);                         \
+      __asm__ volatile(                                           \
+         VALGRIND_ALIGN_STACK                                     \
+         "ld.d $a0, %1, 8 \n\t"  /* arg1 */                       \
+         "ld.d $t8, %1, 0 \n\t"  /* target->t8 */                 \
+         VALGRIND_CALL_NOREDIR_T8                                 \
+         VALGRIND_RESTORE_STACK                                   \
+         "move %0, $a0    \n\t"                                   \
+         : /*out*/   "=r" (_res)                                  \
+         : /*in*/    "r" (&_argvec[0])                            \
+         : /*trash*/ "memory", __CALLER_SAVED_REGS, "$s0"         \
+      );                                                          \
+      lval = (__typeof__(lval)) _res;                             \
+   } while (0)
+
+#define CALL_FN_W_WW(lval, orig, arg1, arg2)                      \
+   do {                                                           \
+      volatile OrigFn        _orig = (orig);                      \
+      volatile unsigned long _argvec[3];                          \
+      volatile unsigned long _res;                                \
+      _argvec[0] = (unsigned long)_orig.nraddr;                   \
+      _argvec[1] = (unsigned long)(arg1);                         \
+      _argvec[2] = (unsigned long)(arg2);                         \
+      __asm__ volatile(                                           \
+         VALGRIND_ALIGN_STACK                                     \
+         "ld.d $a0, %1, 8  \n\t"  /* arg1 */                      \
+         "ld.d $a1, %1, 16 \n\t"  /* arg2 */                      \
+         "ld.d $t8, %1, 0  \n\t"  /* target->t8 */                \
+         VALGRIND_CALL_NOREDIR_T8                                 \
+         VALGRIND_RESTORE_STACK                                   \
+         "move %0, $a0     \n\t"                                  \
+         : /*out*/   "=r" (_res)                                  \
+         : /*in*/    "r" (&_argvec[0])                            \
+         : /*trash*/ "memory", __CALLER_SAVED_REGS, "$s0"         \
+      );                                                          \
+      lval = (__typeof__(lval)) _res;                             \
+   } while (0)
+
+#define CALL_FN_W_WWW(lval, orig, arg1, arg2, arg3)               \
+   do {                                                           \
+      volatile OrigFn        _orig = (orig);                      \
+      volatile unsigned long _argvec[4];                          \
+      volatile unsigned long _res;                                \
+      _argvec[0] = (unsigned long)_orig.nraddr;                   \
+      _argvec[1] = (unsigned long)(arg1);                         \
+      _argvec[2] = (unsigned long)(arg2);                         \
+      _argvec[3] = (unsigned long)(arg3);                         \
+      __asm__ volatile(                                           \
+         VALGRIND_ALIGN_STACK                                     \
+         "ld.d $a0, %1, 8  \n\t"  /* arg1 */                      \
+         "ld.d $a1, %1, 16 \n\t"  /* arg2 */                      \
+         "ld.d $a2, %1, 24 \n\t"  /* arg3 */                      \
+         "ld.d $t8, %1, 0  \n\t"  /* target->t8 */                \
+         VALGRIND_CALL_NOREDIR_T8                                 \
+         VALGRIND_RESTORE_STACK                                   \
+         "move %0, $a0     \n\t"                                  \
+         : /*out*/   "=r" (_res)                                  \
+         : /*in*/    "r" (&_argvec[0])                            \
+         : /*trash*/ "memory", __CALLER_SAVED_REGS, "$s0"         \
+      );                                                          \
+      lval = (__typeof__(lval)) _res;                             \
+   } while (0)
+
+#define CALL_FN_W_WWWW(lval, orig, arg1, arg2, arg3, arg4)        \
+   do {                                                           \
+      volatile OrigFn        _orig = (orig);                      \
+      volatile unsigned long _argvec[5];                          \
+      volatile unsigned long _res;                                \
+      _argvec[0] = (unsigned long)_orig.nraddr;                   \
+      _argvec[1] = (unsigned long)(arg1);                         \
+      _argvec[2] = (unsigned long)(arg2);                         \
+      _argvec[3] = (unsigned long)(arg3);                         \
+      _argvec[4] = (unsigned long)(arg4);                         \
+      __asm__ volatile(                                           \
+         VALGRIND_ALIGN_STACK                                     \
+         "ld.d $a0, %1, 8  \n\t"  /* arg1 */                      \
+         "ld.d $a1, %1, 16 \n\t"  /* arg2 */                      \
+         "ld.d $a2, %1, 24 \n\t"  /* arg3 */                      \
+         "ld.d $a3, %1, 32 \n\t"  /* arg4 */                      \
+         "ld.d $t8, %1, 0  \n\t"  /* target->t8 */                \
+         VALGRIND_CALL_NOREDIR_T8                                 \
+         VALGRIND_RESTORE_STACK                                   \
+         "move %0, $a0     \n\t"                                  \
+         : /*out*/   "=r" (_res)                                  \
+         : /*in*/    "r" (&_argvec[0])                            \
+         : /*trash*/ "memory", __CALLER_SAVED_REGS, "$s0"         \
+      );                                                          \
+      lval = (__typeof__(lval)) _res;                             \
+   } while (0)
+
+#define CALL_FN_W_5W(lval, orig, arg1, arg2, arg3, arg4, arg5)    \
+   do {                                                           \
+      volatile OrigFn        _orig = (orig);                      \
+      volatile unsigned long _argvec[6];                          \
+      volatile unsigned long _res;                                \
+      _argvec[0] = (unsigned long)_orig.nraddr;                   \
+      _argvec[1] = (unsigned long)(arg1);                         \
+      _argvec[2] = (unsigned long)(arg2);                         \
+      _argvec[3] = (unsigned long)(arg3);                         \
+      _argvec[4] = (unsigned long)(arg4);                         \
+      _argvec[5] = (unsigned long)(arg5);                         \
+      __asm__ volatile(                                           \
+         VALGRIND_ALIGN_STACK                                     \
+         "ld.d $a0, %1, 8  \n\t"  /* arg1 */                      \
+         "ld.d $a1, %1, 16 \n\t"  /* arg2 */                      \
+         "ld.d $a2, %1, 24 \n\t"  /* arg3 */                      \
+         "ld.d $a3, %1, 32 \n\t"  /* arg4 */                      \
+         "ld.d $a4, %1, 40 \n\t"  /* arg5 */                      \
+         "ld.d $t8, %1, 0  \n\t"  /* target->t8 */                \
+         VALGRIND_CALL_NOREDIR_T8                                 \
+         VALGRIND_RESTORE_STACK                                   \
+         "move %0, $a0     \n\t"                                  \
+         : /*out*/   "=r" (_res)                                  \
+         : /*in*/    "r" (&_argvec[0])                            \
+         : /*trash*/ "memory", __CALLER_SAVED_REGS, "$s0"         \
+      );                                                          \
+      lval = (__typeof__(lval)) _res;                             \
+   } while (0)
+
+#define CALL_FN_W_6W(lval, orig, arg1, arg2, arg3, arg4, arg5,    \
+                                 arg6)                            \
+   do {                                                           \
+      volatile OrigFn        _orig = (orig);                      \
+      volatile unsigned long _argvec[7];                          \
+      volatile unsigned long _res;                                \
+      _argvec[0] = (unsigned long)_orig.nraddr;                   \
+      _argvec[1] = (unsigned long)(arg1);                         \
+      _argvec[2] = (unsigned long)(arg2);                         \
+      _argvec[3] = (unsigned long)(arg3);                         \
+      _argvec[4] = (unsigned long)(arg4);                         \
+      _argvec[5] = (unsigned long)(arg5);                         \
+      _argvec[6] = (unsigned long)(arg6);                         \
+      __asm__ volatile(                                           \
+         VALGRIND_ALIGN_STACK                                     \
+         "ld.d $a0, %1, 8  \n\t"  /* arg1 */                      \
+         "ld.d $a1, %1, 16 \n\t"  /* arg2 */                      \
+         "ld.d $a2, %1, 24 \n\t"  /* arg3 */                      \
+         "ld.d $a3, %1, 32 \n\t"  /* arg4 */                      \
+         "ld.d $a4, %1, 40 \n\t"  /* arg5 */                      \
+         "ld.d $a5, %1, 48 \n\t"  /* arg6 */                      \
+         "ld.d $t8, %1, 0  \n\t"  /* target->t8 */                \
+         VALGRIND_CALL_NOREDIR_T8                                 \
+         VALGRIND_RESTORE_STACK                                   \
+         "move %0, $a0     \n\t"                                  \
+         : /*out*/   "=r" (_res)                                  \
+         : /*in*/    "r" (&_argvec[0])                            \
+         : /*trash*/ "memory", __CALLER_SAVED_REGS, "$s0"         \
+      );                                                          \
+      lval = (__typeof__(lval)) _res;                             \
+   } while (0)
+
+#define CALL_FN_W_7W(lval, orig, arg1, arg2, arg3, arg4, arg5,    \
+                                 arg6, arg7)                      \
+   do {                                                           \
+      volatile OrigFn        _orig = (orig);                      \
+      volatile unsigned long _argvec[8];                          \
+      volatile unsigned long _res;                                \
+      _argvec[0] = (unsigned long)_orig.nraddr;                   \
+      _argvec[1] = (unsigned long)(arg1);                         \
+      _argvec[2] = (unsigned long)(arg2);                         \
+      _argvec[3] = (unsigned long)(arg3);                         \
+      _argvec[4] = (unsigned long)(arg4);                         \
+      _argvec[5] = (unsigned long)(arg5);                         \
+      _argvec[6] = (unsigned long)(arg6);                         \
+      _argvec[7] = (unsigned long)(arg7);                         \
+      __asm__ volatile(                                           \
+         VALGRIND_ALIGN_STACK                                     \
+         "ld.d $a0, %1, 8  \n\t"  /* arg1 */                      \
+         "ld.d $a1, %1, 16 \n\t"  /* arg2 */                      \
+         "ld.d $a2, %1, 24 \n\t"  /* arg3 */                      \
+         "ld.d $a3, %1, 32 \n\t"  /* arg4 */                      \
+         "ld.d $a4, %1, 40 \n\t"  /* arg5 */                      \
+         "ld.d $a5, %1, 48 \n\t"  /* arg6 */                      \
+         "ld.d $a6, %1, 56 \n\t"  /* arg7 */                      \
+         "ld.d $t8, %1, 0  \n\t"  /* target->t8 */                \
+         VALGRIND_CALL_NOREDIR_T8                                 \
+         VALGRIND_RESTORE_STACK                                   \
+         "move %0, $a0     \n\t"                                  \
+         : /*out*/   "=r" (_res)                                  \
+         : /*in*/    "r" (&_argvec[0])                            \
+         : /*trash*/ "memory", __CALLER_SAVED_REGS, "$s0"         \
+      );                                                          \
+      lval = (__typeof__(lval)) _res;                             \
+   } while (0)
+
+#define CALL_FN_W_8W(lval, orig, arg1, arg2, arg3, arg4, arg5,    \
+                                 arg6, arg7, arg8)                \
+   do {                                                           \
+      volatile OrigFn        _orig = (orig);                      \
+      volatile unsigned long _argvec[9];                          \
+      volatile unsigned long _res;                                \
+      _argvec[0] = (unsigned long)_orig.nraddr;                   \
+      _argvec[1] = (unsigned long)(arg1);                         \
+      _argvec[2] = (unsigned long)(arg2);                         \
+      _argvec[3] = (unsigned long)(arg3);                         \
+      _argvec[4] = (unsigned long)(arg4);                         \
+      _argvec[5] = (unsigned long)(arg5);                         \
+      _argvec[6] = (unsigned long)(arg6);                         \
+      _argvec[7] = (unsigned long)(arg7);                         \
+      _argvec[8] = (unsigned long)(arg8);                         \
+      __asm__ volatile(                                           \
+         VALGRIND_ALIGN_STACK                                     \
+         "ld.d $a0, %1, 8  \n\t"  /* arg1 */                      \
+         "ld.d $a1, %1, 16 \n\t"  /* arg2 */                      \
+         "ld.d $a2, %1, 24 \n\t"  /* arg3 */                      \
+         "ld.d $a3, %1, 32 \n\t"  /* arg4 */                      \
+         "ld.d $a4, %1, 40 \n\t"  /* arg5 */                      \
+         "ld.d $a5, %1, 48 \n\t"  /* arg6 */                      \
+         "ld.d $a6, %1, 56 \n\t"  /* arg7 */                      \
+         "ld.d $a7, %1, 64 \n\t"  /* arg8 */                      \
+         "ld.d $t8, %1, 0  \n\t"  /* target->t8 */                \
+         VALGRIND_CALL_NOREDIR_T8                                 \
+         VALGRIND_RESTORE_STACK                                   \
+         "move %0, $a0     \n\t"                                  \
+         : /*out*/   "=r" (_res)                                  \
+         : /*in*/    "r" (&_argvec[0])                            \
+         : /*trash*/ "memory", __CALLER_SAVED_REGS, "$s0"         \
+      );                                                          \
+      lval = (__typeof__(lval)) _res;                             \
+   } while (0)
+
+#define CALL_FN_W_9W(lval, orig, arg1, arg2, arg3, arg4, arg5,    \
+                                 arg6, arg7, arg8, arg9)          \
+   do {                                                           \
+      volatile OrigFn        _orig = (orig);                      \
+      volatile unsigned long _argvec[10];                         \
+      volatile unsigned long _res;                                \
+      _argvec[0] = (unsigned long)_orig.nraddr;                   \
+      _argvec[1] = (unsigned long)(arg1);                         \
+      _argvec[2] = (unsigned long)(arg2);                         \
+      _argvec[3] = (unsigned long)(arg3);                         \
+      _argvec[4] = (unsigned long)(arg4);                         \
+      _argvec[5] = (unsigned long)(arg5);                         \
+      _argvec[6] = (unsigned long)(arg6);                         \
+      _argvec[7] = (unsigned long)(arg7);                         \
+      _argvec[8] = (unsigned long)(arg8);                         \
+      _argvec[9] = (unsigned long)(arg9);                         \
+      __asm__ volatile(                                           \
+         VALGRIND_ALIGN_STACK                                     \
+         "addi.d $sp, $sp, -8 \n\t"                               \
+         "ld.d   $a0, %1, 72  \n\t"                               \
+         "st.d   $a0, $sp, 0  \n\t"  /* arg9 */                   \
+         "ld.d   $a0, %1, 8   \n\t"  /* arg1 */                   \
+         "ld.d   $a1, %1, 16  \n\t"  /* arg2 */                   \
+         "ld.d   $a2, %1, 24  \n\t"  /* arg3 */                   \
+         "ld.d   $a3, %1, 32  \n\t"  /* arg4 */                   \
+         "ld.d   $a4, %1, 40  \n\t"  /* arg5 */                   \
+         "ld.d   $a5, %1, 48  \n\t"  /* arg6 */                   \
+         "ld.d   $a6, %1, 56  \n\t"  /* arg7 */                   \
+         "ld.d   $a7, %1, 64  \n\t"  /* arg8 */                   \
+         "ld.d   $t8, %1, 0   \n\t"  /* target->t8 */             \
+         VALGRIND_CALL_NOREDIR_T8                                 \
+         VALGRIND_RESTORE_STACK                                   \
+         "move %0, $a0     \n\t"                                  \
+         : /*out*/   "=r" (_res)                                  \
+         : /*in*/    "r" (&_argvec[0])                            \
+         : /*trash*/ "memory", __CALLER_SAVED_REGS, "$s0"         \
+      );                                                          \
+      lval = (__typeof__(lval)) _res;                             \
+   } while (0)
+
+#define CALL_FN_W_10W(lval, orig, arg1, arg2, arg3, arg4, arg5,   \
+                                  arg6, arg7, arg8, arg9, arg10)  \
+   do {                                                           \
+      volatile OrigFn        _orig = (orig);                      \
+      volatile unsigned long _argvec[11];                         \
+      volatile unsigned long _res;                                \
+      _argvec[0] = (unsigned long)_orig.nraddr;                   \
+      _argvec[1] = (unsigned long)(arg1);                         \
+      _argvec[2] = (unsigned long)(arg2);                         \
+      _argvec[3] = (unsigned long)(arg3);                         \
+      _argvec[4] = (unsigned long)(arg4);                         \
+      _argvec[5] = (unsigned long)(arg5);                         \
+      _argvec[6] = (unsigned long)(arg6);                         \
+      _argvec[7] = (unsigned long)(arg7);                         \
+      _argvec[8] = (unsigned long)(arg8);                         \
+      _argvec[9] = (unsigned long)(arg9);                         \
+      _argvec[10] = (unsigned long)(arg10);                       \
+      __asm__ volatile(                                           \
+         VALGRIND_ALIGN_STACK                                     \
+         "addi.d $sp, $sp, -16 \n\t"                              \
+         "ld.d   $a0, %1, 72   \n\t"                              \
+         "st.d   $a0, $sp, 0   \n\t"  /* arg9 */                  \
+         "ld.d   $a0, %1, 80   \n\t"                              \
+         "st.d   $a0, $sp, 8   \n\t"  /* arg10 */                 \
+         "ld.d   $a0, %1, 8    \n\t"  /* arg1 */                  \
+         "ld.d   $a1, %1, 16   \n\t"  /* arg2 */                  \
+         "ld.d   $a2, %1, 24   \n\t"  /* arg3 */                  \
+         "ld.d   $a3, %1, 32   \n\t"  /* arg4 */                  \
+         "ld.d   $a4, %1, 40   \n\t"  /* arg5 */                  \
+         "ld.d   $a5, %1, 48   \n\t"  /* arg6 */                  \
+         "ld.d   $a6, %1, 56   \n\t"  /* arg7 */                  \
+         "ld.d   $a7, %1, 64   \n\t"  /* arg8 */                  \
+         "ld.d   $t8, %1, 0    \n\t"  /* target->t8 */            \
+         VALGRIND_CALL_NOREDIR_T8                                 \
+         VALGRIND_RESTORE_STACK                                   \
+         "move %0, $a0     \n\t"                                  \
+         : /*out*/   "=r" (_res)                                  \
+         : /*in*/    "r" (&_argvec[0])                            \
+         : /*trash*/ "memory", __CALLER_SAVED_REGS, "$s0"         \
+      );                                                          \
+      lval = (__typeof__(lval)) _res;                             \
+   } while (0)
+
+#define CALL_FN_W_11W(lval, orig, arg1, arg2, arg3, arg4, arg5,   \
+                                  arg6, arg7, arg8, arg9, arg10,  \
+                                  arg11)                          \
+   do {                                                           \
+      volatile OrigFn        _orig = (orig);                      \
+      volatile unsigned long _argvec[12];                         \
+      volatile unsigned long _res;                                \
+      _argvec[0] = (unsigned long)_orig.nraddr;                   \
+      _argvec[1] = (unsigned long)(arg1);                         \
+      _argvec[2] = (unsigned long)(arg2);                         \
+      _argvec[3] = (unsigned long)(arg3);                         \
+      _argvec[4] = (unsigned long)(arg4);                         \
+      _argvec[5] = (unsigned long)(arg5);                         \
+      _argvec[6] = (unsigned long)(arg6);                         \
+      _argvec[7] = (unsigned long)(arg7);                         \
+      _argvec[8] = (unsigned long)(arg8);                         \
+      _argvec[9] = (unsigned long)(arg9);                         \
+      _argvec[10] = (unsigned long)(arg10);                       \
+      _argvec[11] = (unsigned long)(arg11);                       \
+      __asm__ volatile(                                           \
+         VALGRIND_ALIGN_STACK                                     \
+         "addi.d $sp, $sp, -24 \n\t"                              \
+         "ld.d   $a0, %1, 72   \n\t"                              \
+         "st.d   $a0, $sp, 0   \n\t"  /* arg9 */                  \
+         "ld.d   $a0, %1, 80   \n\t"                              \
+         "st.d   $a0, $sp, 8   \n\t"  /* arg10 */                 \
+         "ld.d   $a0, %1, 88   \n\t"                              \
+         "st.d   $a0, $sp, 16  \n\t"  /* arg11 */                 \
+         "ld.d   $a0, %1, 8    \n\t"  /* arg1 */                  \
+         "ld.d   $a1, %1, 16   \n\t"  /* arg2 */                  \
+         "ld.d   $a2, %1, 24   \n\t"  /* arg3 */                  \
+         "ld.d   $a3, %1, 32   \n\t"  /* arg4 */                  \
+         "ld.d   $a4, %1, 40   \n\t"  /* arg5 */                  \
+         "ld.d   $a5, %1, 48   \n\t"  /* arg6 */                  \
+         "ld.d   $a6, %1, 56   \n\t"  /* arg7 */                  \
+         "ld.d   $a7, %1, 64   \n\t"  /* arg8 */                  \
+         "ld.d   $t8, %1, 0    \n\t"  /* target->t8 */            \
+         VALGRIND_CALL_NOREDIR_T8                                 \
+         VALGRIND_RESTORE_STACK                                   \
+         "move %0, $a0     \n\t"                                  \
+         : /*out*/   "=r" (_res)                                  \
+         : /*in*/    "r" (&_argvec[0])                            \
+         : /*trash*/ "memory", __CALLER_SAVED_REGS, "$s0"         \
+      );                                                          \
+      lval = (__typeof__(lval)) _res;                             \
+   } while (0)
+
+#define CALL_FN_W_12W(lval, orig, arg1, arg2, arg3, arg4, arg5,   \
+                                  arg6, arg7, arg8, arg9, arg10,  \
+                                  arg11, arg12)                   \
+   do {                                                           \
+      volatile OrigFn        _orig = (orig);                      \
+      volatile unsigned long _argvec[13];                         \
+      volatile unsigned long _res;                                \
+      _argvec[0] = (unsigned long)_orig.nraddr;                   \
+      _argvec[1] = (unsigned long)(arg1);                         \
+      _argvec[2] = (unsigned long)(arg2);                         \
+      _argvec[3] = (unsigned long)(arg3);                         \
+      _argvec[4] = (unsigned long)(arg4);                         \
+      _argvec[5] = (unsigned long)(arg5);                         \
+      _argvec[6] = (unsigned long)(arg6);                         \
+      _argvec[7] = (unsigned long)(arg7);                         \
+      _argvec[8] = (unsigned long)(arg8);                         \
+      _argvec[9] = (unsigned long)(arg9);                         \
+      _argvec[10] = (unsigned long)(arg10);                       \
+      _argvec[11] = (unsigned long)(arg11);                       \
+      _argvec[12] = (unsigned long)(arg12);                       \
+      __asm__ volatile(                                           \
+         VALGRIND_ALIGN_STACK                                     \
+         "addi.d $sp, $sp, -32 \n\t"                              \
+         "ld.d   $a0, %1, 72   \n\t"                              \
+         "st.d   $a0, $sp, 0   \n\t"  /* arg9 */                  \
+         "ld.d   $a0, %1, 80   \n\t"                              \
+         "st.d   $a0, $sp, 8   \n\t"  /* arg10 */                 \
+         "ld.d   $a0, %1, 88   \n\t"                              \
+         "st.d   $a0, $sp, 16  \n\t"  /* arg11 */                 \
+         "ld.d   $a0, %1, 96   \n\t"                              \
+         "st.d   $a0, $sp, 24  \n\t"  /* arg12 */                 \
+         "ld.d   $a0, %1, 8    \n\t"  /* arg1 */                  \
+         "ld.d   $a1, %1, 16   \n\t"  /* arg2 */                  \
+         "ld.d   $a2, %1, 24   \n\t"  /* arg3 */                  \
+         "ld.d   $a3, %1, 32   \n\t"  /* arg4 */                  \
+         "ld.d   $a4, %1, 40   \n\t"  /* arg5 */                  \
+         "ld.d   $a5, %1, 48   \n\t"  /* arg6 */                  \
+         "ld.d   $a6, %1, 56   \n\t"  /* arg7 */                  \
+         "ld.d   $a7, %1, 64   \n\t"  /* arg8 */                  \
+         "ld.d   $t8, %1, 0    \n\t"  /* target->t8 */            \
+         VALGRIND_CALL_NOREDIR_T8                                 \
+         VALGRIND_RESTORE_STACK                                   \
+         "move %0, $a0     \n\t"                                  \
+         : /*out*/   "=r" (_res)                                  \
+         : /*in*/    "r" (&_argvec[0])                            \
+         : /*trash*/ "memory", __CALLER_SAVED_REGS, "$s0"         \
+      );                                                          \
+      lval = (__typeof__(lval)) _res;                             \
+   } while (0)
+
+#endif /* PLAT_loongarch64_linux */
+
 /* ------------------------------------------------------------------ */
 /* ARCHITECTURE INDEPENDENT MACROS for CLIENT REQUESTS.               */
 /*                                                                    */
@@ -7159,6 +7681,7 @@ VALGRIND_PRINTF_BACKTRACE(const char *format, ...)
 #undef PLAT_mips32_linux
 #undef PLAT_mips64_linux
 #undef PLAT_nanomips_linux
+#undef PLAT_loongarch64_linux
 #undef PLAT_x86_solaris
 #undef PLAT_amd64_solaris
 
diff --git a/include/vki/vki-linux.h b/include/vki/vki-linux.h
index 443180f3b..0a60c0a09 100644
--- a/include/vki/vki-linux.h
+++ b/include/vki/vki-linux.h
@@ -97,6 +97,8 @@
 #  include "vki-posixtypes-mips64-linux.h"
 #elif defined(VGA_nanomips)
 #  include "vki-posixtypes-nanomips-linux.h"
+#elif defined(VGA_loongarch64)
+#  include "vki-posixtypes-loongarch64-linux.h"
 #else
 #  error Unknown platform
 #endif
@@ -225,6 +227,8 @@ typedef unsigned int	        vki_uint;
 #  include "vki-mips64-linux.h"
 #elif defined(VGA_nanomips)
 #  include "vki-nanomips-linux.h"
+#elif defined(VGA_loongarch64)
+#  include "vki-loongarch64-linux.h"
 #else
 #  error Unknown platform
 #endif
diff --git a/include/vki/vki-loongarch64-linux.h b/include/vki/vki-loongarch64-linux.h
new file mode 100644
index 000000000..97d3f66dd
--- /dev/null
+++ b/include/vki/vki-loongarch64-linux.h
@@ -0,0 +1,811 @@
+
+/*--------------------------------------------------------------------*/
+/*--- loongarch/Linux-specific kernel interface.                   ---*/
+/*---                                      vki-loongarch64-linux.h ---*/
+/*--------------------------------------------------------------------*/
+
+/*
+   This file is part of Valgrind, a dynamic binary instrumentation
+   framework.
+
+   Copyright (C) 2021-2022 Loongson Technology Corporation Limited
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef __VKI_LOONGARCH64_LINUX_H
+#define __VKI_LOONGARCH64_LINUX_H
+
+// loongarch64 is little-endian.
+#define VKI_LITTLE_ENDIAN 1
+
+//----------------------------------------------------------------------
+// From linux-5.15.2/include/uapi/asm-generic/int-ll64.h
+//----------------------------------------------------------------------
+
+typedef __signed__ char __vki_s8;
+typedef unsigned char __vki_u8;
+
+typedef __signed__ short __vki_s16;
+typedef unsigned short __vki_u16;
+
+typedef __signed__ int __vki_s32;
+typedef unsigned int __vki_u32;
+
+typedef __signed__ long long __vki_s64;
+typedef unsigned long long __vki_u64;
+
+//----------------------------------------------------------------------
+// From linux-5.15.2/include/asm-generic/int-ll64.h
+//----------------------------------------------------------------------
+
+typedef __vki_s8  vki_s8;
+typedef __vki_u8  vki_u8;
+typedef __vki_s16 vki_s16;
+typedef __vki_u16 vki_u16;
+typedef __vki_s32 vki_s32;
+typedef __vki_u32 vki_u32;
+typedef __vki_s64 vki_s64;
+typedef __vki_u64 vki_u64;
+
+//----------------------------------------------------------------------
+// From linux-5.15.2/include/linux/types.h
+//----------------------------------------------------------------------
+
+typedef vki_u8  vki_u_int8_t;
+typedef vki_s8  vki_int8_t;
+typedef vki_u16 vki_u_int16_t;
+typedef vki_s16 vki_int16_t;
+typedef vki_u32 vki_u_int32_t;
+typedef vki_s32 vki_int32_t;
+
+typedef vki_u8  vki_uint8_t;
+typedef vki_u16 vki_uint16_t;
+typedef vki_u32 vki_uint32_t;
+
+typedef vki_u64 vki_uint64_t;
+typedef vki_u64 vki_u_int64_t;
+typedef vki_s64 vki_int64_t;
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/arch/loongarch/include/asm/page.h
+//----------------------------------------------------------------------
+
+/* loongarch64 uses runtime pagesize detection */
+extern UWord VKI_PAGE_SHIFT;
+extern UWord VKI_PAGE_SIZE;
+#define VKI_PAGE_MASK      (~(PAGE_SIZE - 1))
+#define VKI_MAX_PAGE_SHIFT 16
+#define VKI_MAX_PAGE_SIZE  (1UL << VKI_MAX_PAGE_SHIFT)
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/arch/loongarch/include/asm/shmparam.h
+//----------------------------------------------------------------------
+
+#define VKI_SHMLBA 0x00010000 // SZ_64K
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/arch/loongarch/include/uapi/asm/signal.h
+//----------------------------------------------------------------------
+
+#define VKI_MINSIGSTKSZ 4096
+#define VKI_SIGSTKSZ    16384
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/signal-defs.h
+//----------------------------------------------------------------------
+
+#define VKI_SA_NOCLDSTOP      0x00000001
+#define VKI_SA_NOCLDWAIT      0x00000002
+#define VKI_SA_SIGINFO        0x00000004
+/* 0x00000008 used on alpha, mips, parisc */
+/* 0x00000010 used on alpha, parisc */
+/* 0x00000020 used on alpha, parisc, sparc */
+/* 0x00000040 used on alpha, parisc */
+/* 0x00000080 used on parisc */
+/* 0x00000100 used on sparc */
+/* 0x00000200 used on sparc */
+#define VKI_SA_UNSUPPORTED    0x00000400
+#define VKI_SA_EXPOSE_TAGBITS 0x00000800
+/* 0x00010000 used on mips */
+/* 0x00800000 used for internal SA_IMMUTABLE */
+/* 0x01000000 used on x86 */
+/* 0x02000000 used on x86 */
+/*
+ * New architectures should not define the obsolete
+ *      VKI_SA_RESTORER       0x04000000
+ */
+#define VKI_SA_ONSTACK        0x08000000
+#define VKI_SA_RESTART        0x10000000
+#define VKI_SA_NODEFER        0x40000000
+#define VKI_SA_RESETHAND      0x80000000
+
+#define VKI_SA_NOMASK         VKI_SA_NODEFER
+#define VKI_SA_ONESHOT        VKI_SA_RESETHAND
+
+#define VKI_SIG_BLOCK     0 /* for blocking signals */
+#define VKI_SIG_UNBLOCK   1 /* for unblocking signals */
+#define VKI_SIG_SETMASK   2 /* for setting the signal mask */
+
+typedef void __vki_signalfn_t(int);
+typedef __vki_signalfn_t __user *__vki_sighandler_t;
+
+typedef void __vki_restorefn_t(void);
+typedef __vki_restorefn_t __user *__vki_igrestore_t;
+
+#define VKI_SIG_DFL ((__vki_sighandler_t)0)  /* default signal handling */
+#define VKI_SIG_IGN ((__vki_sighandler_t)1)  /* ignore signal */
+#define VKI_SIG_ERR ((__vki_sighandler_t)-1) /* error return from signal */
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/signal.h
+//----------------------------------------------------------------------
+
+#define _VKI_NSIG       64
+#define _VKI_NSIG_BPW   64 // __BITS_PER_LONG == 64
+#define _VKI_NSIG_WORDS (_VKI_NSIG / _VKI_NSIG_BPW)
+
+#define VKI_SIGHUP     1
+#define VKI_SIGINT     2
+#define VKI_SIGQUIT    3
+#define VKI_SIGILL     4
+#define VKI_SIGTRAP    5
+#define VKI_SIGABRT    6
+#define VKI_SIGIOT     6
+#define VKI_SIGBUS     7
+#define VKI_SIGFPE     8
+#define VKI_SIGKILL    9
+#define VKI_SIGUSR1   10
+#define VKI_SIGSEGV   11
+#define VKI_SIGUSR2   12
+#define VKI_SIGPIPE   13
+#define VKI_SIGALRM   14
+#define VKI_SIGTERM   15
+#define VKI_SIGSTKFLT 16
+#define VKI_SIGCHLD   17
+#define VKI_SIGCONT   18
+#define VKI_SIGSTOP   19
+#define VKI_SIGTSTP   20
+#define VKI_SIGTTIN   21
+#define VKI_SIGTTOU   22
+#define VKI_SIGURG    23
+#define VKI_SIGXCPU   24
+#define VKI_SIGXFSZ   25
+#define VKI_SIGVTALRM 26
+#define VKI_SIGPROF   27
+#define VKI_SIGWINCH  28
+#define VKI_SIGIO     29
+#define VKI_SIGPOLL   VKI_SIGIO
+/*
+#define VKI_SIGLOST   29
+*/
+#define VKI_SIGPWR    30
+#define VKI_SIGSYS    31
+#define VKI_SIGUNUSED 31
+
+#define VKI_SIGRTMIN  32
+#define VKI_SIGRTMAX  _VKI_NSIG
+
+typedef struct {
+   unsigned long sig[_VKI_NSIG_WORDS];
+} vki_sigset_t;
+
+typedef unsigned long vki_old_sigset_t;
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/linux/signal.h
+//----------------------------------------------------------------------
+
+#define VKI_SS_ONSTACK 1
+#define VKI_SS_DISABLE 2
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/linux/signal_types.h
+//----------------------------------------------------------------------
+
+struct vki_sigaction {
+   __vki_sighandler_t sa_handler;
+	unsigned long      sa_flags;
+	vki_sigset_t       sa_mask; /* mask last for extensibility */
+};
+
+struct vki_sigaction_base {
+   // [[Nb: a 'k' prefix is added to "sa_handler" because
+   // bits/sigaction.h (which gets dragged in somehow via signal.h)
+   // #defines it as something else.  Since that is done for glibc's
+   // purposes, which we don't care about here, we use our own name.]]
+   __vki_sighandler_t ksa_handler;
+   unsigned long      sa_flags;
+   vki_sigset_t       sa_mask; /* mask last for extensibility */
+};
+
+/* On Linux we use the same type for passing sigactions to
+   and from the kernel.  Hence: */
+typedef struct vki_sigaction_base vki_sigaction_toK_t;
+typedef struct vki_sigaction_base vki_sigaction_fromK_t;
+
+typedef struct vki_sigaltstack {
+   void __user         *ss_sp;
+   int                 ss_flags;
+   __vki_kernel_size_t ss_size;
+} vki_stack_t;
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/arch/loongarch/include/uapi/asm/sigcontext.h
+//----------------------------------------------------------------------
+
+struct vki_sigcontext {
+   __vki_u64 sc_pc;
+   __vki_u64 sc_regs[32];
+   __vki_u32 sc_flags;
+   __vki_u64 sc_extcontext[0] __attribute__((__aligned__(16)));
+};
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/linux/mman.h
+//----------------------------------------------------------------------
+
+#define VKI_MAP_SHARED          0x01       /* Share changes */
+#define VKI_MAP_PRIVATE         0x02       /* Changes are private */
+#define VKI_MAP_SHARED_VALIDATE 0x03       /* share + validate extension flags */
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/mman-common.h
+//----------------------------------------------------------------------
+
+#define VKI_PROT_READ  0x1                 /* page can be read */
+#define VKI_PROT_WRITE 0x2                 /* page can be written */
+#define VKI_PROT_EXEC  0x4                 /* page can be executed */
+#define VKI_PROT_SEM   0x8                 /* page may be used for atomic ops */
+/*                              0x10          reserved for arch-specific use */
+/*                              0x20          reserved for arch-specific use */
+#define VKI_PROT_NONE           0x0        /* page can not be accessed */
+#define VKI_PROT_GROWSDOWN      0x01000000 /* mprotect flag: extend change to start of growsdown vma */
+#define VKI_PROT_GROWSUP        0x02000000 /* mprotect flag: extend change to end of growsup vma */
+
+/* 0x01 - 0x03 are defined in linux/mman.h */
+#define VKI_MAP_TYPE            0x0f       /* Mask for type of mapping */
+#define VKI_MAP_FIXED           0x10       /* Interpret addr exactly */
+#define VKI_MAP_ANONYMOUS       0x20       /* don't use a file */
+
+/* 0x0100 - 0x4000 flags are defined in asm-generic/mman.h */
+#define VKI_MAP_POPULATE        0x008000   /* populate (prefault) pagetables */
+#define VKI_MAP_NONBLOCK        0x010000   /* do not block on IO */
+#define VKI_MAP_STACK           0x020000   /* give out an address that is best suited for process/thread stacks */
+#define VKI_MAP_HUGETLB         0x040000   /* create a huge page mapping */
+#define VKI_MAP_SYNC            0x080000   /* perform synchronous page faults for the mapping */
+#define VKI_MAP_FIXED_NOREPLACE 0x100000   /* MAP_FIXED which doesn't unmap underlying mapping */
+
+#define VKI_MAP_UNINITIALIZED   0x4000000  /* For anonymous mmap, memory could be uninitialized */
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/fcntl.h
+//----------------------------------------------------------------------
+
+#define VKI_O_ACCMODE    00000003
+#define VKI_O_RDONLY     00000000
+#define VKI_O_WRONLY     00000001
+#define VKI_O_RDWR       00000002
+#define VKI_O_CREAT      00000100 /* not fcntl */
+#define VKI_O_EXCL       00000200 /* not fcntl */
+#define VKI_O_NOCTTY     00000400 /* not fcntl */
+#define VKI_O_TRUNC      00001000 /* not fcntl */
+#define VKI_O_APPEND     00002000
+#define VKI_O_NONBLOCK   00004000
+#define VKI_O_DSYNC      00010000 /* used to be O_SYNC, see below */
+#define VKI_FASYNC       00020000 /* fcntl, for BSD compatibility */
+#define VKI_O_DIRECT     00040000 /* direct disk access hint */
+#define VKI_O_LARGEFILE  00100000
+
+#define VKI_F_DUPFD         0  /* dup */
+#define VKI_F_GETFD         1  /* get close_on_exec */
+#define VKI_F_SETFD         2  /* set/clear close_on_exec */
+#define VKI_F_GETFL         3  /* get file->f_flags */
+#define VKI_F_SETFL         4  /* set file->f_flags */
+#define VKI_F_GETLK         5
+#define VKI_F_SETLK         6
+#define VKI_F_SETLKW        7
+#define VKI_F_SETOWN        8  /* for sockets. */
+#define VKI_F_GETOWN        9  /* for sockets. */
+#define VKI_F_SETSIG        10 /* for sockets. */
+#define VKI_F_GETSIG        11 /* for sockets. */
+
+#define VKI_F_SETOWN_EX     15
+#define VKI_F_GETOWN_EX     16
+
+#define VKI_F_GETOWNER_UIDS 17
+
+#define VKI_F_OFD_GETLK     36
+#define VKI_F_OFD_SETLK     37
+#define VKI_F_OFD_SETLKW    38
+
+#define VKI_F_OWNER_TID     0
+#define VKI_F_OWNER_PID     1
+#define VKI_F_OWNER_PGRP    2
+
+struct vki_f_owner_ex {
+   int   type;
+   __vki_kernel_pid_t   pid;
+};
+
+#define VKI_FD_CLOEXEC 1  /* actually anything with low bit set goes */
+
+#define VKI_F_RDLCK    0
+#define VKI_F_WRLCK    1
+#define VKI_F_UNLCK    2
+
+#define VKI_F_EXLCK    4   /* or 3 */
+#define VKI_F_SHLCK    8   /* or 4 */
+
+#define VKI_LOCK_SH    1   /* shared lock */
+#define VKI_LOCK_EX    2   /* exclusive lock */
+#define VKI_LOCK_NB    4   /* or'd with one of the above to prevent blocking */
+#define VKI_LOCK_UN    8   /* remove lock */
+
+#define VKI_LOCK_MAND  32  /* This is a mandatory flock ... */
+#define VKI_LOCK_READ  64  /* which allows concurrent read operations */
+#define VKI_LOCK_WRITE 128 /* which allows concurrent write operations */
+#define VKI_LOCK_RW    192 /* which allows concurrent read & write ops */
+
+#define VKI_F_LINUX_SPECIFIC_BASE 1024
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/linux/fcntl.h
+//----------------------------------------------------------------------
+
+#define VKI_AT_FDCWD -100 /* Special value used to indicate
+                             openat should use the current
+                             working directory. */
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/resource.h
+//----------------------------------------------------------------------
+
+#define VKI_RLIMIT_DATA   2 /* max data size */
+#define VKI_RLIMIT_STACK  3 /* max stack size */
+#define VKI_RLIMIT_CORE   4 /* max core file size */
+#define VKI_RLIMIT_NOFILE 7 /* max number of open files */
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/socket.h
+//----------------------------------------------------------------------
+
+#define VKI_SOL_SOCKET 1
+#define VKI_SO_TYPE    3
+
+#define VKI_SO_ATTACH_FILTER 26
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/sockios.h
+//----------------------------------------------------------------------
+
+#define VKI_FIOSETOWN        0x8901
+#define VKI_SIOCSPGRP        0x8902
+#define VKI_FIOGETOWN        0x8903
+#define VKI_SIOCGPGRP        0x8904
+#define VKI_SIOCATMARK       0x8905
+#define VKI_SIOCGSTAMP_OLD   0x8906 /* Get stamp (timeval) */
+#define VKI_SIOCGSTAMPNS_OLD 0x8907 /* Get stamp (timespec) */
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/linux/sockios.h
+//----------------------------------------------------------------------
+
+#define VKI_SIOCGSTAMP       VKI_SIOCGSTAMP_OLD
+#define VKI_SIOCGSTAMPNS     VKI_SIOCGSTAMPNS_OLD
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/stat.h
+//----------------------------------------------------------------------
+
+struct vki_stat {
+   unsigned long st_dev;        /* Device.  */
+   unsigned long st_ino;        /* File serial number.  */
+   unsigned int  st_mode;       /* File mode.  */
+   unsigned int  st_nlink;      /* Link count.  */
+   unsigned int  st_uid;        /* User ID of the file's owner.  */
+   unsigned int  st_gid;        /* Group ID of the file's group. */
+   unsigned long st_rdev;       /* Device number, if device.  */
+   unsigned long __pad1;
+   long          st_size;       /* Size of file, in bytes.  */
+   int           st_blksize;    /* Optimal block size for I/O.  */
+   int           __pad2;
+   long          st_blocks;     /* Number 512-byte blocks allocated. */
+   long          st_atime;      /* Time of last access.  */
+   unsigned long st_atime_nsec;
+   long          st_mtime;      /* Time of last modification.  */
+   unsigned long st_mtime_nsec;
+   long          st_ctime;      /* Time of last status change.  */
+   unsigned long st_ctime_nsec;
+   unsigned int  __unused4;
+   unsigned int  __unused5;
+};
+
+struct vki_stat64 {
+   unsigned long long st_dev;        /* Device.  */
+   unsigned long long st_ino;        /* File serial number.  */
+   unsigned int       st_mode;       /* File mode.  */
+   unsigned int       st_nlink;      /* Link count.  */
+   unsigned int       st_uid;        /* User ID of the file's owner.  */
+   unsigned int       st_gid;        /* Group ID of the file's group. */
+   unsigned long long st_rdev;       /* Device number, if device.  */
+   unsigned long long __pad1;
+   long long          st_size;       /* Size of file, in bytes.  */
+   int                st_blksize;    /* Optimal block size for I/O.  */
+   int                __pad2;
+   long long          st_blocks;     /* Number 512-byte blocks allocated. */
+   int                st_atime;      /* Time of last access.  */
+   unsigned int       st_atime_nsec;
+   int                st_mtime;      /* Time of last modification.  */
+   unsigned int       st_mtime_nsec;
+   int                st_ctime;      /* Time of last status change.  */
+   unsigned int       st_ctime_nsec;
+   unsigned int       __unused4;
+   unsigned int       __unused5;
+};
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/statfs.h
+//----------------------------------------------------------------------
+
+#define __vki_statfs_word __vki_kernel_long_t
+
+struct vki_statfs {
+   __vki_statfs_word f_type;
+   __vki_statfs_word f_bsize;
+   __vki_statfs_word f_blocks;
+   __vki_statfs_word f_bfree;
+   __vki_statfs_word f_bavail;
+   __vki_statfs_word f_files;
+   __vki_statfs_word f_ffree;
+   __vki_kernel_fsid_t f_fsid;
+   __vki_statfs_word f_namelen;
+   __vki_statfs_word f_frsize;
+   __vki_statfs_word f_flags;
+   __vki_statfs_word f_spare[4];
+};
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/termios.h
+//----------------------------------------------------------------------
+
+struct vki_winsize {
+   unsigned short ws_row;
+   unsigned short ws_col;
+   unsigned short ws_xpixel;
+   unsigned short ws_ypixel;
+};
+
+#define VKI_NCC 8
+struct vki_termio {
+   unsigned short c_iflag;       /* input mode flags */
+   unsigned short c_oflag;       /* output mode flags */
+   unsigned short c_cflag;       /* control mode flags */
+   unsigned short c_lflag;       /* local mode flags */
+   unsigned char  c_line;        /* line discipline */
+   unsigned char  c_cc[VKI_NCC]; /* control characters */
+};
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/termbits.h
+//----------------------------------------------------------------------
+
+typedef unsigned char vki_cc_t;
+typedef unsigned int  vki_speed_t;
+typedef unsigned int  vki_tcflag_t;
+
+#define VKI_NCCS 19
+struct vki_termios {
+   vki_tcflag_t c_iflag;     /* input mode flags */
+   vki_tcflag_t c_oflag;     /* output mode flags */
+   vki_tcflag_t c_cflag;     /* control mode flags */
+   vki_tcflag_t c_lflag;     /* local mode flags */
+   vki_cc_t c_line;          /* line discipline */
+   vki_cc_t c_cc[VKI_NCCS];  /* control characters */
+};
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/ioctl.h
+//----------------------------------------------------------------------
+
+#define _VKI_IOC_NRBITS    8
+#define _VKI_IOC_TYPEBITS  8
+#define _VKI_IOC_SIZEBITS  14
+#define _VKI_IOC_DIRBITS   2
+
+#define _VKI_IOC_NRMASK    ((1 << _VKI_IOC_NRBITS)-1)
+#define _VKI_IOC_TYPEMASK  ((1 << _VKI_IOC_TYPEBITS)-1)
+#define _VKI_IOC_SIZEMASK  ((1 << _VKI_IOC_SIZEBITS)-1)
+#define _VKI_IOC_DIRMASK   ((1 << _VKI_IOC_DIRBITS)-1)
+
+#define _VKI_IOC_NRSHIFT   0
+#define _VKI_IOC_TYPESHIFT (_VKI_IOC_NRSHIFT+_VKI_IOC_NRBITS)
+#define _VKI_IOC_SIZESHIFT (_VKI_IOC_TYPESHIFT+_VKI_IOC_TYPEBITS)
+#define _VKI_IOC_DIRSHIFT  (_VKI_IOC_SIZESHIFT+_VKI_IOC_SIZEBITS)
+
+#define _VKI_IOC_NONE      0U
+#define _VKI_IOC_WRITE     1U
+#define _VKI_IOC_READ      2U
+
+#define _VKI_IOC(dir,type,nr,size) \
+        (((dir)  << _VKI_IOC_DIRSHIFT) | \
+         ((type) << _VKI_IOC_TYPESHIFT) | \
+         ((nr)   << _VKI_IOC_NRSHIFT) | \
+         ((size) << _VKI_IOC_SIZESHIFT))
+
+#define _VKI_IO(type,nr)            _VKI_IOC(_VKI_IOC_NONE,(type),(nr),0)
+#define _VKI_IOR(type,nr,size)      _VKI_IOC(_VKI_IOC_READ,(type),(nr),(_VKI_IOC_TYPECHECK(size)))
+#define _VKI_IOW(type,nr,size)      _VKI_IOC(_VKI_IOC_WRITE,(type),(nr),(_VKI_IOC_TYPECHECK(size)))
+#define _VKI_IOWR(type,nr,size)     _VKI_IOC(_VKI_IOC_READ|_VKI_IOC_WRITE,(type),(nr),(_VKI_IOC_TYPECHECK(size)))
+#define _VKI_IOR_BAD(type,nr,size)  _VKI_IOC(_VKI_IOC_READ,(type),(nr),sizeof(size))
+#define _VKI_IOW_BAD(type,nr,size)  _VKI_IOC(_VKI_IOC_WRITE,(type),(nr),sizeof(size))
+#define _VKI_IOWR_BAD(type,nr,size) _VKI_IOC(_VKI_IOC_READ|_VKI_IOC_WRITE,(type),(nr),sizeof(size))
+
+#define _VKI_IOC_DIR(nr)  (((nr) >> _VKI_IOC_DIRSHIFT) & _VKI_IOC_DIRMASK)
+#define _VKI_IOC_TYPE(nr) (((nr) >> _VKI_IOC_TYPESHIFT) & _VKI_IOC_TYPEMASK)
+#define _VKI_IOC_NR(nr)   (((nr) >> _VKI_IOC_NRSHIFT) & _VKI_IOC_NRMASK)
+#define _VKI_IOC_SIZE(nr) (((nr) >> _VKI_IOC_SIZESHIFT) & _VKI_IOC_SIZEMASK)
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/ioctls.h
+//----------------------------------------------------------------------
+
+#define VKI_TCGETS       0x5401
+#define VKI_TCSETS       0x5402
+#define VKI_TCSETSW      0x5403
+#define VKI_TCSETSF      0x5404
+#define VKI_TCGETA       0x5405
+#define VKI_TCSETA       0x5406
+#define VKI_TCSETAW      0x5407
+#define VKI_TCSETAF      0x5408
+#define VKI_TCSBRK       0x5409
+#define VKI_TCXONC       0x540A
+#define VKI_TCFLSH       0x540B
+#define VKI_TIOCEXCL     0x540C
+#define VKI_TIOCNXCL     0x540D
+#define VKI_TIOCSCTTY    0x540E
+#define VKI_TIOCGPGRP    0x540F
+#define VKI_TIOCSPGRP    0x5410
+#define VKI_TIOCOUTQ     0x5411
+#define VKI_TIOCSTI      0x5412
+#define VKI_TIOCGWINSZ   0x5413
+#define VKI_TIOCSWINSZ   0x5414
+#define VKI_TIOCMGET     0x5415
+#define VKI_TIOCMBIS     0x5416
+#define VKI_TIOCMBIC     0x5417
+#define VKI_TIOCMSET     0x5418
+#define VKI_TIOCGSOFTCAR 0x5419
+#define VKI_TIOCSSOFTCAR 0x541A
+#define VKI_FIONREAD     0x541B
+#define VKI_TIOCINQ      VKI_FIONREAD
+#define VKI_TIOCLINUX    0x541C
+#define VKI_TIOCCONS     0x541D
+#define VKI_TIOCGSERIAL  0x541E
+#define VKI_TIOCSSERIAL  0x541F
+#define VKI_TIOCPKT      0x5420
+#define VKI_FIONBIO      0x5421
+#define VKI_TIOCNOTTY    0x5422
+#define VKI_TIOCSETD     0x5423
+#define VKI_TIOCGETD     0x5424
+#define VKI_TCSBRKP      0x5425   /* Needed for POSIX tcsendbreak() */
+#define VKI_TIOCSBRK     0x5427   /* BSD compatibility */
+#define VKI_TIOCCBRK     0x5428   /* BSD compatibility */
+#define VKI_TIOCGSID     0x5429   /* Return the session ID of FD */
+#define VKI_TCGETS2      _VKI_IOR('T', 0x2A, struct termios2)
+#define VKI_TCSETS2      _VKI_IOW('T', 0x2B, struct termios2)
+#define VKI_TCSETSW2     _VKI_IOW('T', 0x2C, struct termios2)
+#define VKI_TCSETSF2     _VKI_IOW('T', 0x2D, struct termios2)
+#define VKI_TIOCGRS485   0x542E
+#define VKI_TIOCSRS485   0x542F
+#define VKI_TIOCGPTN     _VKI_IOR('T', 0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
+#define VKI_TIOCSPTLCK   _VKI_IOW('T', 0x31, int) /* Lock/unlock Pty */
+#define VKI_TIOCGDEV     _VKI_IOR('T', 0x32, unsigned int) /* Get primary device node of /dev/console */
+#define VKI_TCGETX       0x5432 /* SYS5 TCGETX compatibility */
+#define VKI_TCSETX       0x5433
+#define VKI_TCSETXF      0x5434
+#define VKI_TCSETXW      0x5435
+#define VKI_TIOCSIG      _VKI_IOW('T', 0x36, int) /* pty: generate signal */
+#define VKI_TIOCVHANGUP  0x5437
+#define VKI_TIOCGPKT     _VKI_IOR('T', 0x38, int) /* Get packet mode state */
+#define VKI_TIOCGPTLCK   _VKI_IOR('T', 0x39, int) /* Get Pty lock state */
+#define VKI_TIOCGEXCL    _VKI_IOR('T', 0x40, int) /* Get exclusive mode state */
+#define VKI_TIOCGPTPEER  _VKI_IO('T', 0x41)       /* Safely open the slave */
+#define VKI_TIOCGISO7816 _VKI_IOR('T', 0x42, struct serial_iso7816)
+#define VKI_TIOCSISO7816 _VKI_IOWR('T', 0x43, struct serial_iso7816)
+
+#define VKI_FIONCLEX        0x5450
+#define VKI_FIOCLEX         0x5451
+#define VKI_FIOASYNC        0x5452
+#define VKI_TIOCSERCONFIG   0x5453
+#define VKI_TIOCSERGWILD    0x5454
+#define VKI_TIOCSERSWILD    0x5455
+#define VKI_TIOCGLCKTRMIOS  0x5456
+#define VKI_TIOCSLCKTRMIOS  0x5457
+#define VKI_TIOCSERGSTRUCT  0x5458 /* For debugging only */
+#define VKI_TIOCSERGETLSR   0x5459 /* Get line status register */
+#define VKI_TIOCSERGETMULTI 0x545A /* Get multiport config  */
+#define VKI_TIOCSERSETMULTI 0x545B /* Set multiport config */
+
+#define VKI_TIOCMIWAIT      0x545C /* wait for a change on serial input line(s) */
+#define VKI_TIOCGICOUNT     0x545D /* read serial port inline interrupt counts */
+
+#define VKI_FIOQSIZE        0x5460
+
+#define VKI_TIOCPKT_DATA       0
+#define VKI_TIOCPKT_FLUSHREAD  1
+#define VKI_TIOCPKT_FLUSHWRITE 2
+#define VKI_TIOCPKT_STOP       4
+#define VKI_TIOCPKT_START      8
+#define VKI_TIOCPKT_NOSTOP    16
+#define VKI_TIOCPKT_DOSTOP    32
+#define VKI_TIOCPKT_IOCTL     64
+
+#define VKI_TIOCSER_TEMT 0x01 /* Transmitter physically empty */
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/poll.h
+//----------------------------------------------------------------------
+
+#define VKI_POLLIN 0x0001
+
+struct vki_pollfd {
+   int   fd;
+   short events;
+   short revents;
+};
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/arch/loongarch/include/asm/elf.h
+//----------------------------------------------------------------------
+
+#define VKI_ELF_NGREG  45
+#define VKI_ELF_NFPREG 34
+
+typedef unsigned long vki_elf_greg_t;
+typedef vki_elf_greg_t vki_elf_gregset_t[VKI_ELF_NGREG];
+
+typedef double vki_elf_fpreg_t;
+typedef vki_elf_fpreg_t vki_elf_fpregset_t[VKI_ELF_NFPREG];
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/arch/loongarch/include/uapi/asm/ucontext.h
+//----------------------------------------------------------------------
+
+struct vki_ucontext {
+   unsigned long         uc_flags;
+   struct vki_ucontext   *uc_link;
+   vki_stack_t           uc_stack;
+   vki_sigset_t          uc_sigmask;
+   __vki_u8              __unused[1024 / 8 - sizeof(vki_sigset_t)];
+   struct vki_sigcontext uc_mcontext;
+};
+
+typedef char vki_modify_ldt_t;
+
+
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/ipcbuf.h
+//----------------------------------------------------------------------
+
+struct vki_ipc64_perm {
+   __vki_kernel_key_t   key;
+   __vki_kernel_uid32_t uid;
+   __vki_kernel_gid32_t gid;
+   __vki_kernel_uid32_t cuid;
+   __vki_kernel_gid32_t cgid;
+   __vki_kernel_mode_t  mode;
+   unsigned char        __pad1[4 - sizeof(__vki_kernel_mode_t)]; /* pad if mode_t is u16: */
+   unsigned short       seq;
+   unsigned short       __pad2;
+   __vki_kernel_ulong_t __unused1;
+   __vki_kernel_ulong_t __unused2;
+};
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/sembuf.h
+//----------------------------------------------------------------------
+struct vki_semid64_ds {
+   struct vki_ipc64_perm sem_perm;  /* permissions .. see ipc.h */
+   long                  sem_otime; /* last semop time */
+   long                  sem_ctime; /* last change time */
+   unsigned long         sem_nsems; /* no. of semaphores in array */
+   unsigned long         __unused3;
+   unsigned long         __unused4;
+};
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/msgbuf.h
+//----------------------------------------------------------------------
+
+struct vki_msqid64_ds {
+   struct vki_ipc64_perm msg_perm;
+   long                  msg_stime;  /* last msgsnd time */
+   long                  msg_rtime;  /* last msgrcv time */
+   long                  msg_ctime;  /* last change time */
+   unsigned long         msg_cbytes; /* current number of bytes on queue */
+   unsigned long         msg_qnum;   /* number of messages in queue */
+   unsigned long         msg_qbytes; /* max number of bytes on queue */
+   __vki_kernel_pid_t    msg_lspid;  /* pid of last msgsnd */
+   __vki_kernel_pid_t    msg_lrpid;  /* last receive pid */
+   unsigned long         __unused4;
+   unsigned long         __unused5;
+};
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/shmbuf.h
+//----------------------------------------------------------------------
+
+struct vki_shmid64_ds {
+   struct vki_ipc64_perm shm_perm;   /* operation perms */
+   vki_size_t            shm_segsz;  /* size of segment (bytes) */
+   long                  shm_atime;  /* last attach time */
+   long                  shm_dtime;  /* last detach time */
+   long                  shm_ctime;  /* last change time */
+   __vki_kernel_pid_t    shm_cpid;   /* pid of creator */
+   __vki_kernel_pid_t    shm_lpid;   /* pid of last operator */
+   unsigned long         shm_nattch; /* no. of current attaches */
+   unsigned long         __unused4;
+   unsigned long         __unused5;
+};
+
+struct vki_shminfo64 {
+   unsigned long shmmax;
+   unsigned long shmmin;
+   unsigned long shmmni;
+   unsigned long shmseg;
+   unsigned long shmall;
+   unsigned long __unused1;
+   unsigned long __unused2;
+   unsigned long __unused3;
+   unsigned long __unused4;
+};
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/arch/loongarch/include/uapi/asm/ptrace.h
+//----------------------------------------------------------------------
+
+struct vki_user_pt_regs {
+   /* Saved main processor registers. */
+   unsigned long regs[32];
+
+   /* Original syscall arg0. */
+   unsigned long orig_a0;
+
+   /* Saved special registers. */
+   unsigned long csr_era;
+   unsigned long csr_badv;
+   unsigned long reserved[10];
+} __attribute__((aligned(8)));
+
+#define vki_user_regs_struct vki_user_pt_regs
+
+struct vki_user_fp_state {
+   vki_uint64_t fpr[32];
+   vki_uint64_t fcc;
+   vki_uint32_t fcsr;
+};
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/errno.h
+//----------------------------------------------------------------------
+
+#define VKI_ENOSYS     38 /* Invalid system call number */
+#define VKI_EOVERFLOW  75 /* Value too large for defined data type */
+
+#endif // __VKI_LOONGARCH64_LINUX_H
+
+/*--------------------------------------------------------------------*/
+/*--- end                                  vki-loongarch64-linux.h ---*/
+/*--------------------------------------------------------------------*/
diff --git a/include/vki/vki-posixtypes-loongarch64-linux.h b/include/vki/vki-posixtypes-loongarch64-linux.h
new file mode 100644
index 000000000..0282a2a39
--- /dev/null
+++ b/include/vki/vki-posixtypes-loongarch64-linux.h
@@ -0,0 +1,76 @@
+
+/*--------------------------------------------------------------------*/
+/*--- loongarch/Linux-specific kernel interface: posix types.      ---*/
+/*---                           vki-posixtypes-loongarch64-linux.h ---*/
+/*--------------------------------------------------------------------*/
+
+/*
+   This file is part of Valgrind, a dynamic binary instrumentation
+   framework.
+
+   Copyright (C) 2021-2022 Loongson Technology Corporation Limited
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/>.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+#ifndef __VKI_POSIXTYPES_LOONGARCH64_LINUX_H
+#define __VKI_POSIXTYPES_LOONGARCH64_LINUX_H
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/posix_types.h
+//----------------------------------------------------------------------
+
+typedef long                 __vki_kernel_long_t;
+typedef unsigned long        __vki_kernel_ulong_t;
+typedef __vki_kernel_ulong_t __vki_kernel_ino_t;
+typedef unsigned int         __vki_kernel_mode_t;
+typedef int                  __vki_kernel_pid_t;
+typedef int                  __vki_kernel_ipc_pid_t;
+typedef unsigned int         __vki_kernel_uid_t;
+typedef unsigned int         __vki_kernel_gid_t;
+typedef __vki_kernel_long_t  __vki_kernel_suseconds_t;
+typedef int                  __vki_kernel_daddr_t;
+typedef unsigned int         __vki_kernel_uid32_t;
+typedef unsigned int         __vki_kernel_gid32_t;
+typedef __vki_kernel_uid_t   __vki_kernel_old_uid_t;
+typedef __vki_kernel_gid_t   __vki_kernel_old_gid_t;
+typedef unsigned int         __vki_kernel_old_dev_t;
+
+typedef __vki_kernel_ulong_t __vki_kernel_size_t;
+typedef __vki_kernel_long_t  __vki_kernel_ssize_t;
+typedef __vki_kernel_long_t  __vki_kernel_ptrdiff_t;
+
+typedef struct {
+   int val[2];
+} __vki_kernel_fsid_t;
+
+typedef __vki_kernel_long_t  __vki_kernel_off_t;
+typedef long long            __vki_kernel_loff_t;
+typedef __vki_kernel_long_t  __vki_kernel_old_time_t;
+typedef __vki_kernel_long_t  __vki_kernel_time_t;
+typedef long long            __vki_kernel_time64_t;
+typedef __vki_kernel_long_t  __vki_kernel_clock_t;
+typedef int                  __vki_kernel_timer_t;
+typedef int                  __vki_kernel_clockid_t;
+typedef char *               __vki_kernel_caddr_t;
+typedef unsigned short       __vki_kernel_uid16_t;
+typedef unsigned short       __vki_kernel_gid16_t;
+
+#endif // __VKI_POSIXTYPES_LOONGARCH64_LINUX_H
+
+/*--------------------------------------------------------------------*/
+/*--- end                       vki-posixtypes-loongarch64-linux.h ---*/
+/*--------------------------------------------------------------------*/
diff --git a/include/vki/vki-scnums-loongarch64-linux.h b/include/vki/vki-scnums-loongarch64-linux.h
new file mode 100644
index 000000000..552824f66
--- /dev/null
+++ b/include/vki/vki-scnums-loongarch64-linux.h
@@ -0,0 +1,330 @@
+/*--------------------------------------------------------------------*/
+/*--- System call numbers for loongarch-linux.                     ---*/
+/*---                               vki-scnums-loongarch64-linux.h ---*/
+/*--------------------------------------------------------------------*/
+
+/*
+   This file is part of Valgrind, a dynamic binary instrumentation
+   framework.
+
+   Copyright (C) 2021-2022 Loongson Technology Corporation Limited
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/>.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+#ifndef __VKI_SCNUMS_LOONGARCH64_LINUX_H
+#define __VKI_SCNUMS_LOONGARCH64_LINUX_H
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/unistd.h
+//----------------------------------------------------------------------
+
+#define __NR_io_setup 0
+#define __NR_io_destroy 1
+#define __NR_io_submit 2
+#define __NR_io_cancel 3
+#define __NR_io_getevents 4
+#define __NR_setxattr 5
+#define __NR_lsetxattr 6
+#define __NR_fsetxattr 7
+#define __NR_getxattr 8
+#define __NR_lgetxattr 9
+#define __NR_fgetxattr 10
+#define __NR_listxattr 11
+#define __NR_llistxattr 12
+#define __NR_flistxattr 13
+#define __NR_removexattr 14
+#define __NR_lremovexattr 15
+#define __NR_fremovexattr 16
+#define __NR_getcwd 17
+#define __NR_lookup_dcookie 18
+#define __NR_eventfd2 19
+#define __NR_epoll_create1 20
+#define __NR_epoll_ctl 21
+#define __NR_epoll_pwait 22
+#define __NR_dup 23
+#define __NR_dup3 24
+#define __NR3264_fcntl 25
+#define __NR_inotify_init1 26
+#define __NR_inotify_add_watch 27
+#define __NR_inotify_rm_watch 28
+#define __NR_ioctl 29
+#define __NR_ioprio_set 30
+#define __NR_ioprio_get 31
+#define __NR_flock 32
+#define __NR_mknodat 33
+#define __NR_mkdirat 34
+#define __NR_unlinkat 35
+#define __NR_symlinkat 36
+#define __NR_linkat 37
+// #define __NR_renameat 38
+#define __NR_umount2 39
+#define __NR_mount 40
+#define __NR_pivot_root 41
+#define __NR_nfsservctl 42
+#define __NR3264_statfs 43
+#define __NR3264_fstatfs 44
+#define __NR3264_truncate 45
+#define __NR3264_ftruncate 46
+#define __NR_fallocate 47
+#define __NR_faccessat 48
+#define __NR_chdir 49
+#define __NR_fchdir 50
+#define __NR_chroot 51
+#define __NR_fchmod 52
+#define __NR_fchmodat 53
+#define __NR_fchownat 54
+#define __NR_fchown 55
+#define __NR_openat 56
+#define __NR_close 57
+#define __NR_vhangup 58
+#define __NR_pipe2 59
+#define __NR_quotactl 60
+#define __NR_getdents64 61
+#define __NR3264_lseek 62
+#define __NR_read 63
+#define __NR_write 64
+#define __NR_readv 65
+#define __NR_writev 66
+#define __NR_pread64 67
+#define __NR_pwrite64 68
+#define __NR_preadv 69
+#define __NR_pwritev 70
+#define __NR3264_sendfile 71
+#define __NR_pselect6 72
+#define __NR_ppoll 73
+#define __NR_signalfd4 74
+#define __NR_vmsplice 75
+#define __NR_splice 76
+#define __NR_tee 77
+#define __NR_readlinkat 78
+// #define __NR3264_fstatat 79
+// #define __NR3264_fstat 80
+#define __NR_sync 81
+#define __NR_fsync 82
+#define __NR_fdatasync 83
+#define __NR_sync_file_range 84
+#define __NR_timerfd_create 85
+#define __NR_timerfd_settime 86
+#define __NR_timerfd_gettime 87
+#define __NR_utimensat 88
+#define __NR_acct 89
+#define __NR_capget 90
+#define __NR_capset 91
+#define __NR_personality 92
+#define __NR_exit 93
+#define __NR_exit_group 94
+#define __NR_waitid 95
+#define __NR_set_tid_address 96
+#define __NR_unshare 97
+#define __NR_futex 98
+#define __NR_set_robust_list 99
+#define __NR_get_robust_list 100
+#define __NR_nanosleep 101
+#define __NR_getitimer 102
+#define __NR_setitimer 103
+#define __NR_kexec_load 104
+#define __NR_init_module 105
+#define __NR_delete_module 106
+#define __NR_timer_create 107
+#define __NR_timer_gettime 108
+#define __NR_timer_getoverrun 109
+#define __NR_timer_settime 110
+#define __NR_timer_delete 111
+#define __NR_clock_settime 112
+#define __NR_clock_gettime 113
+#define __NR_clock_getres 114
+#define __NR_clock_nanosleep 115
+#define __NR_syslog 116
+#define __NR_ptrace 117
+#define __NR_sched_setparam 118
+#define __NR_sched_setscheduler 119
+#define __NR_sched_getscheduler 120
+#define __NR_sched_getparam 121
+#define __NR_sched_setaffinity 122
+#define __NR_sched_getaffinity 123
+#define __NR_sched_yield 124
+#define __NR_sched_get_priority_max 125
+#define __NR_sched_get_priority_min 126
+#define __NR_sched_rr_get_interval 127
+#define __NR_restart_syscall 128
+#define __NR_kill 129
+#define __NR_tkill 130
+#define __NR_tgkill 131
+#define __NR_sigaltstack 132
+#define __NR_rt_sigsuspend 133
+#define __NR_rt_sigaction 134
+#define __NR_rt_sigprocmask 135
+#define __NR_rt_sigpending 136
+#define __NR_rt_sigtimedwait 137
+#define __NR_rt_sigqueueinfo 138
+#define __NR_rt_sigreturn 139
+#define __NR_setpriority 140
+#define __NR_getpriority 141
+#define __NR_reboot 142
+#define __NR_setregid 143
+#define __NR_setgid 144
+#define __NR_setreuid 145
+#define __NR_setuid 146
+#define __NR_setresuid 147
+#define __NR_getresuid 148
+#define __NR_setresgid 149
+#define __NR_getresgid 150
+#define __NR_setfsuid 151
+#define __NR_setfsgid 152
+#define __NR_times 153
+#define __NR_setpgid 154
+#define __NR_getpgid 155
+#define __NR_getsid 156
+#define __NR_setsid 157
+#define __NR_getgroups 158
+#define __NR_setgroups 159
+#define __NR_uname 160
+#define __NR_sethostname 161
+#define __NR_setdomainname 162
+// #define __NR_getrlimit 163
+// #define __NR_setrlimit 164
+#define __NR_getrusage 165
+#define __NR_umask 166
+#define __NR_prctl 167
+#define __NR_getcpu 168
+#define __NR_gettimeofday 169
+#define __NR_settimeofday 170
+#define __NR_adjtimex 171
+#define __NR_getpid 172
+#define __NR_getppid 173
+#define __NR_getuid 174
+#define __NR_geteuid 175
+#define __NR_getgid 176
+#define __NR_getegid 177
+#define __NR_gettid 178
+#define __NR_sysinfo 179
+#define __NR_mq_open 180
+#define __NR_mq_unlink 181
+#define __NR_mq_timedsend 182
+#define __NR_mq_timedreceive 183
+#define __NR_mq_notify 184
+#define __NR_mq_getsetattr 185
+#define __NR_msgget 186
+#define __NR_msgctl 187
+#define __NR_msgrcv 188
+#define __NR_msgsnd 189
+#define __NR_semget 190
+#define __NR_semctl 191
+#define __NR_semtimedop 192
+#define __NR_semop 193
+#define __NR_shmget 194
+#define __NR_shmctl 195
+#define __NR_shmat 196
+#define __NR_shmdt 197
+#define __NR_socket 198
+#define __NR_socketpair 199
+#define __NR_bind 200
+#define __NR_listen 201
+#define __NR_accept 202
+#define __NR_connect 203
+#define __NR_getsockname 204
+#define __NR_getpeername 205
+#define __NR_sendto 206
+#define __NR_recvfrom 207
+#define __NR_setsockopt 208
+#define __NR_getsockopt 209
+#define __NR_shutdown 210
+#define __NR_sendmsg 211
+#define __NR_recvmsg 212
+#define __NR_readahead 213
+#define __NR_brk 214
+#define __NR_munmap 215
+#define __NR_mremap 216
+#define __NR_add_key 217
+#define __NR_request_key 218
+#define __NR_keyctl 219
+#define __NR_clone 220
+#define __NR_execve 221
+#define __NR3264_mmap 222
+#define __NR3264_fadvise64 223
+#define __NR_swapon 224
+#define __NR_swapoff 225
+#define __NR_mprotect 226
+#define __NR_msync 227
+#define __NR_mlock 228
+#define __NR_munlock 229
+#define __NR_mlockall 230
+#define __NR_munlockall 231
+#define __NR_mincore 232
+#define __NR_madvise 233
+#define __NR_remap_file_pages 234
+#define __NR_mbind 235
+#define __NR_get_mempolicy 236
+#define __NR_set_mempolicy 237
+#define __NR_migrate_pages 238
+#define __NR_move_pages 239
+#define __NR_rt_tgsigqueueinfo 240
+#define __NR_perf_event_open 241
+#define __NR_accept4 242
+#define __NR_recvmmsg 243
+
+#define __NR_wait4 260
+#define __NR_prlimit64 261
+#define __NR_fanotify_init 262
+#define __NR_fanotify_mark 263
+#define __NR_name_to_handle_at 264
+#define __NR_open_by_handle_at 265
+#define __NR_clock_adjtime 266
+#define __NR_syncfs 267
+#define __NR_setns 268
+#define __NR_sendmmsg 269
+#define __NR_process_vm_readv 270
+#define __NR_process_vm_writev 271
+#define __NR_kcmp 272
+#define __NR_finit_module 273
+#define __NR_sched_setattr 274
+#define __NR_sched_getattr 275
+#define __NR_renameat2 276
+#define __NR_seccomp 277
+#define __NR_getrandom 278
+#define __NR_memfd_create 279
+#define __NR_bpf 280
+#define __NR_execveat 281
+#define __NR_userfaultfd 282
+#define __NR_membarrier 283
+#define __NR_mlock2 284
+#define __NR_copy_file_range 285
+#define __NR_preadv2 286
+#define __NR_pwritev2 287
+#define __NR_pkey_mprotect 288
+#define __NR_pkey_alloc 289
+#define __NR_pkey_free 290
+#define __NR_statx 291
+#define __NR_io_pgetevents 292
+#define __NR_rseq 293
+#define __NR_kexec_file_load 294
+
+#define __NR_fcntl __NR3264_fcntl
+#define __NR_statfs __NR3264_statfs
+#define __NR_fstatfs __NR3264_fstatfs
+#define __NR_truncate __NR3264_truncate
+#define __NR_ftruncate __NR3264_ftruncate
+#define __NR_lseek __NR3264_lseek
+#define __NR_sendfile __NR3264_sendfile
+#define __NR_mmap __NR3264_mmap
+#define __NR_fadvise64 __NR3264_fadvise64
+
+#endif /* __VKI_SCNUMS_LOONGARCH64_LINUX_H */
+
+/*--------------------------------------------------------------------*/
+/*--- end                           vki-scnums-loongarch64-linux.h ---*/
+/*--------------------------------------------------------------------*/
diff --git a/memcheck/mc_machine.c b/memcheck/mc_machine.c
index 176c8e5cb..49f98948e 100644
--- a/memcheck/mc_machine.c
+++ b/memcheck/mc_machine.c
@@ -1394,6 +1394,118 @@ static Int get_otrack_shadow_offset_wrk ( Int offset, Int szB )
                offset,szB);
    tl_assert(0);
 #  undef GOF
+#  undef SZB
+
+   /* ----------------- loongarch64 ----------------- */
+
+#  elif defined(VGA_loongarch64)
+
+#  define GOF(_fieldname) \
+      (offsetof(VexGuestLOONGARCH64State,guest_##_fieldname))
+#  define SZB(_fieldname) \
+      (sizeof(((VexGuestLOONGARCH64State*)0)->guest_##_fieldname))
+
+   Int  o      = offset;
+   Int  sz     = szB;
+   Bool is48   = sz == 8 || sz == 4;
+   Bool is1248 = sz == 8 || sz == 4 || sz == 2 || sz == 1;
+
+   tl_assert(sz > 0);
+   tl_assert(host_is_little_endian());
+
+   if (o == GOF(R0)  && is1248) return o;
+   if (o == GOF(R1)  && is1248) return o;
+   if (o == GOF(R2)  && is1248) return o;
+   if (o == GOF(R3)  && is1248) return o;
+   if (o == GOF(R4)  && is1248) return o;
+   if (o == GOF(R5)  && is1248) return o;
+   if (o == GOF(R6)  && is1248) return o;
+   if (o == GOF(R7)  && is1248) return o;
+   if (o == GOF(R8)  && is1248) return o;
+   if (o == GOF(R9)  && is1248) return o;
+   if (o == GOF(R10) && is1248) return o;
+   if (o == GOF(R11) && is1248) return o;
+   if (o == GOF(R12) && is1248) return o;
+   if (o == GOF(R13) && is1248) return o;
+   if (o == GOF(R14) && is1248) return o;
+   if (o == GOF(R15) && is1248) return o;
+   if (o == GOF(R16) && is1248) return o;
+   if (o == GOF(R17) && is1248) return o;
+   if (o == GOF(R18) && is1248) return o;
+   if (o == GOF(R19) && is1248) return o;
+   if (o == GOF(R20) && is1248) return o;
+   if (o == GOF(R21) && is1248) return o;
+   if (o == GOF(R22) && is1248) return o;
+   if (o == GOF(R23) && is1248) return o;
+   if (o == GOF(R24) && is1248) return o;
+   if (o == GOF(R25) && is1248) return o;
+   if (o == GOF(R26) && is1248) return o;
+   if (o == GOF(R27) && is1248) return o;
+   if (o == GOF(R28) && is1248) return o;
+   if (o == GOF(R29) && is1248) return o;
+   if (o == GOF(R30) && is1248) return o;
+   if (o == GOF(R31) && is1248) return o;
+
+   if (o == GOF(PC)  && sz == 8) return -1;  /* slot unused */
+
+   if (o >= GOF(X0)  && o + sz <= GOF(X0)  + SZB(X0))  return GOF(X0);
+   if (o >= GOF(X1)  && o + sz <= GOF(X1)  + SZB(X1))  return GOF(X1);
+   if (o >= GOF(X2)  && o + sz <= GOF(X2)  + SZB(X2))  return GOF(X2);
+   if (o >= GOF(X3)  && o + sz <= GOF(X3)  + SZB(X3))  return GOF(X3);
+   if (o >= GOF(X4)  && o + sz <= GOF(X4)  + SZB(X4))  return GOF(X4);
+   if (o >= GOF(X5)  && o + sz <= GOF(X5)  + SZB(X5))  return GOF(X5);
+   if (o >= GOF(X6)  && o + sz <= GOF(X6)  + SZB(X6))  return GOF(X6);
+   if (o >= GOF(X7)  && o + sz <= GOF(X7)  + SZB(X7))  return GOF(X7);
+   if (o >= GOF(X8)  && o + sz <= GOF(X8)  + SZB(X8))  return GOF(X8);
+   if (o >= GOF(X9)  && o + sz <= GOF(X9)  + SZB(X9))  return GOF(X9);
+   if (o >= GOF(X10) && o + sz <= GOF(X10) + SZB(X10)) return GOF(X10);
+   if (o >= GOF(X11) && o + sz <= GOF(X11) + SZB(X11)) return GOF(X11);
+   if (o >= GOF(X12) && o + sz <= GOF(X12) + SZB(X12)) return GOF(X12);
+   if (o >= GOF(X13) && o + sz <= GOF(X13) + SZB(X13)) return GOF(X13);
+   if (o >= GOF(X14) && o + sz <= GOF(X14) + SZB(X14)) return GOF(X14);
+   if (o >= GOF(X15) && o + sz <= GOF(X15) + SZB(X15)) return GOF(X15);
+   if (o >= GOF(X16) && o + sz <= GOF(X16) + SZB(X16)) return GOF(X16);
+   if (o >= GOF(X17) && o + sz <= GOF(X17) + SZB(X17)) return GOF(X17);
+   if (o >= GOF(X18) && o + sz <= GOF(X18) + SZB(X18)) return GOF(X18);
+   if (o >= GOF(X19) && o + sz <= GOF(X19) + SZB(X19)) return GOF(X19);
+   if (o >= GOF(X20) && o + sz <= GOF(X20) + SZB(X20)) return GOF(X20);
+   if (o >= GOF(X21) && o + sz <= GOF(X21) + SZB(X21)) return GOF(X21);
+   if (o >= GOF(X22) && o + sz <= GOF(X22) + SZB(X22)) return GOF(X22);
+   if (o >= GOF(X23) && o + sz <= GOF(X23) + SZB(X23)) return GOF(X23);
+   if (o >= GOF(X24) && o + sz <= GOF(X24) + SZB(X24)) return GOF(X24);
+   if (o >= GOF(X25) && o + sz <= GOF(X25) + SZB(X25)) return GOF(X25);
+   if (o >= GOF(X26) && o + sz <= GOF(X26) + SZB(X26)) return GOF(X26);
+   if (o >= GOF(X27) && o + sz <= GOF(X27) + SZB(X27)) return GOF(X27);
+   if (o >= GOF(X28) && o + sz <= GOF(X28) + SZB(X28)) return GOF(X28);
+   if (o >= GOF(X29) && o + sz <= GOF(X29) + SZB(X29)) return GOF(X29);
+   if (o >= GOF(X30) && o + sz <= GOF(X30) + SZB(X30)) return GOF(X30);
+   if (o >= GOF(X31) && o + sz <= GOF(X31) + SZB(X31)) return GOF(X31);
+
+   if (o == GOF(FCC0) && sz == 1) return -1;  /* slot unused */
+   if (o == GOF(FCC1) && sz == 1) return -1;  /* slot unused */
+   if (o == GOF(FCC2) && sz == 1) return -1;  /* slot unused */
+   if (o == GOF(FCC3) && sz == 1) return -1;  /* slot unused */
+   if (o == GOF(FCC4) && sz == 1) return -1;  /* slot unused */
+   if (o == GOF(FCC5) && sz == 1) return -1;  /* slot unused */
+   if (o == GOF(FCC6) && sz == 1) return -1;  /* slot unused */
+   if (o == GOF(FCC7) && sz == 1) return -1;  /* slot unused */
+   if (o == GOF(FCSR) && sz == 4) return -1;  /* slot unused */
+
+   if (o == GOF(EMNOTE) && sz == 4) return -1;  /* slot unused */
+
+   if (o == GOF(CMSTART) && sz == 8) return -1;  /* slot unused */
+   if (o == GOF(CMLEN)   && sz == 8) return -1;  /* slot unused */
+
+   if (o == GOF(NRADDR)  && sz == 8) return -1;  /* slot unused */
+
+   if (o == GOF(LLSC_SIZE) && sz == 8) return -1;  /* slot unused */
+   if (o == GOF(LLSC_ADDR) && sz == 8) return -1;  /* slot unused */
+   if (o == GOF(LLSC_DATA) && is48)    return -1;  /* slot unused */
+
+   VG_(printf)("MC_(get_otrack_shadow_offset)(loongarch64)(off=%d,sz=%d)\n",
+               offset,szB);
+   tl_assert(0);
+#  undef GOF
 #  undef SZB
 
 #  else
@@ -1517,6 +1629,13 @@ IRType MC_(get_otrack_reg_array_equiv_int_type) ( IRRegArray* arr )
    VG_(printf)("\n");
    tl_assert(0);
 
+   /* ----------------- loongarch64 ----------------- */
+#  elif defined(VGA_loongarch64)
+   VG_(printf)("get_reg_array_equiv_int_type(loongarch64): unhandled: ");
+   ppIRRegArray(arr);
+   VG_(printf)("\n");
+   tl_assert(0);
+
 #  else
 #    error "FIXME: not implemented for this architecture"
 #  endif
diff --git a/memcheck/mc_translate.c b/memcheck/mc_translate.c
index 52d1939a8..1f0396b6e 100644
--- a/memcheck/mc_translate.c
+++ b/memcheck/mc_translate.c
@@ -8781,6 +8781,9 @@ IRSB* MC_(instrument) ( VgCallbackClosure* closure,
       mce.dlbo.dl_CmpEQ64_CmpNE64 = DLexpensive;
 #     elif defined(VGA_arm)
       mce.dlbo.dl_CmpEQ32_CmpNE32 = DLexpensive;
+#     elif defined(VGA_loongarch64)
+      mce.dlbo.dl_CmpEQ32_CmpNE32 = DLexpensive;
+      mce.dlbo.dl_CmpEQ64_CmpNE64 = DLexpensive;
 #     endif
 
       /* preInstrumentationAnalysis() will allocate &mce.tmpHowUsed and then
diff --git a/memcheck/tests/atomic_incs.c b/memcheck/tests/atomic_incs.c
index 1c738c530..83deeafca 100644
--- a/memcheck/tests/atomic_incs.c
+++ b/memcheck/tests/atomic_incs.c
@@ -245,6 +245,9 @@ __attribute__((noinline)) void atomic_add_8bit ( char* p, int n )
       );
    } while (block[2] != 1);
 #endif
+#elif defined(VGA_loongarch64)
+   /* TODO */
+   assert(0);
 #else
 # error "Unsupported arch"
 #endif
@@ -461,6 +464,9 @@ __attribute__((noinline)) void atomic_add_16bit ( short* p, int n )
       );
    } while (block[2] != 1);
 #endif
+#elif defined(VGA_loongarch64)
+   /* TODO */
+   assert(0);
 #else
 # error "Unsupported arch"
 #endif
@@ -616,6 +622,9 @@ __attribute__((noinline)) void atomic_add_32bit ( int* p, int n )
          : /*trash*/ "memory", "t0", "t1", "t2", "t3"
       );
    } while (block[2] != 1);
+#elif defined(VGA_loongarch64)
+   /* TODO */
+   assert(0);
 #else
 # error "Unsupported arch"
 #endif
@@ -718,6 +727,9 @@ __attribute__((noinline)) void atomic_add_64bit ( long long int* p, int n )
          : /*trash*/ "memory", "t0", "t1", "t2", "t3"
       );
    } while (block[2] != 1);
+#elif defined(VGA_loongarch64)
+   /* TODO */
+   assert(0);
 #else
 # error "Unsupported arch"
 #endif
@@ -731,7 +743,8 @@ __attribute__((noinline)) void atomic_add_128bit ( MyU128* p,
     || defined(VGA_amd64) \
     || defined(VGA_ppc64be) || defined(VGA_ppc64le) \
     || defined(VGA_arm) \
-    || defined(VGA_s390x)
+    || defined(VGA_s390x) \
+    || defined(VGA_loongarch64)
    /* do nothing; is not supported */
 #elif defined(VGA_arm64)
    unsigned long long int block[3]
diff --git a/memcheck/tests/unit_libcbase.c b/memcheck/tests/unit_libcbase.c
index 0ce65be26..48036033e 100644
--- a/memcheck/tests/unit_libcbase.c
+++ b/memcheck/tests/unit_libcbase.c
@@ -9,14 +9,14 @@
 #include "pub_tool_vki.h"
 #include "m_libcbase.c"
 
-/* On PPC, MIPS and ARM64 Linux VKI_PAGE_SIZE is a variable, not a macro. */
+/* On PPC, MIPS, ARM64 and LOONGARCH64 Linux VKI_PAGE_SIZE is a variable, not a macro. */
 #if defined(VGP_ppc32_linux) || defined(VGP_ppc64be_linux) \
     || defined(VGP_ppc64le_linux)
 unsigned long VKI_PAGE_SIZE  = 1UL << 12;
 #elif defined(VGP_arm64_linux)
 unsigned long VKI_PAGE_SIZE  = 1UL << 16;
 #elif defined(VGP_mips32_linux) || defined(VGP_mips64_linux) \
-    || defined (VGP_nanomips_linux)
+    || defined (VGP_nanomips_linux) || defined(VGP_loongarch64_linux)
 #include <unistd.h>
 unsigned long VKI_PAGE_SIZE;
 #endif
diff --git a/none/tests/libvex_test.c b/none/tests/libvex_test.c
index 5b57a4c2e..3080ce667 100644
--- a/none/tests/libvex_test.c
+++ b/none/tests/libvex_test.c
@@ -76,6 +76,8 @@ __attribute__((noinline)) static void get_guest_arch(VexArch    *ga)
    *ga = VexArchMIPS64;
 #elif defined(VGA_nanomips)
    *ga = VexArchNANOMIPS;
+#elif defined(VGA_loongarch64)
+   *ga = VexArchLOONGARCH64;
 #else
    missing arch;
 #endif
@@ -113,6 +115,7 @@ static VexEndness arch_endness (VexArch va) {
          else
             return VexEndnessBE;
       }
+   case VexArchLOONGARCH64: return VexEndnessLE;
    default: failure_exit();
    }
 }
@@ -139,6 +142,7 @@ static UInt arch_hwcaps (VexArch va) {
    case VexArchMIPS64: return VEX_PRID_COMP_MIPS | VEX_MIPS_HOST_FR;
 #endif
    case VexArchNANOMIPS: return 0;
+   case VexArchLOONGARCH64: return VEX_HWCAPS_LOONGARCH_ISA_64BIT;
    default: failure_exit();
    }
 }
@@ -156,6 +160,7 @@ static Bool mode64 (VexArch va) {
    case VexArchMIPS32: return False;
    case VexArchMIPS64: return True;
    case VexArchNANOMIPS: return False;
+   case VexArchLOONGARCH64: return True;
    default: failure_exit();
    }
 }
@@ -275,7 +280,7 @@ int main(int argc, char **argv)
    // explicitly via command line arguments.
    if (multiarch) {
       VexArch va;
-      for (va = VexArchX86; va <= VexArchNANOMIPS; va++) {
+      for (va = VexArchX86; va <= VexArchLOONGARCH64; va++) {
          vta.arch_host = va;
          vta.archinfo_host.endness = arch_endness (vta.arch_host);
          vta.archinfo_host.hwcaps = arch_hwcaps (vta.arch_host);
diff --git a/tests/Makefile.am b/tests/Makefile.am
index 86c81b315..31003d185 100644
--- a/tests/Makefile.am
+++ b/tests/Makefile.am
@@ -54,7 +54,8 @@ check_PROGRAMS = \
 	power_insn_available \
 	is_ppc64_BE \
 	min_power_isa \
-	arm64_features
+	arm64_features \
+	loongarch64_features
 
 
 AM_CFLAGS   += $(AM_FLAG_M3264_PRI)
diff --git a/tests/arch_test.c b/tests/arch_test.c
index 37cc1bc76..97b6bc7c8 100644
--- a/tests/arch_test.c
+++ b/tests/arch_test.c
@@ -34,6 +34,7 @@ char* all_archs[] = {
    "mips32",
    "mips64",
    "nanomips",
+   "loongarch64",
    NULL
 };
 
@@ -79,6 +80,10 @@ static Bool go(char* arch)
 
 #elif defined(VGP_nanomips_linux)
    if ( 0 == strcmp( arch, "nanomips" ) ) return True;
+
+#elif defined(VGP_loongarch64_linux)
+   if ( 0 == strcmp( arch, "loongarch64" ) ) return True;
+
 #else
 #  error Unknown platform
 #endif   // VGP_*
diff --git a/tests/loongarch64_features.c b/tests/loongarch64_features.c
new file mode 100644
index 000000000..45ba2d1c0
--- /dev/null
+++ b/tests/loongarch64_features.c
@@ -0,0 +1,81 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+// This file determines loongarch64 features a processor supports.
+// For now, we only support loongarch64-linux.
+//
+// We return:
+// - 0 if the machine has the asked-for feature.
+// - 1 if the machine doesn't have the asked-for feature.
+// - 2 if the asked-for feature isn't recognised (this will always be the case
+//     for any feature if run on a non-loongarch64 machine).
+// - 3 if there was a usage error (it also prints an error message).
+#define FEATURE_PRESENT       0
+#define FEATURE_NOT_PRESENT   1
+#define UNRECOGNISED_FEATURE  2
+#define USAGE_ERROR           3
+
+#if defined(VGA_loongarch64)
+
+static int go(const char* feature_name)
+{
+   int i, len, found;
+   FILE* fp;
+   char buf[256];
+   const char* features[] = {
+      "cpucfg", "lam", "ual", "fpu",
+      "lsx", "lasx", "complex", "crypto",
+      "lvz", "lbt_x86", "lbt_arm", "lbt_mips"
+   };
+
+   found = 0;
+   len = sizeof(features) / sizeof(features[0]);
+   for (i = 0; i < len; i++) {
+      if (strcmp(feature_name, features[i]) == 0) {
+         found = 1;
+         break;
+      }
+   }
+
+   if (!found)
+      return UNRECOGNISED_FEATURE;
+
+   fp = fopen("/proc/cpuinfo", "r");
+   if(fp == NULL)
+      return UNRECOGNISED_FEATURE;
+
+   while (fgets(buf, sizeof(buf), fp) != NULL) {
+      if (strstr(buf, feature_name) != NULL) {
+         fclose(fp);
+         return FEATURE_PRESENT;
+      }
+   }
+
+   fclose(fp);
+   return FEATURE_NOT_PRESENT;
+}
+
+#else
+
+static int go(const char* feature_name)
+{
+   // Feature not recognised (non-loongarch64 machine!)
+   return UNRECOGNISED_FEATURE;
+}
+
+#endif // defined(VGA_loongarch64)
+
+
+//---------------------------------------------------------------------------
+// main
+//---------------------------------------------------------------------------
+int main(int argc, char **argv)
+{
+   if (argc != 2) {
+      fprintf(stderr, "usage: loongarch64_features <feature>\n");
+      exit(USAGE_ERROR);
+   }
+
+   return go(argv[1]);
+}
diff --git a/tests/platform_test b/tests/platform_test
index c23a4f645..a1eaf8f1c 100644
--- a/tests/platform_test
+++ b/tests/platform_test
@@ -14,6 +14,7 @@ all_platforms=
 all_platforms="$all_platforms x86-linux amd64-linux ppc32-linux ppc64-linux"
 all_platforms="$all_platforms arm-linux arm64-linux"
 all_platforms="$all_platforms s390x-linux mips32-linux mips64-linux"
+all_platforms="$all_platforms loongarch64-linux"
 all_platforms="$all_platforms x86-darwin amd64-darwin"
 all_platforms="$all_platforms x86-solaris amd64-solaris"
 all_platforms="$all_platforms x86-freebsd amd64-freebsd"
-- 
2.45.2

