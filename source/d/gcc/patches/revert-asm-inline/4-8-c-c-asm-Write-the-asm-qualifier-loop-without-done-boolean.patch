From patchwork Thu Dec 27 14:59:09 2018
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Subject: [4/8] c/c++, asm: Write the asm-qualifier loop without "done" boolean
X-Patchwork-Submitter: Segher Boessenkool <segher@kernel.crashing.org>
X-Patchwork-Id: 13821
Message-Id: <5bbbd04162b8546d9c72da11cf33e6e61d1128d7.1545922222.git.segher@kernel.crashing.org>
To: gcc-patches@gcc.gnu.org
Cc: Segher Boessenkool <segher@kernel.crashing.org>
Date: Thu, 27 Dec 2018 14:59:09 +0000
From: Segher Boessenkool <segher@kernel.crashing.org>
List-Id: <gcc-patches.gcc.gnu.org>

As suggested by Jason.

Segher

2018-12-10  Segher Boessenkool  <segher@kernel.crashing.org>

c/
	* c-parser.c (c_parser_asm_statement): Rewrite the loop to work without
	"done" boolean variable.

cp/
	* parser.c (cp_parser_asm_definition): Rewrite the loop to work without
	"done" boolean variable.
---
 gcc/c/c-parser.c | 65 +++++++++++++++++++++++++--------------------------
 gcc/cp/parser.c  | 71 +++++++++++++++++++++++++-------------------------------
 2 files changed, 62 insertions(+), 74 deletions(-)

-- 
1.8.3.1

diff --git a/gcc/c/c-parser.c b/gcc/c/c-parser.c
index e45f70b..b632f68 100644
--- a/gcc/c/c-parser.c
+++ b/gcc/c/c-parser.c
@@ -6304,40 +6304,37 @@ c_parser_asm_statement (c_parser *parser)
   is_volatile = false;
   is_inline = false;
   is_goto = false;
-  for (bool done = false; !done; )
-    switch (c_parser_peek_token (parser)->keyword)
-      {
-      case RID_VOLATILE:
-	if (!is_volatile)
-	  {
-	    is_volatile = true;
-	    quals = c_parser_peek_token (parser)->value;
-	    c_parser_consume_token (parser);
-	  }
-	else
-	  done = true;
-	break;
-      case RID_INLINE:
-	if (!is_inline)
-	  {
-	    is_inline = true;
-	    c_parser_consume_token (parser);
-	  }
-	else
-	  done = true;
-	break;
-      case RID_GOTO:
-	if (!is_goto)
-	  {
-	    is_goto = true;
-	    c_parser_consume_token (parser);
-	  }
-	else
-	  done = true;
-	break;
-      default:
-	done = true;
-      }
+  for (;;)
+    {
+      switch (c_parser_peek_token (parser)->keyword)
+	{
+	case RID_VOLATILE:
+	  if (is_volatile)
+	    break;
+	  is_volatile = true;
+	  quals = c_parser_peek_token (parser)->value;
+	  c_parser_consume_token (parser);
+	  continue;
+
+	case RID_INLINE:
+	  if (is_inline)
+	    break;
+	  is_inline = true;
+	  c_parser_consume_token (parser);
+	  continue;
+
+	case RID_GOTO:
+	  if (is_goto)
+	    break;
+	  is_goto = true;
+	  c_parser_consume_token (parser);
+	  continue;
+
+	default:
+	  break;
+	}
+      break;
+    }
 
   /* ??? Follow the C++ parser rather than using the
      lex_untranslated_string kludge.  */
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index 3fd9a02..7660565 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -19124,47 +19124,38 @@ cp_parser_asm_definition (cp_parser* parser)
       cp_function_chain->invalid_constexpr = true;
     }
 
-  /* See if the next token is `volatile'.  */
+  /* Handle the asm-qualifier-list.  */
   if (cp_parser_allow_gnu_extensions_p (parser))
-    for (bool done = false; !done ; )
-      switch (cp_lexer_peek_token (parser->lexer)->keyword)
-	{
-	case RID_VOLATILE:
-	  if (!volatile_p)
-	    {
-	      /* Remember that we saw the `volatile' keyword.  */
-	      volatile_p = true;
-	      /* Consume the token.  */
-	      cp_lexer_consume_token (parser->lexer);
-	    }
-	  else
-	    done = true;
-	  break;
-	case RID_INLINE:
-	  if (!inline_p && parser->in_function_body)
-	    {
-	      /* Remember that we saw the `inline' keyword.  */
-	      inline_p = true;
-	      /* Consume the token.  */
-	      cp_lexer_consume_token (parser->lexer);
-	    }
-	  else
-	    done = true;
-	  break;
-	case RID_GOTO:
-	  if (!goto_p && parser->in_function_body)
-	    {
-	      /* Remember that we saw the `goto' keyword.  */
-	      goto_p = true;
-	      /* Consume the token.  */
-	      cp_lexer_consume_token (parser->lexer);
-	    }
-	  else
-	    done = true;
-	  break;
-	default:
-	  done = true;
-	}
+    for (;;)
+      {
+	switch (cp_lexer_peek_token (parser->lexer)->keyword)
+	  {
+	  case RID_VOLATILE:
+	    if (volatile_p)
+	      break;
+	    volatile_p = true;
+	    cp_lexer_consume_token (parser->lexer);
+	    continue;
+
+	  case RID_INLINE:
+	    if (inline_p || !parser->in_function_body)
+	      break;
+	    inline_p = true;
+	    cp_lexer_consume_token (parser->lexer);
+	    continue;
+
+	  case RID_GOTO:
+	    if (goto_p || !parser->in_function_body)
+	      break;
+	    goto_p = true;
+	    cp_lexer_consume_token (parser->lexer);
+	    continue;
+
+	  default:
+	    break;
+	  }
+	break;
+      }
 
   /* Look for the opening `('.  */
   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))
