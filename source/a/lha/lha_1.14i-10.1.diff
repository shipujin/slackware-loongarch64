--- lha-1.14i.orig/src/lha_macro.h
+++ lha-1.14i/src/lha_macro.h
@@ -7,7 +7,7 @@
 /*	Ver. 1.14g	modified   						2000.05.06	T.OKAMOTO		*/
 /* ------------------------------------------------------------------------ */
 
-#define LHA_VERSION "lha for unix version 1.14g"
+#define LHA_VERSION "lha for unix version 1.14i"
 
 /* Most of System V, define SYSTIME_HAS_NO_TM */
 #ifdef	SYSTIME_HAS_NO_TM
--- lha-1.14i.orig/man/lha.n
+++ lha-1.14i/man/lha.n
@@ -9,7 +9,7 @@
 ]
 .I archive_file
 [
-.I flie
+.I file
 \&.\|.\|. ]
 .br
 .B lha
--- lha-1.14i.orig/man/lha.man
+++ lha-1.14i/man/lha.man
@@ -1,324 +1,224 @@
+LHA(N)                     LHa for UNIX Users Manual                    LHA(N)
 
 
-LHA(N)              Unix Programmer's Manual               LHA(N)
 
+NNAAMMEE 名名称称
+       LHa - 高圧縮アーカイバ
 
-NNNAAAMMMEEE 名名名称称称
-     LHa - 高圧縮アーカイバ
+SSYYNNOOPPSSIISS 形形式式
+       llhhaa kkeeyy [ mmooddiiffiieerrss ] _a_r_c_h_i_v_e___f_i_l_e [ _f_i_l_e ... ]
+       llhhaa _a_r_c_h_i_v_e___f_i_l_e
 
-SSSYYYNNNOOOPPPSSSIIISSS 形形形式式式
-     lllhhhaaa kkkeeeyyy [ mmmooodddiiifffiiieeerrrsss ] _a_r_c_h_i_v_e__f_i_l_e [ _f_l_i_e ... ]
-     lllhhhaaa _a_r_c_h_i_v_e__f_i_l_e
+DDEESSCCRRIIPPTTIIOONN 解解説説
+       LLHHaa は効率の高い圧縮機能を持つファイルアーカイバです。
+       kkeeyy に機能文字を指定し、file の追加、更新、抽出、削除、一覧表示などを行
+       ないます。引数に archive_file のみを指定した場合には、機能文字に l を指
+       定したのと同等の動作を行ないます。
+       機能文字は以下の通りです。
 
-DDDEEESSSCCCRRRIIIPPPTTTIIIOOONNN 解解解説説説
-     LLLHHHaaa は効率の高い圧縮機能を持つファイルアーカイバです。
-     kkkeeeyyy  に機能文字を指定し、file   の追加、更新、抽出、削除、一
-     覧表示などを行ないます。引数に  archive_file  のみを指定した
-     場合には、機能文字に  l   を指定したのと同等の動作を行ないま
-     す。
-     機能文字は以下の通りです。
+       aa       追加。file を archive_file に追加します。 file がディレクトリで
+               あれば、そのディレクトリに含まれるファイルをすべて追加します。
 
-     aaa       追加。file を archive_file  に追加します。file  がデ
-             ィレクトリであれば、そのディレクトリに含まれるファ
-             イルをすべて追加します。
+       uu       更新。file が archive_file に格納されていないか、もしくは格納さ
+               れているものが古ければ、file を archive_file に追加します。
 
-     uuu       更新。file  が  archive_file  に格納されていないか、
-             もしくは格納されているものが古ければ、file        を
-             archive_file に追加します。
+       ll ままたたはは vv
+               一覧表示。archive_file に格納されている file の情報を一覧表示し
+               ます。file の指定がなければ archive_file 内の全てのファイルの情
+               報 を 表 示します。 v を指定すると l よりも詳しい情報を表示しま
+               す。
 
-     lll まままたたたははは vvv
-             一覧表示。archive_file  に格納されている  file  の情
-             報を一覧表示します。file            の指定がなければ
-             archive_file    内の全てのファイルの情報を表示します
-             。v を指定すると l よりも詳しい情報を表示します。
+       xx ままたたはは ee
+               抽出。archive_file から file を抽出します。file の指定がなけ れ
+               ば  archive_file 内の全てのファイルを抽出します。抽出すべきファ
+               イルがすでに存在している場合には、重ね書きしていいかの問い合 わ
+               せを行ないます。
 
-     xxx まままたたたははは eee
-             抽出。archive_file から file  を抽出します。file  の
-             指定がなければ  archive_file  内の全てのファイルを抽
-             出します。抽出すべきファイルがすでに存在している場
-             合には、重ね書きしていいかの問い合わせを行ないます
-             。
+       pp       内容表示。archive_file から file の内容を取り出し、標準出力へと
+               出力します。file の指定がなければ、全ての内容を出力します。
 
-     ppp       内容表示。archive_file  から  file  の内容を取り出し
-             、標準出力へと出力します。file    の指定がなければ、
-             全ての内容を出力します。
+       dd       削除。archive_file から file を削除します。
 
-     ddd       削除。archive_file から file を削除します。
+       mm       移動。file を archive_file に追加した後、file を削除します。 こ
+               れ は、key に a を、modifiers に d を指定した時と同じ動作を行な
+               います。
 
-     mmm       移動。file を archive_file  に追加した後、file  を削
-             除します。これは、key  に  a を、modifiers に d を指
-             定した時と同じ動作を行ないます。
+       cc       新規作成。archive_file を新たに作成し、file を追加します。
 
+       機能変更文字 modifiers を指定することによって key の動作の詳細を変更 す
+       る こ と ができます。modifiers は、以下の中から複数指定することができま
+       す。
 
-                        January 14,1997                         1
 
 
+       qq<<nnuumm>>  表示の抑制。対話的なメッセージの表示を抑制します。 <num> の値に
+               よって、INDICATOR の表示方法を変更できます。
 
-LHA(N)              Unix Programmer's Manual               LHA(N)
+                      qq00 oooo........ のの表表示示をを行行ななうう。。
 
+                      qq11 フファァイイルル名名表表示示ののみみ行行ななうう。。
 
-     ccc       新規作成。archive_file  を新たに作成し、file  を追加
-             します。
+                      qq22 何何もも表表示示ししなないい。。
 
-     機能変更文字 modifiers を指定することによって  key  の動作の
-     詳細を変更することができます。modifiers   は、以下の中から複
-     数指定することができます。
+               なお、値を入力しなかった際には、q2 と同等になります。
 
+       vv       表示の冗長化。表示するメッセージを冗長にします。
 
+       nn        実行しない。実際の更新や抽出の動作を行ないません。実行内容の確
+               認のために用意されています。
 
-     qqq<<<nnnuuummm>>>  表示の抑制。対話的なメッセージの表示を抑制します。
-             <num>  の値によって、INDICATOR  の表示方法を変更でき
-             ます。
+       ff       強制的な実行。ファイルの抽出時に、存在するファイルの削除確認 を
+               行なわず強制的に削除を行ないます。
 
-             qqq000 oooooo............ ののの表表表示示示ををを行行行なななううう。。。
+       tt       テキストモードによる格納,抽出。アーカイブファイルへのファイルの
+               格納時には、 UNIX から MS-DOS への改行コード変換を行ないま す。
+               ファイルの抽出時には逆に、MS-DOS から UNIX への改行コード変換を
+               行ないます。
 
-             qqq111 フフファァァイイイルルル名名名表表表示示示のののみみみ行行行なななううう。。。
+       oo{{nnuumm}}  LHarc 互換アーカイブの生成、または圧縮アルゴリズムを指定す る。
+               機能文字 a, u, m と共に指定し、抽出時には無視されます。
 
-             qqq222 何何何ももも表表表示示示しししななないいい。。。
+                      oo LLHHaarrcc 互互換換アアーーカカイイブブのの生生成成をを行行うう。。
 
-             なお、値を入力しなかった際には、q2    と同等になりま
-             す。
+                      古 い 形 式 の アー カイブを生成します。圧縮アルゴリズム
+                      は-lh1-を使用します。
 
-     vvv       表示の冗長化。表示するメッセージを冗長にします。
+               oo55 圧圧縮縮アアルルゴゴリリズズムムにに --llhh55-- をを使使用用すするる。。
 
-     nnn       実行しない。実際の更新や抽出の動作を行ないません。
-             実行内容の確認のために用意されています。
+               oo66 圧圧縮縮アアルルゴゴリリズズムムにに --llhh66-- をを使使用用すするる。。
 
-     fff       強制的な実行。ファイルの抽出時に、存在するファイル
-             の削除確認を行なわず強制的に削除を行ないます。
+               LHAの種類によっては、-lh6-で生成されたアーカイブは抽出できな い
+               恐 れ が あるので、アーカイブを配布する際には注意してください。
+               MSDOS版の正規配布版では -lh6- の生成は行いません。また、MSDOS版
+               LHA  version  2.5x  以降のバージョンでは -lh6- の抽出のみできま
+               す。
 
-     ttt       テキストモードによる格納,抽出。アーカイブファイル
-             へのファイルの格納時には、UNIX  から  MS-DOS  への改
-             行コード変換を行ないます。ファイルの抽出時には逆に
-             、MS-DOS  から  UNIX  への改行コード変換を行ないます
-             。
+       ww==<<//ddiirr>>
+               格納および抽出時のワーク用ディレクトリ 指 定。 デ フォ ル ト で
+               は、/tmp  ですが、/tmp の大きさ以上のファイルを格納する際には必
+               要です。
 
-     ooo{{{nnnuuummm}}}  LHarc   互換アーカイブの生成、または圧縮アルゴリズム
-             を指定する。機能文字  a,  u,  m と共に指定し、抽出時
-             には無視されます。
+       dd       ファイル格納後のファイルの削除。機能文字 a, もしくは u と共に用
+               い、 アーカイブファイルへのファイルの格納の後にファイルを削除し
+               ます。 u に付加した場合、アーカイブファイルの内容の方が新しい時
+               に ファ イ ルが格納されずに削除されることになるので注意して下さ
+               い。
 
-             ooo LLLHHHaaarrrccc 互互互換換換アアアーーーカカカイイイブブブののの生生生成成成ををを行行行ううう。。。
+       ii       抽出時のディレクトリ名の無効化。抽出時にディレクトリ名を無効 に
+               します。
 
-                  古い形式のアーカイブを生成します。圧縮アルゴ
-                  リズムは-lh1-を使用します。
+       zz        非 圧 縮格納。アーカイブへのファイルの格納時に圧縮を行ないませ
+               ん。すでに圧縮を行なっていて圧縮効率を望めない場合などに使用 し
+               ます。抽出時には無視されます。
 
+       gg       [generic]アーカイブの作成。 UNIX 用の付加情報を持たないアーカイ
+               ブファイルを生成します。抽出時には無視されます。
 
+       00//11//22   ヘッダレベル指定。アーカイブの内部表現の形式を指定し ま す。 デ
+               フォ ルトでは 1 です。0 は LHarc で用意されていた古い形式です。
+               将来は 2 の形式に統一されるようです。これはファイルの格納時のみ
+               有効です。ファイルの抽出時には自動的に形式を判断し処理します。
 
-                        January 14,1997                         2
+       _a_r_c_h_i_v_e___f_i_l_e にはアーカイブファイルを指定します。
 
+       _a_r_c_h_i_v_e___f_i_l_e  に _- と書くことによって、アーカイブファイルを標準入出力に
+       することが可能です。 ttaarr(1) のように、アーカイブの作成、更新時には標 準
+       出力に、アーカイブからのファイルの抽出時には標準入力になります。
 
+       抽 出時に _a_r_c_h_i_v_e___f_i_l_e が存在しない時にはサフィックス ..llzzhh をファイル名
+       の後ろに付加して抽出を試みます。
+       特に規定はありませんが、運用上サフィックスとして ..llzzhh を用いるのが望 ま
+       し いと思います。日本以外では ..llhhaa を使用しているケースがあるそうですの
+       で、適宜調整して下さい。:-)
+       サフィックスが ccoomm もしくは ..eexxee の場合には、MS-DOS 版で作成された _S_F_X(
+       自己展開機能付きの圧縮ファイル) 形式かどうかをチェックし、対応します。
+       サ フィックスが ..xx の場合には、日本製 SHARP X68000 の OS, Human68k 版で
+       作成された SFX 形式かどうかをチェックし対応します。
+       SFX 形式のアーカイブファイルに対して追加や削除を行った 場 合 に は、 サ
+       フィックスを ..llzzhh に変更し、SFX の情報を削除します。
 
-LHA(N)              Unix Programmer's Manual               LHA(N)
 
+FFIILLEESS フファァイイルル
+       *.lzh          - LHa/LHarc アーカイブファイル
+       *.bak          - バックアップファイル
+       /tmp/lh*       - テンポラリファイル
+       *.com *.exe    - MS-DOS SFX ファイル
+       *.x            - Human68k SFX ファイル
 
-             ooo555 圧圧圧縮縮縮アアアルルルゴゴゴリリリズズズムムムににに ---lllhhh555- ををを使使使用用用すすするるる。。。
 
-             ooo666 圧圧圧縮縮縮アアアルルルゴゴゴリリリズズズムムムににに ---lllhhh666- ををを使使使用用用すすするるる。。。
+SSEEEE AALLSSOO 関関連連項項目目
+       ttaarr(1), aarr(1), ccoommpprreessss(1)
 
-             LHAの種類によっては、-lh6-で生成されたアーカイブは
-             抽出できない恐れがあるので、アーカイブを配布する際
-             には注意してください。MSDOS版の正規配布版では  -lh6-
-             の生成は行いません。また、MSDOS版  LHA  version 2.5x
-             以降のバージョンでは -lh6- の抽出のみできます。
+DDIISSTTRRIIBBUUTTIIOONN 再再配配布布ににつついいてて
+       以下の条件で、再配布、転載、改変を許可します。
 
-     www===<<<///dddiiirrr>>>
-             格納および抽出時のワーク用ディレクトリ指定。デフォ
-             ルトでは、/tmp  ですが、/tmp  の大きさ以上のファイル
-             を格納する際には必要です。
+       1.     著作権表示を削除しないこと。
 
-     ddd       ファイル格納後のファイルの削除。機能文字  a,  もしく
-             は   u  と共に用い、アーカイブファイルへのファイルの
-             格納の後にファイルを削除します。u   に付加した場合、
-             アーカイブファイルの内容の方が新しい時にファイルが
-             格納されずに削除されることになるので注意して下さい
-             。
+       2.     配布内容については、
 
-     iii       抽出時のディレクトリ名の無効化。抽出時にディレクト
-             リ名を無効にします。
+              a.      配 布の際に存在する内容(すなわちソースコード、ドキュメン
+                     ト、プログラマーへの手引きなど)が再配布されたものの中に必
+                     ず 存 在 すること。改変されているならば、それを明示したド
+                     キュメントを用意すること。
 
-     zzz       非圧縮格納。アーカイブへのファイルの格納時に圧縮を
-             行ないません。すでに圧縮を行なっていて圧縮効率を望
-             めない場合などに使用します。抽出時には無視されます
-             。
+              b.     LHa に対する付加価値が付けられて再配布される場合にはそ れ
+                     ら もできるだけ含めるよう努力すること。また、その際には付
+                     加価値が付けられていることを明示したドキュメントを用意 す
+                     ること。
 
-     ggg       [generic]アーカイブの作成。UNIX   用の付加情報を持た
-             ないアーカイブファイルを生成します。抽出時には無視
-             されます。
+              c.     バイナリのみの配布は許されない。(付加価値のものも含む)
 
-     000///111///222   ヘッダレベル指定。アーカイブの内部表現の形式を指定
-             します。デフォルトでは 1 です。0 は  LHarc  で用意さ
-             れていた古い形式です。将来は   2  の形式に統一される
-             ようです。これはファイルの格納時のみ有効です。ファ
-             イルの抽出時には自動的に形式を判断し処理します。
+       3.     最新版の配布に務めること。(義務はない)
 
-     _a_r_c_h_i_v_e__f_i_l_e にはアーカイブファイルを指定します。
+              注.     なお、ネットでの配付は自由であるが、ネットにアクセスでき
+                     ない方（雑誌および、 CD-ROM などによる）配付は、配付前 に
+                     こ ちらに E-Mail をお願いします。配付前に出来ない際には、
+                     後日必ず E-Mail をお願いします。
 
-     _a_r_c_h_i_v_e__f_i_l_e  に-   と書くことによって、アーカイブファイルを
-     標準入出力にすることが可能です。tttaaarrr(1)    のように、アーカイ
-     ブの作成、更新時には標準出力に、アーカイブからのファイルの
+       4.     このプログラムの存在や使用したことによって生じた損害は全く保証し
+              ない。
 
+       5.     作者は、このプログラムに不備があっても、それを訂正する義務を負わ
+              ない。
 
-                        January 14,1997                         3
+       6.     このプログラムの一部、または全部を他のプログラムに組み込んで利用
+              し てもかまわない。この場合、そのプログラムは LHa ではなく、 LHa
+              と名乗ってはいけない。
 
+       7.     商利用に関しては、上記の条件に加え、下記の条件のもとにこれを認め
+              る。
 
+              a.     このプログラムをメインとする商利用は禁止する。
 
-LHA(N)              Unix Programmer's Manual               LHA(N)
+              b.      商利用の相手がこのプログラムの使用者として不適切と判断し
+                     た場合には配布しない。
 
+              c.     インストールの手段として使用する場合、このプログラムを 使
+                     う こ と を相手に強制しない。この場合、商利用者が作業を行
+                     う。また、そのときの損害は、商利用者が全責任を負う。
 
-     抽出時には標準入力になります。
+              d.     商利用を付加価値として行いこのプログラムを使用する場 合、
+                     商利用者は、そのサポートを行う。
 
-     抽出時に_a_r_c_h_i_v_e__f_i_l_e  が存在しない時にはサフィックス...lllzzzhhh  を
-     ファイル名の後ろに付加して抽出を試みます。
-     特に規定はありませんが、運用上サフィックスとして...lllzzzhhh    を用
-     いるのが望ましいと思います。日本以外では  ...lllhhhaaa  を使用してい
-     るケースがあるそうですので、適宜調整して下さい。:-)
-     サフィックスがcccooommm もしくは...eeexxxeee  の場合には、MS-DOS  版で作成
-     された_S_F_X(自己展開機能付きの圧縮ファイル)   形式かどうかをチ
-     ェックし、対応します。
-     サフィックスが...xxx  の場合には、日本製  SHARP  X68000  の  OS,
-     Human68k  版で作成された  SFX 形式かどうかをチェックし対応し
-     ます。
-     SFX   形式のアーカイブファイルに対して追加や削除を行った場合
-     には、サフィックスを...lllzzzhhh   に変更し、SFX  の情報を削除します
-     。
 
-FFFIIILLLEEESSS フフファァァイイイルルル
-     *.lzh          - LHa/LHarc アーカイブファイル
-     *.bak          - バックアップファイル
-     /tmp/lh*       - テンポラリファイル
-     *.com *.exe    - MS-DOS SFX ファイル
-     *.x            - Human68k SFX ファイル
+最最後後にに((FFrroomm YY..TTaaggaawwaa))
+       LZHUF   法の基礎となった LZARI 法を発表してくださった奥村晴彦氏、それを
+       NIFTY-Serve に紹介し、また、LArc の作者でもある三木和彦氏、また、これら
+       の 要 因 から LZHUF 法及び、MS-DOS 版 LHarc を作成した吉崎栄泰氏、LHarc
+       UNIX の開発に協力した人達、こころよくメッセージの橋渡しをしてくれた石崎
+       一明氏(MIX ID:k.ishi)、また、いろいろなレポートをくれたみなさん、それを
+       中継してくださった森公一郎氏 (MIX ID:kmori)に感謝します。
 
-SSSEEEEEE AAALLLSSSOOO 関関関連連連項項項目目目
-     tttaaarrr(1), aaarrr(1), cccooommmppprrreeessssss(1)
 
-DDDIIISSSTTTRRRIIIBBBUUUTTTIIIOOONNN 再再再配配配布布布にににつつついいいててて
+最最後後にに((FFrroomm MMaassaarruu OOkkii))
+       上記の方々はもちろん、加えて LHarc UNIX を作成した Y.Tagawa 氏、それ を
+       OSK   に移植し吉崎氏の LHx のアルゴリズムを組み込んだ H.S 氏、 JUNET の
+       LHa for UNIX MailingList にて協力してくださったみなさんに感謝致します。
 
-     以下の条件で、再配布、転載、改変を許可します。
+最最後後にに((FFrroomm NNoobbuuttaakkaa WWaattaazzaakkii))
+       このプログラムの作成にかかわった方々、さらにここまで LHa を仕上げてくだ
+       さった 沖勝氏に感謝致します。
 
-     1.      著作権表示を削除しないこと。
 
-     2.      配布内容については、
-
-     a.      配布の際に存在する内容(すなわちソースコード、ドキ
-             ュメント、プログラマーへの手引きなど)が再配布され
-             たものの中に必ず存在すること。改変されているならば
-             、それを明示したドキュメントを用意すること。
-
-     b.      LHa   に対する付加価値が付けられて再配布される場合に
-             はそれらもできるだけ含めるよう努力すること。また、
-             その際には付加価値が付けられていることを明示したド
-             キュメントを用意すること。
-
-
-
-                        January 14,1997                         4
-
-
-
-LHA(N)              Unix Programmer's Manual               LHA(N)
-
-
-     c.      バイナリのみの配布は許されない。(付加価値のものも
-             含む)
-
-     3.      最新版の配布に務めること。(義務はない)
-
-     注.     なお、ネットでの配付は自由であるが、ネットにアクセ
-             スできない方（雑誌および、CD-ROM    などによる）配付
-             は、配付前にこちらに  E-Mail  をお願いします。配付前
-             に出来ない際には、後日必ず E-Mail をお願いします。
-
-     4.      このプログラムの存在や使用したことによって生じた損
-             害は全く保証しない。
-
-     5.      作者は、このプログラムに不備があっても、それを訂正
-             する義務を負わない。
-
-     6.      このプログラムの一部、または全部を他のプログラムに
-             組み込んで利用してもかまわない。この場合、そのプロ
-             グラムは LHa ではなく、LHa と名乗ってはいけない。
-
-     7.      商利用に関しては、上記の条件に加え、下記の条件のも
-             とにこれを認める。
-
-     a.      このプログラムをメインとする商利用は禁止する。
-
-     b.      商利用の相手がこのプログラムの使用者として不適切と
-             判断した場合には配布しない。
-
-     c.      インストールの手段として使用する場合、このプログラ
-             ムを使うことを相手に強制しない。この場合、商利用者
-             が作業を行う。また、そのときの損害は、商利用者が全
-             責任を負う。
-
-     d.      商利用を付加価値として行いこのプログラムを使用する
-             場合、商利用者は、そのサポートを行う。
-
-最最最後後後ににに(((FFFrrrooommm YYY...TTTaaagggaaawwwaaa)))
-     LZHUF  法の基礎となった  LZARI  法を発表してくださった奥村晴
-     彦氏、それを  NIFTY-Serve  に紹介し、また、LArc の作者でもあ
-     る三木和彦氏、また、これらの要因から  LZHUF   法及び、MS-DOS
-     版  LHarc  を作成した吉崎栄泰氏、LHarc UNIX の開発に協力した
-     人達、こころよくメッセージの橋渡しをしてくれた石崎一明氏(MIX
-     ID:k.ishi)、また、いろいろなレポートをくれたみなさん、それ
-     を中継してくださった森公一郎氏  (MIX   ID:kmori)に感謝します
-     。
-
-
-                        January 14,1997                         5
-
-
-
-LHA(N)              Unix Programmer's Manual               LHA(N)
-
-
-最最最後後後ににに(((FFFrrrooommm MMMaaasssaaarrruuu OOOkkkiii)))
-     上記の方々はもちろん、加えて LHarc UNIX を作成した  Y.Tagawa
-     氏、それを  OSK  に移植し吉崎氏の LHx のアルゴリズムを組み込
-     んだ H.S 氏、JUNET の LHa for  UNIX  MailingList  にて協力し
-     てくださったみなさんに感謝致します。
-
-最最最後後後ににに(((FFFrrrooommm NNNooobbbuuutttaaakkkaaa WWWaaatttaaazzzaaakkkiii)))
-     このプログラムの作成にかかわった方々、さらにここまで     LHa
-     を仕上げてくださった 沖勝氏に感謝致します。
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-                        January 14,1997                         6
 
+                                January 14,1997                         LHA(N)
--- lha-1.14i.orig/Makefile
+++ lha-1.14i/Makefile
@@ -20,7 +20,7 @@
 
 #MACHINE     = -DSYSTIME_HAS_NO_TM -DFTIME -DEUC
 #MACHINE     = -DSYSTIME_HAS_NO_TM -DEUC -DHAVE_TM_ZONE -DSYSV_SYSTEM_DIR
-MACHINE     = -DSYSTIME_HAS_NO_TM -DEUC -DSYSV_SYSTEM_DIR -DMKTIME
+MACHINE     = -DSYSTIME_HAS_NO_TM -DEUC -DSYSV_SYSTEM_DIR -DMKTIME -DMULTIBYTE_CHAR
 
 #OPTIMIZE	= -O2 -fstrength-reduce -fomit-frame-pointer
 OPTIMIZE	= -O2 -DSUPPORT_LH7 -DMKSTEMP
--- lha-1.14i.orig/debian/patch.multibyte
+++ lha-1.14i/debian/patch.multibyte
@@ -0,0 +1,145 @@
+diff -Nuar src.old/header.c src/header.c
+--- src.old/header.c	Fri Oct  6 02:36:03 2000
++++ src/header.c	Fri Jul 19 16:46:41 2002
+@@ -82,6 +82,7 @@
+ 	register int    i;
+ 
+ #ifdef MULTIBYTE_CHAR
++	if (multibyte_mode == TRUE) {
+ 	for (i = 0; i < len; i++) {
+ 		if (MULTIBYTE_FIRST_P(name[i]) &&
+ 		    MULTIBYTE_SECOND_P(name[i + 1]))
+@@ -91,6 +92,14 @@
+ 		else if (!noconvertcase && isupper(name[i]))
+ 			name[i] = tolower(name[i]);
+ 	}
++	} else {
++	for (i = 0; i < len; i++) {
++		if (name[i] == '\\')
++			name[i] = '/';
++		else if (!noconvertcase && isupper(name[i]))
++			name[i] = tolower(name[i]);
++	}
++	}
+ #else
+ 	for (i = 0; i < len; i++) {
+ 		if (name[i] == '\\')
+@@ -111,6 +120,7 @@
+ 	boolean         lower_case_used = FALSE;
+ 
+ #ifdef MULTIBYTE_CHAR
++	if (multibyte_mode == TRUE) {
+ 	for (i = 0; i < len; i++) {
+ 		if (MULTIBYTE_FIRST_P(name[i]) &&
+ 		    MULTIBYTE_SECOND_P(name[i + 1]))
+@@ -128,6 +138,19 @@
+ 			name[i] = '/';
+ 		else if (!noconvertcase && !lower_case_used && isupper(name[i]))
+ 			name[i] = tolower(name[i]);
++	}
++	} else {
++	for (i = 0; i < len; i++)
++		if (islower(name[i])) {
++			lower_case_used = TRUE;
++			break;
++		}
++	for (i = 0; i < len; i++) {
++		if (name[i] == '\\')
++			name[i] = '/';
++		else if (!noconvertcase && !lower_case_used && isupper(name[i]))
++			name[i] = tolower(name[i]);
++	}
+ 	}
+ #else
+ 	for (i = 0; i < len; i++)
+diff -Nuar src.old/lha.h src/lha.h
+--- src.old/lha.h	Fri Jul 19 17:22:13 2002
++++ src/lha.h	Fri Jul 19 17:18:05 2002
+@@ -101,6 +101,9 @@
+ #ifdef EUC
+ EXTERN boolean	euc_mode;
+ #endif
++#ifdef MULTIBYTE_CHAR
++EXTERN boolean	multibyte_mode;
++#endif
+ 
+ /* list command flags */
+ EXTERN boolean  verbose_listing;
+diff -Nuar src.old/lharc.c src/lharc.c
+--- src.old/lharc.c	Fri Oct  6 02:33:34 2000
++++ src/lharc.c	Fri Jul 19 16:56:03 2002
+@@ -101,6 +101,10 @@
+ 	euc_mode		= FALSE;
+ #endif
+ 
++#ifdef MULTIBYTE_CHAR
++	multibyte_mode		= FALSE;
++#endif
++
+ /* view command flags */
+ 	verbose_listing = FALSE;
+ 
+@@ -177,6 +181,11 @@
+                                      e  TEXT code convert from/to EUC\n\
+ ");
+ #endif
++#ifdef MULTIBYTE_CHAR
++	fprintf(stderr, "\
++                                     y  filename multibyte convert\n\
++");
++#endif
+ 	exit(1);
+ }
+ 
+@@ -308,6 +317,11 @@
+ 		case 'e':
+ 			text_mode = TRUE;
+ 			euc_mode = TRUE;
++			break;
++#endif
++#ifdef MULTIBYTE_CHAR
++		case 'y':
++			multibyte_mode = TRUE;
+ 			break;
+ #endif
+ 		case 'n':
+diff -Nuar src.old/util.c src/util.c
+--- src.old/util.c	Wed Oct  4 23:57:38 2000
++++ src/util.c	Fri Jul 19 16:49:23 2002
+@@ -113,18 +113,29 @@
+ #endif
+ 	for (p = path; (c = *p) != 0; p++) {
+ #ifdef MULTIBYTE_CHAR
+-		if (kflg) {
+-			kflg = 0;
++		if (multibyte_mode == TRUE) {
++			if (kflg) {
++				kflg = 0;
++			} else if (MULTIBYTE_FIRST_P(c)) {
++				kflg = 1;
++			} else {
++				if (c == '\\' || c == DELIM || c == DELIM2) {
++					*p = delim;
++					path = p + 1;
++				}
++			}
++		} else {
++			if (c == '\\' || c == DELIM || c == DELIM2) {
++				*p = delim;
++				path = p + 1;
++			}
+ 		}
+-		else if (MULTIBYTE_FIRST_P(c)) {
+-			kflg = 1;
+-		}
+-		else
+-#endif
++#else
+ 		if (c == '\\' || c == DELIM || c == DELIM2) {
+ 			*p = delim;
+ 			path = p + 1;
+ 		}
++#endif
+ 	}
+ 	return path;
+ }
--- lha-1.14i.orig/debian/README.Debian
+++ lha-1.14i/debian/README.Debian
@@ -0,0 +1,6 @@
+lha for DEBIAN
+----------------------
+
+LHa for UNIX
+
+Atsushi KAMOSHIDA <kamop@post1.com>, Sun, 13 Apr 1997 17:52:59 +0900
--- lha-1.14i.orig/debian/org/lha.h
+++ lha-1.14i/debian/org/lha.h
@@ -0,0 +1,322 @@
+/* ------------------------------------------------------------------------ */
+/* LHa for UNIX    Archiver Driver											*/
+/*																			*/
+/*		Modified          		Nobutaka Watazaki							*/
+/*																			*/
+/*	Ver. 1.14 	Soruce All chagned				1995.01.14	N.Watazaki		*/
+/*	Ver. 1.14i 	Modified and bug fixed			2000.10.06	t.okamoto   	*/
+/* ------------------------------------------------------------------------ */
+/*
+	Included...
+		lharc.h		interface.h		slidehuf.h
+*/
+#include <stdio.h>
+#include <errno.h>
+#include <ctype.h>
+#include <sys/types.h>
+#include <sys/file.h>
+#include <sys/stat.h>
+
+#include <signal.h>
+
+#include "lha_macro.h"
+
+struct encode_option {
+#if defined(__STDC__) || defined(AIX)
+	void            (*output) ();
+	void            (*encode_start) ();
+	void            (*encode_end) ();
+#else
+	int             (*output) ();
+	int             (*encode_start) ();
+	int             (*encode_end) ();
+#endif
+};
+
+struct decode_option {
+	unsigned short  (*decode_c) ();
+	unsigned short  (*decode_p) ();
+#if defined(__STDC__) || defined(AIX)
+	void            (*decode_start) ();
+#else
+	int             (*decode_start) ();
+#endif
+};
+
+/* ------------------------------------------------------------------------ */
+/*	LHa File Type Definition												*/
+/* ------------------------------------------------------------------------ */
+struct string_pool {
+	int             used;
+	int             size;
+	int             n;
+	char           *buffer;
+};
+
+typedef struct LzHeader {
+	unsigned char   header_size;
+	char            method[METHOD_TYPE_STRAGE];
+	long            packed_size;
+	long            original_size;
+	long            last_modified_stamp;
+	unsigned char   attribute;
+	unsigned char   header_level;
+	char            name[256];
+	unsigned short  crc;
+	boolean         has_crc;
+	unsigned char   extend_type;
+	unsigned char   minor_version;
+
+	/* extend_type == EXTEND_UNIX  and convert from other type. */
+	time_t          unix_last_modified_stamp;
+	unsigned short  unix_mode;
+	unsigned short  unix_uid;
+	unsigned short  unix_gid;
+}  LzHeader;
+
+struct interfacing {
+	FILE			*infile;
+	FILE			*outfile;
+	unsigned long   original;
+	unsigned long   packed;
+	int             dicbit;
+	int             method;
+};
+
+
+/* ------------------------------------------------------------------------ */
+/*	Option switch variable													*/
+/* ------------------------------------------------------------------------ */
+/* command line options (common options) */
+EXTERN boolean  quiet;
+EXTERN boolean  text_mode;
+EXTERN boolean  verbose;
+EXTERN boolean  noexec;		/* debugging option */
+EXTERN boolean  force;
+EXTERN boolean  prof;
+EXTERN boolean  delete_after_append;
+EXTERN int		compress_method;
+EXTERN int		header_level;
+/* EXTERN int		quiet_mode; */   /* 1996.8.13 t.okamoto */
+#ifdef EUC
+EXTERN boolean	euc_mode;
+#endif
+
+/* list command flags */
+EXTERN boolean  verbose_listing;
+
+/* extract/print command flags */
+EXTERN boolean  output_to_stdout;
+
+/* add/update/delete command flags */
+EXTERN boolean  new_archive;
+EXTERN boolean  update_if_newer;
+EXTERN boolean  generic_format;
+
+EXTERN boolean	remove_temporary_at_error;
+EXTERN boolean	recover_archive_when_interrupt;
+EXTERN boolean	remove_extracting_file_when_interrupt;
+EXTERN boolean	get_filename_from_stdin;
+EXTERN boolean	ignore_directory;
+EXTERN boolean	verify_mode;
+
+/* Indicator flag */
+EXTERN int		quiet_mode;
+
+/* ------------------------------------------------------------------------ */
+/*	Globale Variable														*/
+/* ------------------------------------------------------------------------ */
+EXTERN char		**cmd_filev;
+EXTERN int      cmd_filec;
+
+EXTERN char		*archive_name;
+EXTERN char     expanded_archive_name[FILENAME_LENGTH];
+EXTERN char     temporary_name[FILENAME_LENGTH];
+EXTERN char     backup_archive_name[FILENAME_LENGTH];
+
+EXTERN char		*reading_filename, *writting_filename;
+
+/* 1996.8.13 t.okamoto */
+#if 0
+EXTERN boolean  remove_temporary_at_error;
+EXTERN boolean  recover_archive_when_interrupt;
+EXTERN boolean  remove_extracting_file_when_interrupt;
+#endif
+
+EXTERN int      archive_file_mode;
+EXTERN int      archive_file_gid;
+
+EXTERN struct	interfacing interface;
+EXTERN node		*next;
+/* EXTERN unsigned short crc; */  /* 1996.8.13 t.okamoto */
+
+EXTERN int      noconvertcase; /* 2000.10.6 */
+
+/* slide.c */
+EXTERN int      unpackable;
+EXTERN unsigned long origsize, compsize;
+EXTERN unsigned short dicbit;
+EXTERN unsigned short maxmatch;
+EXTERN unsigned long count;
+EXTERN unsigned long loc;			/* short -> long .. Changed N.Watazaki */
+EXTERN unsigned char *text;
+EXTERN int		prev_char;
+
+/* huf.c */
+#ifndef LHA_MAIN_SRC  /* t.okamoto 96/2/20 */
+EXTERN unsigned short left[], right[];
+EXTERN unsigned char c_len[], pt_len[];
+EXTERN unsigned short c_freq[], c_table[], c_code[];
+EXTERN unsigned short p_freq[], pt_table[], pt_code[], t_freq[];
+#endif
+
+/* append.c */
+#ifdef NEED_INCREMENTAL_INDICATOR
+EXTERN long		indicator_count;
+EXTERN long		indicator_threshold;
+#endif
+
+/* crcio.c */
+EXTERN FILE		*infile, *outfile;
+EXTERN unsigned short crc, bitbuf;
+EXTERN int      dispflg;
+EXTERN long		reading_size;
+
+/* from dhuf.c */
+EXTERN unsigned int n_max;
+
+/* lhadd.c */
+EXTERN FILE		*temporary_fp;
+
+/* ------------------------------------------------------------------------ */
+/*	Functions																*/
+/* ------------------------------------------------------------------------ */
+/* from lharc.c */
+extern int		patmatch();
+
+extern void		interrupt();
+
+extern void		message();
+extern void		warning();
+extern void		error();
+extern void		fatal_error();
+
+extern boolean	need_file();
+extern int		inquire();
+extern FILE		*xfopen();
+
+extern boolean	find_files();
+extern void		free_files();
+
+extern void		init_sp();
+extern void		add_sp();
+extern void		finish_sp();
+extern void		free_sp();
+extern void		cleaning_files();
+
+extern void		build_temporary_name();
+extern void		build_backup_file_name();
+extern void		build_standard_archive_name();
+
+extern FILE		*open_old_archive();
+extern void		init_header();
+extern boolean	get_header();
+extern boolean	archive_is_msdos_sfx1();
+extern boolean	skip_msdos_sfx1_code();
+extern void		write_header();
+extern void		write_archive_tail();
+extern void		copy_old_one();
+extern unsigned char *convdelim();
+extern long		copyfile();
+
+extern void		cmd_list(), cmd_extract(), cmd_add(), cmd_delete();
+
+extern boolean	ignore_directory;
+extern boolean	compress_method;
+extern boolean	verify_mode;
+
+extern char		*extract_directory;
+
+/* from slide.c */
+
+extern int		encode_alloc();
+extern void		encode();
+extern void		decode();
+
+/* from append.c */
+extern void     start_indicator();
+extern void     finish_indicator();
+extern void     finish_indicator2();
+
+/* slide.c */
+extern void     output_st1();
+extern unsigned char *alloc_buf();
+extern void     encode_start_st1();
+extern void     encode_end_st1();
+extern unsigned short decode_c_st1();
+extern unsigned short decode_p_st1();
+extern void     decode_start_st1();
+
+/* from shuf.c */
+extern void     decode_start_st0();
+extern void     encode_p_st0( /* unsigned short j */ );
+extern void     encode_start_fix();
+extern void     decode_start_fix();
+extern unsigned short decode_c_st0();
+extern unsigned short decode_p_st0();
+
+/* from dhuf.c */
+extern void     start_c_dyn();
+extern void     decode_start_dyn();
+extern unsigned short decode_c_dyn();
+extern unsigned short decode_p_dyn();
+extern void     output_dyn( /* int code, unsigned int pos */ );
+extern void     encode_end_dyn();
+
+extern int      decode_lzhuf();
+
+/* from larc.c */
+
+extern unsigned short decode_c_lzs();
+extern unsigned short decode_p_lzs();
+extern unsigned short decode_c_lz5();
+extern unsigned short decode_p_lz5();
+extern void			  decode_start_lzs();
+extern void			  decode_start_lz5();
+
+extern void	make_table(	/* int nchar, uchar bitlen[], int tablebits,
+							ushort table[] */ );
+
+/* from maketree.c */
+/*
+ * void make_code(short n, uchar len[], ushort code[]); short make_tree(short
+ * nparm, ushort freqparm[], uchar lenparm[], ushort codeparam[]);
+ */
+extern void		make_code( /* int n, uchar len[], ushort code[] */ );
+extern short	make_tree( /* int nparm, ushort freqparm[], uchar lenparm[],
+								ushort codeparam[] */ );
+
+/* from crcio.c */
+extern void				make_crctable();
+extern unsigned short	calccrc( /* uchar *p, uint n */ );
+extern void				fillbuf( /* uchar n */ );
+extern unsigned short	getbits( /* uchar n */ );
+extern void				putcode( /* uchar n, ushort x */ );
+extern void				putbits( /* uchar n, ushort x */ );
+extern int				fread_crc( /* uchar *p, int n, FILE *f */ );
+extern void				fwrite_crc( /* uchar *p, int n, FILE *f */ );
+extern void				init_getbits();
+extern void				init_putbits();
+extern void     		make_crctable();
+extern unsigned 		short calccrc();
+
+/* from lhadd.c */
+extern int		encode_lzhuf();
+extern int      encode_stored_crc();
+
+/* Local Variables: */
+/* mode:c */
+/* tab-width:4 */
+/* End: */
+
+
--- lha-1.14i.orig/debian/org/header.c
+++ lha-1.14i/debian/org/header.c
@@ -0,0 +1,875 @@
+/* ------------------------------------------------------------------------ */
+/* LHa for UNIX    															*/
+/*				header.c -- header manipulate functions						*/
+/*																			*/
+/*		Modified          		Nobutaka Watazaki							*/
+/*																			*/
+/*	Original												Y.Tagawa		*/
+/*	modified									1991.12.16	M.Oki			*/
+/*	Ver. 1.10  Symbolic Link added				1993.10.01	N.Watazaki		*/
+/*	Ver. 1.13b Symbolic Link Bug Fix			1994.08.22	N.Watazaki		*/
+/*	Ver. 1.14  Source All chagned				1995.01.14	N.Watazaki		*/
+/*  Ver. 1.14i bug fixed						2000.10.06  t.okamoto       */
+/* ------------------------------------------------------------------------ */
+#include "lha.h"
+
+/* ------------------------------------------------------------------------ */
+static char    *get_ptr;
+/* ------------------------------------------------------------------------ */
+int
+calc_sum(p, len)
+	register char  *p;
+	register int    len;
+{
+	register int    sum;
+
+	for (sum = 0; len; len--)
+		sum += *p++;
+
+	return sum & 0xff;
+}
+
+/* ------------------------------------------------------------------------ */
+static unsigned short
+get_word()
+{
+	int             b0, b1;
+
+	b0 = get_byte();
+	b1 = get_byte();
+	return (b1 << 8) + b0;
+}
+
+/* ------------------------------------------------------------------------ */
+static void
+put_word(v)
+	unsigned int    v;
+{
+	put_byte(v);
+	put_byte(v >> 8);
+}
+
+/* ------------------------------------------------------------------------ */
+static long
+get_longword()
+{
+	long            b0, b1, b2, b3;
+
+	b0 = get_byte();
+	b1 = get_byte();
+	b2 = get_byte();
+	b3 = get_byte();
+	return (b3 << 24) + (b2 << 16) + (b1 << 8) + b0;
+}
+
+/* ------------------------------------------------------------------------ */
+static void
+put_longword(v)
+	long            v;
+{
+	put_byte(v);
+	put_byte(v >> 8);
+	put_byte(v >> 16);
+	put_byte(v >> 24);
+}
+
+/* ------------------------------------------------------------------------ */
+static void
+msdos_to_unix_filename(name, len)
+	register char  *name;
+	register int    len;
+{
+	register int    i;
+
+#ifdef MULTIBYTE_CHAR
+	for (i = 0; i < len; i++) {
+		if (MULTIBYTE_FIRST_P(name[i]) &&
+		    MULTIBYTE_SECOND_P(name[i + 1]))
+			i++;
+		else if (name[i] == '\\')
+			name[i] = '/';
+		else if (!noconvertcase && isupper(name[i]))
+			name[i] = tolower(name[i]);
+	}
+#else
+	for (i = 0; i < len; i++) {
+		if (name[i] == '\\')
+			name[i] = '/';
+		else if (!noconvertcase && isupper(name[i]))
+			name[i] = tolower(name[i]);
+	}
+#endif
+}
+
+/* ------------------------------------------------------------------------ */
+static void
+generic_to_unix_filename(name, len)
+	register char  *name;
+	register int    len;
+{
+	register int    i;
+	boolean         lower_case_used = FALSE;
+
+#ifdef MULTIBYTE_CHAR
+	for (i = 0; i < len; i++) {
+		if (MULTIBYTE_FIRST_P(name[i]) &&
+		    MULTIBYTE_SECOND_P(name[i + 1]))
+			i++;
+		else if (islower(name[i])) {
+			lower_case_used = TRUE;
+			break;
+		}
+	}
+	for (i = 0; i < len; i++) {
+		if (MULTIBYTE_FIRST_P(name[i]) &&
+		    MULTIBYTE_SECOND_P(name[i + 1]))
+			i++;
+		else if (name[i] == '\\')
+			name[i] = '/';
+		else if (!noconvertcase && !lower_case_used && isupper(name[i]))
+			name[i] = tolower(name[i]);
+	}
+#else
+	for (i = 0; i < len; i++)
+		if (islower(name[i])) {
+			lower_case_used = TRUE;
+			break;
+		}
+	for (i = 0; i < len; i++) {
+		if (name[i] == '\\')
+			name[i] = '/';
+		else if (!noconvertcase && !lower_case_used && isupper(name[i]))
+			name[i] = tolower(name[i]);
+	}
+#endif
+}
+
+/* ------------------------------------------------------------------------ */
+static void
+macos_to_unix_filename(name, len)
+	register char  *name;
+	register int    len;
+{
+	register int    i;
+
+	for (i = 0; i < len; i++) {
+		if (name[i] == ':')
+			name[i] = '/';
+		else if (name[i] == '/')
+			name[i] = ':';
+	}
+}
+
+/* ------------------------------------------------------------------------ */
+static void
+unix_to_generic_filename(name, len)
+	register char  *name;
+	register int    len;
+{
+	register int    i;
+
+	for (i = 0; i < len; i++) {
+		if (name[i] == '/')
+			name[i] = '\\';
+		else if (islower(name[i]))
+			name[i] = toupper(name[i]);
+	}
+}
+
+/* ------------------------------------------------------------------------ */
+/*																			*/
+/* Generic stamp format:						 							*/
+/*																			*/
+/* 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16							*/
+/* |<-------- year ------->|<- month ->|<-- day -->|						*/
+/*																			*/
+/* 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0							*/
+/* |<--- hour --->|<---- minute --->|<- second*2 ->|						*/
+/*																			*/
+/* ------------------------------------------------------------------------ */
+
+/*
+ * NOTE : If you don't have `gettimeofday(2)', or your gettimeofday(2)
+ * returns bogus timezone information, try FTIME, MKTIME, TIMELOCAL or TZSET.
+ */
+
+/* choose one */
+#if defined(MKTIME)
+#ifdef TIMELOCAL
+#undef TIMELOCAL
+#endif
+#endif				/* defined(MKTIME) */
+
+#if defined(MKTIME) || defined(TIMELOCAL)
+#ifdef TZSET
+#undef TZSET
+#endif
+#endif				/* defined(MKTIME) || defined(TIMELOCAL) */
+
+#if defined(MKTIME) || defined(TIMELOCAL) || defined(TZSET)
+#ifdef FTIME
+#undef FTIME
+#endif
+#endif
+
+#if defined(MKTIME) || defined(TIMELOCAL) || defined(TZSET) || defined(FTIME)
+#ifdef GETTIMEOFDAY
+#undef GETTIMEOFDAY
+#endif
+#else
+#ifndef GETTIMEOFDAY
+#define GETTIMEOFDAY		/* use gettimeofday() */
+#endif
+#endif
+
+#ifdef FTIME
+#include <sys/timeb.h>
+#endif
+
+/*
+ * You may define as : #define TIMEZONE_HOOK		\ extern long
+ * timezone ;	\ extern void tzset();
+ */
+#ifdef TIMEZONE_HOOK
+TIMEZONE_HOOK
+/* Which do you like better, `TIMEZONE_HOOK' or `TIMEZONE_HOOK;' ? */
+#endif
+
+#if defined(TZSET) && defined(_MINIX)
+extern long     timezone;		/* not defined in time.h */
+#endif
+
+/* ------------------------------------------------------------------------ */
+#if defined(FTIME) || defined(GETTIMEOFDAY) || defined(TZSET)
+static long
+gettz()
+#ifdef TZSET
+{
+	tzset();
+	return timezone;
+}
+#endif
+
+/* ------------------------------------------------------------------------ */
+#if !defined(TZSET) && defined(FTIME)
+{
+	struct timeb    buf;
+
+	ftime(&buf);
+	return buf.timezone * 60L;
+}
+#endif
+
+/* ------------------------------------------------------------------------ */
+#if !defined(TZSET) && !defined(FTIME)	/* maybe defined(GETTIMEOFDAY) */
+{
+#ifdef HAVE_TM_ZONE
+	time_t tt;
+
+	time(&tt);
+	return -localtime(&tt)->tm_gmtoff;
+#else /* HAVE_TM_ZONE */
+	struct timeval  tp;
+	struct timezone tzp;
+	gettimeofday(&tp, &tzp);/* specific to 4.3BSD */
+	/*
+	 * return (tzp.tz_minuteswest * 60L + (tzp.tz_dsttime != 0 ? 60L *
+	 * 60L : 0));
+	 */
+	return (tzp.tz_minuteswest * 60L);
+#endif /* HAVE_TM_ZONE */
+}
+#endif
+#endif				/* defined(FTIME) || defined(GETTIMEOFDAY) ||
+				 * defined(TZSET) */
+
+/* ------------------------------------------------------------------------ */
+#ifdef NOT_USED
+static struct tm *
+msdos_to_unix_stamp_tm(a)
+	long            a;
+{
+	static struct tm t;
+
+	t.tm_sec = (a & 0x1f) * 2;
+	t.tm_min = (a >> 5) & 0x3f;
+	t.tm_hour = (a >> 11) & 0x1f;
+	t.tm_mday = (a >> 16) & 0x1f;
+	t.tm_mon = ((a >> 16 + 5) & 0x0f) - 1;
+	t.tm_year = ((a >> 16 + 9) & 0x7f) + 80;
+	return &t;
+}
+#endif
+
+/* ------------------------------------------------------------------------ */
+static          time_t
+generic_to_unix_stamp(t)
+	long            t;
+#if defined(MKTIME) || defined(TIMELOCAL)
+{
+	struct tm       dostm;
+
+	/*
+	 * special case:  if MSDOS format date and time were zero, then we
+	 * set time to be zero here too.
+	 */
+	if (t == 0)
+		return (time_t) 0;
+
+	dostm.tm_sec = (t & 0x1f) * 2;
+	dostm.tm_min = t >> 5 & 0x3f;
+	dostm.tm_hour = t >> 11 & 0x1f;
+	dostm.tm_mday = t >> 16 & 0x1f;
+	dostm.tm_mon = (t >> 16 + 5 & 0x0f) - 1;	/* 0..11 */
+	dostm.tm_year = (t >> 16 + 9 & 0x7f) + 80;
+#if 0
+	dostm.tm_isdst = 0;	/* correct? */
+#endif
+	dostm.tm_isdst = -1;    /* correct? */
+#ifdef MKTIME
+	return (time_t) mktime(&dostm);
+#else				/* maybe defined(TIMELOCAL) */
+	return (time_t) timelocal(&dostm);
+#endif
+}
+
+#else				/* defined(MKTIME) || defined(TIMELOCAL) */
+{
+	int             year, month, day, hour, min, sec;
+	long            longtime;
+	static unsigned int dsboy[12] = {0, 31, 59, 90, 120, 151,
+	181, 212, 243, 273, 304, 334};
+	unsigned int    days;
+
+	/*
+	 * special case:  if MSDOS format date and time were zero, then we
+	 * set time to be zero here too.
+	 */
+	if (t == 0)
+		return (time_t) 0;
+
+	year = ((int) (t >> 16 + 9) & 0x7f) + 1980;
+	month = (int) (t >> 16 + 5) & 0x0f;	/* 1..12 means Jan..Dec */
+	day = (int) (t >> 16) & 0x1f;	/* 1..31 means 1st,...31st */
+
+	hour = ((int) t >> 11) & 0x1f;
+	min = ((int) t >> 5) & 0x3f;
+	sec = ((int) t & 0x1f) * 2;
+
+	/* Calculate days since 1970.01.01 */
+	days = (365 * (year - 1970) +	/* days due to whole years */
+		(year - 1970 + 1) / 4 +	/* days due to leap years */
+		dsboy[month - 1] +	/* days since beginning of this year */
+		day - 1);	/* days since beginning of month */
+
+	if ((year % 4 == 0) &&
+		(year % 100 != 0 || year % 400 == 0) &&		/* 1999.5.24 t.oka */
+	    (month >= 3))	/* if this is a leap year and month */
+		days++;		/* is March or later, add a day */
+
+	/* Knowing the days, we can find seconds */
+	longtime = (((days * 24) + hour) * 60 + min) * 60 + sec;
+	longtime += gettz();	/* adjust for timezone */
+
+	/* LONGTIME is now the time in seconds, since 1970/01/01 00:00:00.  */
+	return (time_t) longtime;
+}
+#endif				/* defined(MKTIME) || defined(TIMELOCAL) */
+
+/* ------------------------------------------------------------------------ */
+static long
+unix_to_generic_stamp(t)
+	time_t          t;
+{
+	struct tm      *tm = localtime(&t);
+
+	return ((((long) (tm->tm_year - 80)) << 25) +
+		(((long) (tm->tm_mon + 1)) << 21) +
+		(((long) tm->tm_mday) << 16) +
+		(long) ((tm->tm_hour << 11) +
+			(tm->tm_min << 5) +
+			(tm->tm_sec / 2)));
+}
+
+/* ------------------------------------------------------------------------ */
+/* build header functions													*/
+/* ------------------------------------------------------------------------ */
+boolean
+get_header(fp, hdr)
+	FILE           *fp;
+	register LzHeader *hdr;
+{
+	int             header_size;
+	int             name_length;
+	char            data[LZHEADER_STRAGE];
+	char            dirname[FILENAME_LENGTH];
+	int             dir_length = 0;
+	int             checksum;
+	int             i;
+	char           *ptr;
+	int				extend_size;
+	int				dmy;
+
+	bzero(hdr, sizeof(LzHeader));
+
+	if (((header_size = getc(fp)) == EOF) || (header_size == 0)) {
+		return FALSE;	/* finish */
+	}
+
+	if (fread(data + I_HEADER_CHECKSUM,
+		  sizeof(char), header_size - 1, fp) < header_size - 1) {
+		fatal_error("Invalid header (LHarc file ?)");
+		return FALSE;	/* finish */
+	}
+	setup_get(data + I_HEADER_LEVEL);
+	hdr->header_level = get_byte();
+	if (hdr->header_level != 2 &&
+	    fread(data + header_size, sizeof(char), 2, fp) < 2) {
+		fatal_error("Invalid header (LHarc file ?)");
+		return FALSE;	/* finish */
+	}
+
+	if (hdr->header_level >= 3) {
+		fatal_error("Unknown level header");
+		return FALSE;
+	}
+
+	setup_get(data + I_HEADER_CHECKSUM);
+	checksum = get_byte();
+
+	if (hdr->header_level == 2) {
+		hdr->header_size = header_size + checksum*256;
+	} else {
+		hdr->header_size = header_size;
+	}
+	bcopy(data + I_METHOD, hdr->method, METHOD_TYPE_STRAGE);
+	setup_get(data + I_PACKED_SIZE);
+	hdr->packed_size = get_longword();
+	hdr->original_size = get_longword();
+	hdr->last_modified_stamp = get_longword();
+	hdr->attribute = get_byte();
+
+	if ((hdr->header_level = get_byte()) != 2) {
+		if (calc_sum(data + I_METHOD, header_size) != checksum)
+			warning("Checksum error (LHarc file?)", "");
+		name_length = get_byte();
+		for (i = 0; i < name_length; i++)
+			hdr->name[i] = (char) get_byte();
+		hdr->name[name_length] = '\0';
+	}
+	else {
+		hdr->unix_last_modified_stamp = hdr->last_modified_stamp;
+		name_length = 0;
+	}
+
+	/* defaults for other type */
+	hdr->unix_mode = UNIX_FILE_REGULAR | UNIX_RW_RW_RW;
+	hdr->unix_gid = 0;
+	hdr->unix_uid = 0;
+
+	if (hdr->header_level == 0) {
+		extend_size = header_size - name_length -22;
+		if (extend_size < 0) {
+			if (extend_size == -2) {
+				hdr->extend_type = EXTEND_GENERIC;
+				hdr->has_crc = FALSE;
+			} else {
+				fatal_error("Unkonwn header (lha file?)");
+				return FALSE;
+			}
+		} else {
+			hdr->has_crc = TRUE;
+			hdr->crc = get_word();
+		}
+
+		if (extend_size >= 1) {
+			hdr->extend_type = get_byte();
+			extend_size--;
+		}
+		if (hdr->extend_type == EXTEND_UNIX) {
+			if (extend_size >= 11) {
+				hdr->minor_version = get_byte();
+				hdr->unix_last_modified_stamp = (time_t) get_longword();
+				hdr->unix_mode = get_word();
+				hdr->unix_uid = get_word();
+				hdr->unix_gid = get_word();
+				extend_size -= 11;
+			} else {
+				hdr->extend_type = EXTEND_GENERIC;
+			}
+		}
+		while (extend_size-- > 0)
+			dmy = get_byte();
+		if (hdr->extend_type == EXTEND_UNIX)
+			return TRUE;
+	} else if (hdr->header_level == 1) {
+		hdr->has_crc = TRUE;
+		extend_size = header_size - name_length-25;
+		hdr->crc = get_word();
+		hdr->extend_type = get_byte();
+		while (extend_size-- > 0)
+			dmy = get_byte();
+	} else { /* level 2 */
+		hdr->has_crc = TRUE;
+		hdr->crc = get_word();
+		hdr->extend_type = get_byte();
+	}		
+
+	if (hdr->header_level > 0) {
+		/* Extend Header */
+		if (hdr->header_level != 2)
+			setup_get(data + hdr->header_size);
+		ptr = get_ptr;
+		while ((header_size = get_word()) != 0) {
+			if (hdr->header_level != 2 &&
+			((data + LZHEADER_STRAGE - get_ptr < header_size) ||
+			 fread(get_ptr, sizeof(char), header_size, fp) < header_size)) {
+				fatal_error("Invalid header (LHa file ?)");
+				return FALSE;
+			}
+			switch (get_byte()) {
+			case 0:
+				/*
+				 * header crc
+				 */
+				setup_get(get_ptr + header_size - 3);
+				break;
+			case 1:
+				/*
+				 * filename
+				 */
+				for (i = 0; i < header_size - 3; i++)
+					hdr->name[i] = (char) get_byte();
+				hdr->name[header_size - 3] = '\0';
+				name_length = header_size - 3;
+				break;
+			case 2:
+				/*
+				 * directory
+				 */
+				for (i = 0; i < header_size - 3; i++)
+					dirname[i] = (char) get_byte();
+				dirname[header_size - 3] = '\0';
+				convdelim(dirname, DELIM);
+				dir_length = header_size - 3;
+				break;
+			case 0x40:
+				/*
+				 * MS-DOS attribute
+				 */
+				if (hdr->extend_type == EXTEND_MSDOS ||
+				    hdr->extend_type == EXTEND_HUMAN ||
+				    hdr->extend_type == EXTEND_GENERIC)
+					hdr->attribute = get_word();
+				break;
+			case 0x50:
+				/*
+				 * UNIX permission
+				 */
+				if (hdr->extend_type == EXTEND_UNIX)
+					hdr->unix_mode = get_word();
+				break;
+			case 0x51:
+				/*
+				 * UNIX gid and uid
+				 */
+				if (hdr->extend_type == EXTEND_UNIX) {
+					hdr->unix_gid = get_word();
+					hdr->unix_uid = get_word();
+				}
+				break;
+			case 0x52:
+				/*
+				 * UNIX group name
+				 */
+				setup_get(get_ptr + header_size - 3);
+				break;
+			case 0x53:
+				/*
+				 * UNIX user name
+				 */
+				setup_get(get_ptr + header_size - 3);
+				break;
+			case 0x54:
+				/*
+				 * UNIX last modified time
+				 */
+				if (hdr->extend_type == EXTEND_UNIX)
+					hdr->unix_last_modified_stamp = (time_t) get_longword();
+				break;
+			default:
+				/*
+				 * other headers
+				 */
+				setup_get(get_ptr + header_size - 3);
+				break;
+			}
+		}
+		if (hdr->header_level != 2 && get_ptr - ptr != 2) {
+			hdr->packed_size -= get_ptr - ptr - 2;
+			hdr->header_size += get_ptr - ptr - 2;
+		}
+	}
+
+	switch (hdr->extend_type) {
+	case EXTEND_MSDOS:
+		msdos_to_unix_filename(hdr->name, name_length);
+		msdos_to_unix_filename(dirname, dir_length);
+	case EXTEND_HUMAN:
+		if (hdr->header_level == 2)
+			hdr->unix_last_modified_stamp = hdr->last_modified_stamp;
+		else
+			hdr->unix_last_modified_stamp =
+				generic_to_unix_stamp(hdr->last_modified_stamp);
+		break;
+
+#ifdef OSK
+	case EXTEND_OS68K:
+	case EXTEND_XOSK:
+#endif
+	case EXTEND_UNIX:
+		break;
+
+	case EXTEND_MACOS:
+		macos_to_unix_filename(hdr->name, name_length);
+		/* macos_to_unix_filename(dirname, dir_length); */
+		hdr->unix_last_modified_stamp =
+			generic_to_unix_stamp(hdr->last_modified_stamp);
+		break;
+
+	default:
+		generic_to_unix_filename(hdr->name, name_length);
+		generic_to_unix_filename(dirname, dir_length);
+		if (hdr->header_level == 2)
+			hdr->unix_last_modified_stamp = hdr->last_modified_stamp;
+		else
+			hdr->unix_last_modified_stamp =
+				generic_to_unix_stamp(hdr->last_modified_stamp);
+	}
+
+	if (dir_length) {
+		strcat(dirname, hdr->name);
+		strcpy(hdr->name, dirname);
+		name_length += dir_length;
+	}
+
+	return TRUE;
+}
+
+/* ------------------------------------------------------------------------ */
+void
+init_header(name, v_stat, hdr)
+	char           *name;
+	struct stat    *v_stat;
+	LzHeader       *hdr;
+{
+	int             len;
+
+	if (compress_method == LZHUFF5_METHOD_NUM)  /* Changed N.Watazaki */
+		bcopy(LZHUFF5_METHOD, hdr->method, METHOD_TYPE_STRAGE);
+	else if (compress_method)
+		bcopy(LZHUFF1_METHOD, hdr->method, METHOD_TYPE_STRAGE);
+	else
+		bcopy(LZHUFF0_METHOD, hdr->method, METHOD_TYPE_STRAGE);
+
+	hdr->packed_size = 0;
+	hdr->original_size = v_stat->st_size;
+	hdr->last_modified_stamp = unix_to_generic_stamp(v_stat->st_mtime);
+	hdr->attribute = GENERIC_ATTRIBUTE;
+	hdr->header_level = header_level;
+	strcpy(hdr->name, name);
+	len = strlen(name);
+	hdr->crc = 0x0000;
+	hdr->extend_type = EXTEND_UNIX;
+	hdr->unix_last_modified_stamp = v_stat->st_mtime;
+	/* since 00:00:00 JAN.1.1970 */
+#ifdef NOT_COMPATIBLE_MODE
+	/* Please need your modification in this space. */
+#else
+	hdr->unix_mode = v_stat->st_mode;
+#endif
+
+	hdr->unix_uid = v_stat->st_uid;
+	hdr->unix_gid = v_stat->st_gid;
+
+	if (is_directory(v_stat)) {
+		bcopy(LZHDIRS_METHOD, hdr->method, METHOD_TYPE_STRAGE);
+		hdr->attribute = GENERIC_DIRECTORY_ATTRIBUTE;
+		hdr->original_size = 0;
+		if (len > 0 && hdr->name[len - 1] != '/')
+			strcpy(&hdr->name[len++], "/");
+	}
+
+#ifdef S_IFLNK	
+	if (is_symlink(v_stat)) {
+		char	lkname[257];
+		int		len;	
+		bcopy(LZHDIRS_METHOD, hdr->method, METHOD_TYPE_STRAGE);
+		hdr->attribute = GENERIC_DIRECTORY_ATTRIBUTE;
+		hdr->original_size = 0;
+		len = readlink(name, lkname, 256);
+		lkname[len] = (char)'\0';
+		sprintf(hdr->name, "%s|%s", hdr->name, lkname);
+	}
+#endif
+	if (generic_format)
+		unix_to_generic_filename(hdr->name, len);
+}
+
+/* ------------------------------------------------------------------------ */
+/* Write unix extended header or generic header. */
+void
+write_header(nafp, hdr)
+	FILE           *nafp;
+	LzHeader       *hdr;
+{
+	int             header_size;
+	int             name_length;
+	char            data[LZHEADER_STRAGE];
+	char           *p;
+	char           *headercrc_ptr;
+
+	bzero(data, LZHEADER_STRAGE);
+	bcopy(hdr->method, data + I_METHOD, METHOD_TYPE_STRAGE);
+	setup_put(data + I_PACKED_SIZE);
+	put_longword(hdr->packed_size);
+	put_longword(hdr->original_size);
+
+	if (hdr->header_level == HEADER_LEVEL2)
+		put_longword((long) hdr->unix_last_modified_stamp);
+	else
+		put_longword(hdr->last_modified_stamp);
+
+	switch (hdr->header_level) {
+	case HEADER_LEVEL0:
+		put_byte(hdr->attribute);
+		break;
+	case HEADER_LEVEL1:
+	case HEADER_LEVEL2:
+		put_byte(0x20);
+		break;
+	}
+
+	put_byte(hdr->header_level);
+
+	convdelim(hdr->name, DELIM2);
+	if (hdr->header_level != HEADER_LEVEL2) {
+		if (p = (char *) rindex(hdr->name, DELIM2))
+			name_length = strlen(++p);
+		else
+			name_length = strlen(hdr->name);
+		put_byte(name_length);
+		bcopy(p ? p : hdr->name, data + I_NAME, name_length);
+		setup_put(data + I_NAME + name_length);
+	}
+
+	put_word(hdr->crc);
+	if (header_level == HEADER_LEVEL0) {
+		if (generic_format) {
+			header_size = I_GENERIC_HEADER_BOTTOM - 2 + name_length;
+			data[I_HEADER_SIZE] = header_size;
+			data[I_HEADER_CHECKSUM] = calc_sum(data + I_METHOD, header_size);
+		} else {
+			/* write old-style extend header */
+			put_byte(EXTEND_UNIX);
+			put_byte(CURRENT_UNIX_MINOR_VERSION);
+			put_longword((long) hdr->unix_last_modified_stamp);
+			put_word(hdr->unix_mode);
+			put_word(hdr->unix_uid);
+			put_word(hdr->unix_gid);
+			header_size = I_UNIX_EXTEND_BOTTOM - 2 + name_length;
+			data[I_HEADER_SIZE] = header_size;
+			data[I_HEADER_CHECKSUM] = calc_sum(data + I_METHOD, header_size);
+		}
+	} else {
+		/* write extend header. */
+		char           *ptr;
+
+		if (generic_format)
+			put_byte(0x00);
+		else
+			put_byte(EXTEND_UNIX);
+
+		ptr = put_ptr;
+		if (hdr->header_level == HEADER_LEVEL2) {
+			/* write common header */
+			put_word(5);
+			put_byte(0x00);
+			headercrc_ptr = put_ptr;
+			put_word(0x0000);
+		}
+
+		if (generic_format) {
+			header_size = put_ptr - data;	/* +2 for last 0x0000 */
+		} else {
+			put_word(5);
+			if (hdr->header_level == HEADER_LEVEL1)
+				header_size = put_ptr - data - 2;
+			put_byte(0x50);	/* permission */
+			put_word(hdr->unix_mode);
+			put_word(7);
+			put_byte(0x51);	/* gid and uid */
+			put_word(hdr->unix_gid);
+			put_word(hdr->unix_uid);
+
+			if (p = (char *) rindex(hdr->name, DELIM2)) {
+				int             i;
+
+				name_length = p - hdr->name + 1;
+				put_word(name_length + 3);
+				put_byte(2);	/* dirname */
+				for (i = 0; i < name_length; i++)
+					put_byte(hdr->name[i]);
+			}
+		}		/* if generic .. */
+
+		if (header_level != HEADER_LEVEL2) {
+			if (!generic_format) {
+				put_word(7);
+				put_byte(0x54);	/* time stamp */
+				put_longword(hdr->unix_last_modified_stamp);
+			}
+			hdr->packed_size += put_ptr - ptr;
+			ptr = put_ptr;
+			setup_put(data + I_PACKED_SIZE);
+			put_longword(hdr->packed_size);
+			put_ptr = ptr;
+			data[I_HEADER_SIZE] = header_size;
+			data[I_HEADER_CHECKSUM] = calc_sum(data + I_METHOD, header_size);
+		} else {		/* header level 2 */
+			int             i;
+			if (p = (char *) rindex(hdr->name, DELIM2))
+				name_length = strlen(++p);
+			else {
+				p = hdr->name;
+				name_length = strlen(hdr->name);
+			}
+			put_word(name_length + 3);
+			put_byte(1);	/* filename */
+			for (i = 0; i < name_length; i++)
+				put_byte(*p++);
+		}		/* if he.. != HEAD_LV2 */
+		header_size = put_ptr - data;
+	}
+
+	if (header_level == HEADER_LEVEL2) {
+		unsigned short  hcrc;
+		setup_put(data + I_HEADER_SIZE);
+		put_word(header_size + 2);
+		/* common header */
+		hcrc = calc_header_crc(data, (unsigned int) header_size + 2);
+		setup_put(headercrc_ptr);
+		put_word(hcrc);
+	}
+
+	if (fwrite(data, sizeof(char), header_size + 2, nafp) == 0)
+		fatal_error("Cannot write to temporary file");
+
+	convdelim(hdr->name, DELIM);
+}
+
+/* Local Variables: */
+/* mode:c */
+/* tab-width:4 */
+/* compile-command:"gcc -c header.c" */
+/* End: */
--- lha-1.14i.orig/debian/org/lharc.c
+++ lha-1.14i/debian/org/lharc.c
@@ -0,0 +1,1135 @@
+/* ------------------------------------------------------------------------ */
+/* LHa for UNIX    															*/
+/*				lharc.c -- append to archive								*/
+/*																			*/
+/*		Copyright (C) MCMLXXXIX Yooichi.Tagawa								*/
+/*		Modified          		Nobutaka Watazaki							*/
+/*							Thanks to H.Yoshizaki. (MS-DOS LHarc)			*/
+/*																			*/
+/*  Ver. 0.00  Original							1988.05.23  Y.Tagawa		*/
+/*  Ver. 0.01  Alpha Version (for 4.2BSD)		1989.05.28  Y.Tagawa		*/
+/*  Ver. 0.02  Alpha Version Rel.2				1989.05.29  Y.Tagawa		*/
+/*  Ver. 0.03  Release #3  Beta Version			1989.07.02  Y.Tagawa		*/
+/*  Ver. 0.03a Debug							1989.07.03  Y.Tagawa		*/
+/*  Ver. 0.03b Modified							1989.07.13  Y.Tagawa		*/
+/*  Ver. 0.03c Debug (Thanks to void@rena.dit.junet)						*/
+/*												1989.08.09  Y.Tagawa		*/
+/*  Ver. 0.03d Modified (quiet and verbose)		1989.09.14  Y.Tagawa		*/
+/*  V1.00  Fixed								1989.09.22  Y.Tagawa		*/
+/*  V1.01  Bug Fixed							1989.12.25  Y.Tagawa		*/
+/*																			*/
+/*  DOS-Version Original LHx V C2.01 		(C) H.Yohizaki					*/
+/*																			*/
+/*  V2.00  UNIX Lharc + DOS LHx -> OSK LHx		1990.11.01  Momozou			*/
+/*  V2.01  Minor Modified						1990.11.24  Momozou			*/
+/*																			*/
+/*  Ver. 0.02  LHx for UNIX						1991.11.18  M.Oki			*/
+/*  Ver. 0.03  LHa for UNIX						1991.12.17  M.Oki			*/
+/*  Ver. 0.04  LHa for UNIX	beta version		1992.01.20  M.Oki			*/
+/*  Ver. 1.00  LHa for UNIX	Fixed				1992.03.19  M.Oki			*/
+/*																			*/
+/*  Ver. 1.10  for Symblic Link					1993.06.25  N.Watazaki		*/
+/*  Ver. 1.11  for Symblic Link	Bug Fixed		1993.08.18  N.Watazaki		*/
+/*  Ver. 1.12  for File Date Check				1993.10.28  N.Watazaki		*/
+/*  Ver. 1.13  Bug Fixed (Idicator calcurate)	1994.02.21  N.Watazaki		*/
+/*  Ver. 1.13a Bug Fixed (Sym. Link delete)		1994.03.11  N.Watazaki		*/
+/*	Ver. 1.13b Bug Fixed (Sym. Link delete)		1994.07.29  N.Watazaki		*/
+/*	Ver. 1.14  Source All chagned				1995.01.14	N.Watazaki		*/
+/*	Ver. 1.14b,c  Bug Fixed                     1996.03.07  t.okamoto		*/
+/*  Ver. 1.14d Version up                       1997.01.12  t.okamoto       */
+/*  Ver. 1.14g Bug Fixed                        2000.05.06  t.okamoto       */
+/*  Ver. 1.14i Modified                         2000.10.06  t.okamoto       */
+/* ------------------------------------------------------------------------ */
+#define LHA_MAIN_SRC
+
+#include "lha.h"
+
+/* ------------------------------------------------------------------------ */
+/*								PROGRAM										*/
+/* ------------------------------------------------------------------------ */
+static int      cmd = CMD_UNKNOWN;
+
+/* 1996.8.13 t.okamoto */
+#if 0
+char          **cmd_filev;
+int             cmd_filec;
+
+char           *archive_name;
+char            expanded_archive_name[FILENAME_LENGTH];
+char            temporary_name[FILENAME_LENGTH];
+char            backup_archive_name[FILENAME_LENGTH];
+#endif
+
+/* static functions */
+static void     sort_files();
+static void		print_version();
+
+char		    *extract_directory = NULL;
+char		  **xfilev;
+int             xfilec = 257;
+
+/* 1996.8.13 t.okamoto */
+#if 0
+char           *writting_filename;
+char           *reading_filename;
+
+int             archive_file_mode;
+int             archive_file_gid;
+#endif
+/* ------------------------------------------------------------------------ */
+static void
+init_variable()		/* Added N.Watazaki */
+{
+/* options */
+	quiet			= FALSE;
+	text_mode		= FALSE;
+	verbose			= FALSE;
+	noexec			= FALSE;	/* debugging option */
+	force			= FALSE;
+	prof			= FALSE;
+#ifndef SUPPORT_LH7
+	compress_method = LZHUFF5_METHOD_NUM;
+#endif
+#ifdef SUPPORT_LH7
+	compress_method = LZHUFF7_METHOD_NUM;
+#endif
+
+	header_level	= HEADER_LEVEL1;
+	quiet_mode		= 0;
+
+#ifdef EUC
+	euc_mode		= FALSE;
+#endif
+
+/* view command flags */
+	verbose_listing = FALSE;
+
+/* extract command flags */
+	output_to_stdout = FALSE;
+
+/* append command flags */
+	new_archive			= FALSE;
+	update_if_newer		= FALSE;
+	delete_after_append = FALSE;
+	generic_format		= FALSE;
+
+	remove_temporary_at_error 				= FALSE;
+	recover_archive_when_interrupt			= FALSE;
+	remove_extracting_file_when_interrupt	= FALSE;
+	get_filename_from_stdin					= FALSE;
+	ignore_directory						= FALSE;
+	verify_mode								= FALSE;
+
+	noconvertcase							= FALSE;
+
+	extract_directory = NULL;
+	xfilec = 257;
+}
+
+/* ------------------------------------------------------------------------ */
+/* NOTES :			Text File Format										*/
+/* GENERATOR		NewLine													*/
+/* [generic]		0D 0A													*/
+/* [MS-DOS]			0D 0A													*/
+/* [OS9][MacOS]		0D														*/
+/* [UNIX]			0A														*/
+/* ------------------------------------------------------------------------ */
+static void
+print_tiny_usage_and_exit()
+{
+	fprintf(stderr, "\
+LHarc    for UNIX  V 1.02  Copyright(C) 1989  Y.Tagawa\n\
+LHx      for MSDOS V C2.01 Copyright(C) 1990  H.Yoshizaki\n\
+LHx(arc) for OSK   V 2.01  Modified     1990  Momozou\n\
+LHa      for UNIX  V 1.00  Copyright(C) 1992  Masaru Oki\n\
+LHa      for UNIX  V 1.14  Modified     1995  Nobutaka Watazaki\n\
+LHa      for UNIX  V 1.14i Modified     2000  Tsugio Okamoto\n\
+");
+	fprintf(stderr, "\
+usage: lha [-]{axelvudmcp[q[num]][vnfodizg012]}[w=<dir>] archive_file [file...]\n\
+commands:                           options:\n\
+ a   Add(or replace) to archive      q{num} quiet (num:quiet mode)\n\
+ x,e EXtract from archive            v  verbose\n\
+ l,v List / Verbose List             n  not execute\n\
+ u   Update newer files to archive   f  force (over write at extract)\n\
+ d   Delete from archive             t  FILES are TEXT file\n");
+#ifdef SUPPORT_LH7
+	fprintf(stderr, "\
+ m   Move to archive (means 'ad')    o[567] compression method (a/u)\n\
+");
+#endif
+#ifndef SUPPORT_LH7
+	fprintf(stderr, "\
+ m   Move to archive (means 'ad')    o  use LHarc compatible method (a/u)\n\
+");
+#endif
+	fprintf(stderr, "\
+ c   re-Construct new archive        w=<dir> specify extract directory (a/u/m/x/e)\n\
+ p   Print to STDOUT from archive    d  delete FILES after (a/u/c)\n\
+ t   Test file CRC in archive        i  ignore directory path (x/e)\n\
+                                     z  files not compress (a/u)\n\
+                                     g  Generic format (for compatibility)\n\
+                                        or not convert case when extracting\n\
+                                     0/1/2 header level (a/u)\n\
+");
+#ifdef EUC
+	fprintf(stderr, "\
+                                     e  TEXT code convert from/to EUC\n\
+");
+#endif
+	exit(1);
+}
+
+/* ------------------------------------------------------------------------ */
+int
+main(argc, argv)
+	int             argc;
+	char           *argv[];
+{
+	char           *p, inpbuf[256];
+
+	int i;
+	int  ac;
+	char **av, *m;
+
+	init_variable();		/* Added N.Watazaki */
+
+	ac = argc;
+	av = (char **)malloc( sizeof(char*)*argc );
+	if (av == NULL) fatal_error("not enough memory\n");
+	for (i=0; i<argc; i++) {
+	  if ((av[i] = strdup( argv[i] )) == NULL)
+		fatal_error("not enough memory\n");
+	}
+
+	if (ac < 2)
+		print_tiny_usage_and_exit();
+
+	if (strcmp(av[1], "--version") == 0) {
+		print_version();
+		exit(1);
+	}
+
+	if (ac < 3) {
+		cmd = CMD_LIST;
+		av--; /* argv--; */ /* 1999.7.18 */
+		ac++; /* argc++; */
+		goto work;
+	}
+
+	m = av[1];
+
+	if (m[0] == '-')
+		m++;
+	/* commands */
+	switch (*m) {
+	case 'x':
+	case 'e':
+		cmd = CMD_EXTRACT;
+		break;
+
+	case 'p':
+		output_to_stdout = TRUE;
+		cmd = CMD_EXTRACT;
+		break;
+
+	case 'c':
+		new_archive = TRUE;
+		cmd = CMD_ADD;
+		break;
+
+	case 'a':
+		cmd = CMD_ADD;
+		break;
+
+	case 'd':
+		cmd = CMD_DELETE;
+		break;
+
+	case 'u':
+		update_if_newer = TRUE;
+		cmd = CMD_ADD;
+		break;
+
+	case 'm':
+		delete_after_append = TRUE;
+		cmd = CMD_ADD;
+		break;
+
+	case 'v':
+		verbose_listing = TRUE;
+		cmd = CMD_LIST;
+		break;
+
+	case 'l':
+		cmd = CMD_LIST;
+		break;
+
+	case 't':
+		cmd = CMD_EXTRACT;
+		verify_mode = TRUE;
+		break;
+
+	default:
+		print_tiny_usage_and_exit();
+
+	}
+
+	/* options */
+	/* p = &argv[1][1]; */
+	p = m+1;
+	while ( *p != 0 ) {
+		switch ((*p++)) {
+		case 'q':
+			switch (*p) {
+			case '0':
+			case '1':
+				quiet_mode = *p - '0';
+				++p;
+				break;
+			case '2':
+			default:
+				quiet = TRUE;
+				break;
+			}
+		case 'f':
+			force = TRUE;
+			break;
+		case 'p':
+			prof = TRUE;
+			break;
+		case 'v':
+			verbose = TRUE;
+			break;
+		case 't':
+			text_mode = TRUE;
+			break;
+#ifdef EUC
+		case 'e':
+			text_mode = TRUE;
+			euc_mode = TRUE;
+			break;
+#endif
+		case 'n':
+			noexec = TRUE;
+			break;
+		case 'g':
+			generic_format = TRUE;
+			noconvertcase = TRUE;
+			header_level = 0;
+			break;
+		case 'd':
+			delete_after_append = TRUE;
+			break;
+		case 'o':
+			switch (*p) {
+			case 0:
+				compress_method = LZHUFF1_METHOD_NUM;
+				header_level = 0;
+				break;
+			case '5':
+				compress_method = LZHUFF5_METHOD_NUM;
+				p++;
+				break;
+#ifdef SUPPORT_LH7
+			case '6':
+				compress_method = LZHUFF6_METHOD_NUM;
+				p++;
+				break;
+			case '7':
+				compress_method = LZHUFF7_METHOD_NUM;
+				p++;
+				break;
+#endif
+			default:
+				fprintf(stderr, "LHa: error option o%c\n", p[-1]);
+				exit(1);
+			}
+			break;
+		case 'z':
+			compress_method = LZHUFF0_METHOD_NUM;	/* Changed N.Watazaki */
+			break;
+		case 'i':
+			ignore_directory = TRUE;
+			break;
+		case 'w':
+			if (*p == '=')
+				p++;
+			extract_directory = p;
+			while (*p)
+				p++;
+			break;
+		case '0':
+			header_level = HEADER_LEVEL0;
+			break;
+		case '1':
+			header_level = HEADER_LEVEL1;
+			break;
+		case '2':
+			header_level = HEADER_LEVEL2;
+			break;
+		default:
+			fprintf(stderr, "LHa: Unknown option '%c'.\n", p[-1]);
+			exit(1);
+		}
+	}
+
+work:
+	/* archive file name */
+	archive_name = av[2];
+
+	if (!strcmp(archive_name, "-")) {
+		if (!isatty(1) && cmd == CMD_ADD)
+			quiet = TRUE;
+	}
+	else {
+		if (ac == 3 && !isatty(0)) { /* 1999.7.18 */
+			get_filename_from_stdin = TRUE;
+		}
+	}
+
+	/* target file name */
+	if (get_filename_from_stdin) {
+		cmd_filec = 0;
+		if ((xfilev = (char **) malloc(sizeof(char *) * xfilec)) == NULL)
+			fatal_error("Virtual memory exhausted\n");
+		while (fgets(inpbuf, sizeof(inpbuf), stdin)) {
+		    /* delete \n if it exist */
+			i=0; p=inpbuf;
+			while (i < sizeof(inpbuf) && p != 0) {
+			    if (*p == '\n') {
+				    *p = 0;
+					break;
+				}
+				p++; i++;
+			}
+
+			if (cmd_filec >= xfilec) {
+				xfilec += 256;
+				cmd_filev = (char **) realloc(xfilev,
+						   sizeof(char *) * xfilec);
+				if (cmd_filev == NULL)
+					fatal_error("Virtual memory exhausted\n");
+				xfilev = cmd_filev;
+			}
+			if (strlen(inpbuf) < 1)
+				continue;
+			if ((xfilev[cmd_filec++] = (char *) strdup(inpbuf)) == NULL)
+				fatal_error("Virtual memory exhausted\n");
+		}
+		xfilev[cmd_filec] = NULL;
+		cmd_filev = xfilev;
+	} else {
+		cmd_filec = ac - 3;
+		cmd_filev = av + 3;
+	}
+	sort_files();
+
+	/* make crc table */
+	make_crctable();
+
+	switch (cmd) {
+	case CMD_EXTRACT:
+		cmd_extract();
+		break;
+	case CMD_ADD:
+		cmd_add();
+		break;
+	case CMD_LIST:
+		cmd_list();
+		break;
+	case CMD_DELETE:
+		cmd_delete();
+		break;
+	}
+
+#ifdef USE_PROF
+	if (!prof)
+		exit(0);
+#endif
+
+	return 0;
+}
+
+
+/* ------------------------------------------------------------------------ */
+/* */
+/* ------------------------------------------------------------------------ */
+
+/* ------------------------------------------------------------------------ */
+static void
+print_version()
+{
+	fprintf(stderr, "%s\n", LHA_VERSION);
+}
+
+/* ------------------------------------------------------------------------ */
+static void
+message_1(title, subject, name)
+	char           *title, *subject, *name;
+{
+	fprintf(stderr, "LHa: %s%s ", title, subject);
+	fflush(stderr);
+
+	if (errno == 0)
+		fprintf(stderr, "%s\n", name);
+	else
+		perror(name);
+}
+
+/* ------------------------------------------------------------------------ */
+void
+message(subject, name)
+	char           *subject, *name;
+{
+	message_1("", subject, name);
+}
+
+/* ------------------------------------------------------------------------ */
+void
+warning(subject, name)
+	char           *subject, *name;
+{
+	message_1("Warning: ", subject, name);
+}
+
+/* ------------------------------------------------------------------------ */
+void
+error(subject, msg)
+	char           *subject, *msg;
+{
+	message_1("Error: ", subject, msg);
+}
+
+/* ------------------------------------------------------------------------ */
+void
+fatal_error(msg)
+	char           *msg;
+{
+	message_1("Fatal error:", "", msg);
+
+	if (remove_temporary_at_error)
+		unlink(temporary_name);
+
+	exit(1);
+}
+
+/* ------------------------------------------------------------------------ */
+void
+write_error()
+{
+	fatal_error(writting_filename);
+}
+
+/* ------------------------------------------------------------------------ */
+void
+read_error()
+{
+	fatal_error(reading_filename);
+}
+
+/* ------------------------------------------------------------------------ */
+void
+interrupt(signo)
+	int             signo;
+{
+	errno = 0;
+	message("Interrupted\n", "");
+
+	if (temporary_fp)
+		fclose(temporary_fp);
+	unlink(temporary_name);
+	if (recover_archive_when_interrupt)
+		rename(backup_archive_name, archive_name);
+	if (remove_extracting_file_when_interrupt) {
+		errno = 0;
+		message("Removing", writting_filename);
+		unlink(writting_filename);
+	}
+	signal(SIGINT, SIG_DFL);
+	signal(SIGHUP, SIG_DFL);
+	kill(getpid(), signo);
+}
+
+/* ------------------------------------------------------------------------ */
+/*																			*/
+/* ------------------------------------------------------------------------ */
+static int
+sort_by_ascii(a, b)
+	char          **a, **b;
+{
+	register char  *p, *q;
+	register int    c1, c2;
+
+	p = *a, q = *b;
+	if (generic_format) {
+		do {
+			c1 = *(unsigned char *) p++;
+			c2 = *(unsigned char *) q++;
+			if (!c1 || !c2)
+				break;
+			if (islower(c1))
+				c1 = toupper(c1);
+			if (islower(c2))
+				c2 = toupper(c2);
+		}
+		while (c1 == c2);
+		return c1 - c2;
+	}
+	else {
+		while (*p == *q && *p != '\0')
+			p++, q++;
+		return *(unsigned char *) p - *(unsigned char *) q;
+	}
+}
+
+/* ------------------------------------------------------------------------ */
+static void
+sort_files()
+{
+	if (cmd_filec > 1)
+		qsort(cmd_filev, cmd_filec, sizeof(char *), sort_by_ascii);
+}
+
+/* ------------------------------------------------------------------------ */
+char           *
+xmalloc(size)
+	int             size;
+{
+	char           *p = (char *) malloc(size);
+	if (!p)
+		fatal_error("Not enough memory");
+	return p;
+}
+
+/* ------------------------------------------------------------------------ */
+char           *
+xrealloc(old, size)
+	char           *old;
+	int             size;
+{
+	char           *p = (char *) realloc(old, size);
+	if (!p)
+		fatal_error("Not enough memory");
+	return p;
+}
+
+/* ------------------------------------------------------------------------ */
+/*								STRING POOL									*/
+/* ------------------------------------------------------------------------ */
+/*
+  string pool :
+	+-------------+-------------+------+-------------+----------+
+	| N A M E 1 \0| N A M E 2 \0| .... | N A M E n \0|			|
+	+-------------+-------------+------+-------------+----------+
+	  ^ ^		 ^ buffer+0 buffer+used buffer+size
+
+  vector :
+	+---------------+---------------+------------- -----------------+
+	| pointer to	| pointer to	| pointer to   ...  pointer to	|
+	|  stringpool	|  N A M E 1	|  N A M E 2   ...   N A M E n	|
+	+---------------+---------------+-------------     -------------+
+	^ malloc base      returned
+*/
+
+/* ------------------------------------------------------------------------ */
+void
+init_sp(sp)
+	struct string_pool *sp;
+{
+	sp->size = 1024 - 8;	/* any ( >=0 ) */
+	sp->used = 0;
+	sp->n = 0;
+	sp->buffer = (char *) xmalloc(sp->size * sizeof(char));
+}
+
+/* ------------------------------------------------------------------------ */
+void
+add_sp(sp, name, len)
+	struct string_pool *sp;
+	char           *name;	/* stored '\0' at tail */
+	int             len;	/* include '\0' */
+{
+	while (sp->used + len > sp->size) {
+		sp->size *= 2;
+		sp->buffer = (char *) xrealloc(sp->buffer, sp->size * sizeof(char));
+	}
+	bcopy(name, sp->buffer + sp->used, len);
+	sp->used += len;
+	sp->n++;
+}
+
+/* ------------------------------------------------------------------------ */
+void
+finish_sp(sp, v_count, v_vector)
+	register struct string_pool *sp;
+	int            *v_count;
+	char         ***v_vector;
+{
+	int             i;
+	register char  *p;
+	char          **v;
+
+	v = (char **) xmalloc((sp->n + 1) * sizeof(char *));
+	*v++ = sp->buffer;
+	*v_vector = v;
+	*v_count = sp->n;
+	p = sp->buffer;
+	for (i = sp->n; i; i--) {
+		*v++ = p;
+		if (i - 1)
+			p += strlen(p) + 1;
+	}
+}
+
+/* ------------------------------------------------------------------------ */
+void
+free_sp(vector)
+	char          **vector;
+{
+	vector--;
+	free(*vector);		/* free string pool */
+	free(vector);
+}
+
+
+/* ------------------------------------------------------------------------ */
+/*							READ DIRECTORY FILES							*/
+/* ------------------------------------------------------------------------ */
+static          boolean
+include_path_p(path, name)
+	char           *path, *name;
+{
+	char           *n = name;
+	while (*path)
+		if (*path++ != *n++)
+			return (path[-1] == '/' && *n == '\0');
+	return (*n == '/' || (n != name && path[-1] == '/' && n[-1] == '/'));
+}
+
+/* ------------------------------------------------------------------------ */
+void
+cleaning_files(v_filec, v_filev)
+	int            *v_filec;
+	char         ***v_filev;
+{
+	char           *flags;
+	struct stat     stbuf;
+
+	register char **filev = *v_filev;
+	register int    filec = *v_filec;
+	register char  *p;
+	register int    i, j;
+
+	if (filec == 0)
+		return;
+
+	flags = xmalloc(filec * sizeof(char));
+
+	/* flags & 0x01 :	1: ignore */
+	/* flags & 0x02 :	1: directory, 0 : regular file */
+	/* flags & 0x04 :	1: need delete */
+
+	
+	for (i = 0; i < filec; i++)
+		if (GETSTAT(filev[i], &stbuf) < 0) {
+			flags[i] = 0x04;
+			fprintf(stderr,
+			 "LHa: Cannot access \"%s\", ignored.\n", filev[i]);
+		}
+		else {
+			if (is_regularfile(&stbuf))
+				flags[i] = 0x00;
+			else if (is_directory(&stbuf))
+				flags[i] = 0x02;
+#ifdef S_IFLNK
+			else if (is_symlink(&stbuf)) /* t.okamoto */
+				flags[i] = 0x00;
+#endif			
+			else {
+				flags[i] = 0x04;
+				fprintf(stderr,
+					"LHa: Cannot archive \"%s\", ignored.\n", filev[i]);
+			}
+		}
+	errno = 0;
+
+	for (i = 0; i < filec; i++) {
+		p = filev[i];
+		if ((flags[i] & 0x07) == 0x00) {	/* regular file, not
+							 * deleted/ignored */
+			for (j = i + 1; j < filec; j++) {
+				if ((flags[j] & 0x07) == 0x00) {	/* regular file, not
+									 * deleted/ignored */
+					if (STREQU(p, filev[j]))
+						flags[j] = 0x04;	/* delete */
+				}
+			}
+		}
+		else if ((flags[i] & 0x07) == 0x02) {	/* directory, not
+							 * deleted/ignored */
+			for (j = i + 1; j < filec; j++) {
+				if ((flags[j] & 0x07) == 0x00) {	/* regular file, not
+									 * deleted/ignored */
+					if (include_path_p(p, filev[j]))
+						flags[j] = 0x04;	/* delete */
+				}
+				else if ((flags[j] & 0x07) == 0x02) {	/* directory, not
+									 * deleted/ignored */
+					if (include_path_p(p, filev[j]))
+						flags[j] = 0x04;	/* delete */
+				}
+			}
+		}
+	}
+
+	for (i = j = 0; i < filec; i++) {
+		if ((flags[i] & 0x04) == 0) {
+			if (i != j)
+				filev[j] = filev[i];
+			j++;
+		}
+	}
+	*v_filec = j;
+
+	free(flags);
+}
+
+/* ------------------------------------------------------------------------ */
+#ifdef NODIRECTORY
+/* please need your imprementation */
+boolean
+find_files(name, v_filec, v_filev)
+	char           *name;
+	int            *v_filec;
+	char         ***v_filev;
+{
+	return FALSE;		/* DUMMY */
+}
+
+/* ------------------------------------------------------------------------ */
+void
+free_files(filec, filev)
+	int             filec;
+	char          **filev;
+{
+	/* do nothing */
+}
+/* ------------------------------------------------------------------------ */
+#else
+boolean
+find_files(name, v_filec, v_filev)
+	char           *name;
+	int            *v_filec;
+	char         ***v_filev;
+{
+	struct string_pool sp;
+	char            newname[FILENAME_LENGTH];
+	int             len, n;
+	DIR            *dirp;
+	DIRENTRY       *dp;
+	struct stat     tmp_stbuf, arc_stbuf, fil_stbuf;
+
+	strcpy(newname, name);
+	len = strlen(name);
+	if (len > 0 && newname[len - 1] != '/')
+		newname[len++] = '/';
+
+	dirp = opendir(name);
+	if (!dirp)
+		return FALSE;
+
+	init_sp(&sp);
+
+	GETSTAT(temporary_name, &tmp_stbuf);
+	GETSTAT(archive_name, &arc_stbuf);
+
+	for (dp = readdir(dirp); dp != NULL; dp = readdir(dirp)) {
+		n = NAMLEN(dp);
+		strncpy(newname + len, dp->d_name, n);
+		newname[len + n] = '\0';
+		if (GETSTAT(newname, &fil_stbuf) < 0)
+			continue;
+#ifdef NO_INODE
+		if ( dp->d_name[0] != '.' ||
+			(n != 1 &&
+			 (dp->d_name[1] != '.' ||
+			  n != 2))  ) {
+			add_sp(&sp, newname, len+n+1);
+		}
+#else		
+		if ((dp->d_ino != 0) &&
+		/* exclude '.' and '..' */
+		    ((dp->d_name[0] != '.') ||
+		     ((n != 1) &&
+		      ((dp->d_name[1] != '.') ||
+		       (n != 2)))) &&
+		    ((tmp_stbuf.st_dev != fil_stbuf.st_dev ||
+		      tmp_stbuf.st_ino != fil_stbuf.st_ino) &&
+		     (arc_stbuf.st_dev != fil_stbuf.st_dev ||
+		      arc_stbuf.st_ino != fil_stbuf.st_ino))) {
+			add_sp(&sp, newname, len + n + 1);
+		}
+#endif
+	}
+	closedir(dirp);
+	finish_sp(&sp, v_filec, v_filev);
+	if (*v_filec > 1)
+		qsort(*v_filev, *v_filec, sizeof(char *), sort_by_ascii);
+	cleaning_files(v_filec, v_filev);
+
+	return TRUE;
+}
+
+/* ------------------------------------------------------------------------ */
+void
+free_files(filec, filev)
+	int             filec;
+	char          **filev;
+{
+	free_sp(filev);
+}
+#endif
+/* ------------------------------------------------------------------------ */
+/*																			*/
+/* ------------------------------------------------------------------------ */
+/* Build temporary file name and store to TEMPORARY_NAME */
+void
+build_temporary_name()
+{
+#ifdef TMP_FILENAME_TEMPLATE
+	/* "/tmp/lhXXXXXX" etc. */
+	if (extract_directory == NULL) {
+		strcpy(temporary_name, TMP_FILENAME_TEMPLATE);
+	}
+	else {
+		sprintf(temporary_name, "%s/lhXXXXXX", extract_directory);
+	}
+#ifdef MKSTEMP
+	mkstemp(temporary_name);
+#else
+	mktemp(temporary_name);
+#endif
+#else
+	char           *p, *s;
+
+	strcpy(temporary_name, archive_name);
+	for (p = temporary_name, s = (char *) 0; *p; p++)
+		if (*p == '/')
+			s = p;
+	strcpy((s ? s + 1 : temporary_name), "lhXXXXXX");
+#ifdef MKSTEMP
+	mkstemp(temporary_name);
+#else
+	mktemp(temporary_name);
+#endif
+#endif
+}
+
+/* ------------------------------------------------------------------------ */
+static void
+modify_filename_extention(buffer, ext)
+	char           *buffer;
+	char           *ext;
+{
+	register char  *p, *dot;
+
+	for (p = buffer, dot = (char *) 0; *p; p++) {
+		if (*p == '.')
+			dot = p;
+		else if (*p == '/')
+			dot = (char *) 0;
+	}
+
+	if (dot)
+		p = dot;
+
+	strcpy(p, ext);
+}
+
+/* ------------------------------------------------------------------------ */
+/* build backup file name */
+void
+build_backup_name(buffer, original)
+	char           *buffer;
+	char           *original;
+{
+	strcpy(buffer, original);
+	modify_filename_extention(buffer, BACKUPNAME_EXTENTION);	/* ".bak" */
+}
+
+/* ------------------------------------------------------------------------ */
+void
+build_standard_archive_name(buffer, orginal)
+	char           *buffer;
+	char           *orginal;
+{
+	strcpy(buffer, orginal);
+	modify_filename_extention(buffer, ARCHIVENAME_EXTENTION);	/* ".lzh" */
+}
+
+/* ------------------------------------------------------------------------ */
+/*																			*/
+/* ------------------------------------------------------------------------ */
+boolean
+need_file(name)
+	char           *name;
+{
+	int             i;
+
+	if (cmd_filec == 0)
+		return TRUE;
+
+	for (i = 0; i < cmd_filec; i++) {
+		if (patmatch(cmd_filev[i], name, 0))
+			return TRUE;
+	}
+
+	return FALSE;
+}
+
+FILE           *
+xfopen(name, mode)
+	char           *name, *mode;
+{
+	FILE           *fp;
+
+	if ((fp = fopen(name, mode)) == NULL)
+		fatal_error(name);
+
+	return fp;
+}
+
+/* ------------------------------------------------------------------------ */
+/*																			*/
+/* ------------------------------------------------------------------------ */
+static          boolean
+open_old_archive_1(name, v_fp)
+	char           *name;
+	FILE          **v_fp;
+{
+	FILE           *fp;
+	struct stat     stbuf;
+
+	if (stat(name, &stbuf) >= 0 &&
+	    is_regularfile(&stbuf) &&
+	    (fp = fopen(name, READ_BINARY)) != NULL) {
+		*v_fp = fp;
+		archive_file_gid = stbuf.st_gid;
+		archive_file_mode = stbuf.st_mode;
+		return TRUE;
+	}
+
+	*v_fp = NULL;
+	archive_file_gid = -1;
+	return FALSE;
+}
+
+/* ------------------------------------------------------------------------ */
+FILE           *
+open_old_archive()
+{
+	FILE           *fp;
+	char           *p;
+
+	if (!strcmp(archive_name, "-")) {
+		if (cmd == CMD_EXTRACT || cmd == CMD_LIST)
+			return stdin;
+		else
+			return NULL;
+	}
+	if (p = (char *) rindex(archive_name, '.')) {
+		if (strucmp(".LZH", p) == 0
+		    || strucmp(".LZS", p) == 0
+		    || strucmp(".COM", p) == 0	/* DOS SFX */
+		    || strucmp(".EXE", p) == 0
+		    || strucmp(".X", p) == 0	/* HUMAN SFX */
+		    || strucmp(".BAK", p) == 0) {	/* for BackUp */
+			open_old_archive_1(archive_name, &fp);
+			return fp;
+		}
+	}
+
+	if (open_old_archive_1(archive_name, &fp))
+		return fp;
+	sprintf(expanded_archive_name, "%s.lzh", archive_name);
+	if (open_old_archive_1(expanded_archive_name, &fp)) {
+		archive_name = expanded_archive_name;
+		return fp;
+	}
+	/*
+	 * if ( (errno&0xffff)!=E_PNNF ) { archive_name =
+	 * expanded_archive_name; return NULL; }
+	 */
+	sprintf(expanded_archive_name, "%s.lzs", archive_name);
+	if (open_old_archive_1(expanded_archive_name, &fp)) {
+		archive_name = expanded_archive_name;
+		return fp;
+	}
+	/*
+	 * if ( (errno&0xffff)!=E_PNNF ) { archive_name =
+	 * expanded_archive_name; return NULL; }
+	 */
+	/*
+	 * sprintf( expanded_archive_name , "%s.lzh",archive_name);
+	 * archive_name = expanded_archive_name;
+	 */
+	return NULL;
+}
+
+/* ------------------------------------------------------------------------ */
+int
+inquire(msg, name, selective)
+	char           *msg, *name, *selective;
+{
+	char            buffer[1024];
+	char           *p;
+
+	for (;;) {
+		fprintf(stderr, "%s %s ", name, msg);
+		fflush(stderr);
+
+		fgets(buffer, 1024, stdin);
+
+		for (p = selective; *p; p++)
+			if (buffer[0] == *p)
+				return p - selective;
+	}
+	/* NOTREACHED */
+}
+
+/* ------------------------------------------------------------------------ */
+void
+write_archive_tail(nafp)
+	FILE           *nafp;
+{
+	putc(0x00, nafp);
+}
+
+/* ------------------------------------------------------------------------ */
+void
+copy_old_one(oafp, nafp, hdr)
+	FILE           *oafp, *nafp;
+	LzHeader       *hdr;
+{
+	if (noexec) {
+		fseek(oafp, (long) (hdr->header_size + 2) + hdr->packed_size, SEEK_CUR);
+	}
+	else {
+		reading_filename = archive_name;
+		writting_filename = temporary_name;
+		if (hdr->header_level != 2) {
+			copyfile(oafp, nafp,
+					 (long) (hdr->header_size + 2) + hdr->packed_size, 0);
+		} else {
+			copyfile(oafp, nafp,
+					 (long) (hdr->header_size) + hdr->packed_size, 0);
+		}
+	}
+}
+
+/* Local Variables: */
+/* mode:c */
+/* tab-width:4 */
+/* compile-command:"gcc -c lharc.c" */
+/* End: */
--- lha-1.14i.orig/debian/org/util.c
+++ lha-1.14i/debian/org/util.c
@@ -0,0 +1,375 @@
+/* ------------------------------------------------------------------------ */
+/* LHa for UNIX    															*/
+/*				util.c -- LHarc Util										*/
+/*																			*/
+/*		Modified          		Nobutaka Watazaki							*/
+/*																			*/
+/*	Ver. 1.14 	Source All chagned				1995.01.14	N.Watazaki		*/
+/*  Ver. 1.14e  Support for sfx archives		1999.05.28	T.Okamoto       */
+/* ------------------------------------------------------------------------ */
+#include "lha.h"
+/*
+ * util.c - part of LHa for UNIX Feb 26 1992 modified by Masaru Oki Mar  4
+ * 1992 modified by Masaru Oki #ifndef USESTRCASECMP added. Mar 31 1992
+ * modified by Masaru Oki #ifdef NOMEMSET added.
+ */
+#include <errno.h>
+
+/* ------------------------------------------------------------------------ */
+extern unsigned short crc;
+extern int      quiet;
+/* ------------------------------------------------------------------------ */
+long
+copyfile(f1, f2, size, crc_flg)	/* return: size of source file */
+	FILE           *f1;
+	FILE           *f2;
+	long            size;
+	int             crc_flg;/* 0: no crc, 1: crc check, 2: extract, 3:
+				 * append */
+{
+	unsigned short  xsize;
+	char           *buf;
+	long            rsize = 0;
+
+	if ((buf = (char *) malloc(BUFFERSIZE)) == NULL)
+		fatal_error("virtual memory exhausted.\n");
+	crc = 0;
+	if ((crc_flg == 2 || crc_flg) && text_mode)
+		init_code_cache();
+	while (size > 0) {
+		/* read */
+		if (crc_flg == 3 && text_mode) {
+			xsize = fread_txt(buf, BUFFERSIZE, f1);
+			if (xsize == 0)
+				break;
+			if (ferror(f1)) {
+				fatal_error("file read error\n");
+			}
+		}
+		else {
+			xsize = (size > BUFFERSIZE) ? BUFFERSIZE : size;
+			if (fread(buf, 1, xsize, f1) != xsize) {
+				fatal_error("file read error\n");
+			}
+		}
+		/* write */
+		if (f2) {
+			if (crc_flg == 2 && text_mode) {
+				if (fwrite_txt(buf, xsize, f2)) {
+					fatal_error("file write error\n");
+				}
+			}
+			else {
+				if (fwrite(buf, 1, xsize, f2) != xsize) {
+					fatal_error("file write error\n");
+				}
+			}
+		}
+		/* calculate crc */
+		if (crc_flg) {
+			calccrc(buf, xsize);
+		}
+		rsize += xsize;
+		if (crc_flg != 3 || !text_mode)
+			size -= xsize;
+	}
+	free(buf);
+	return rsize;
+}
+
+/* ------------------------------------------------------------------------ */
+int
+encode_stored_crc(ifp, ofp, size, original_size_var, write_size_var)
+	FILE           *ifp, *ofp;
+	long            size;
+	long           *original_size_var;
+	long           *write_size_var;
+{
+	int             save_quiet;
+
+	save_quiet = quiet;
+	quiet = 1;
+	size = copyfile(ifp, ofp, size, 3);
+	*original_size_var = *write_size_var = size;
+	quiet = save_quiet;
+	return crc;
+}
+
+/* ------------------------------------------------------------------------ */
+/*	convert path delimit
+	erreturns *filename														*/
+/* ------------------------------------------------------------------------ */
+unsigned char  *
+convdelim(path, delim)
+	unsigned char  *path;
+	unsigned char   delim;
+{
+	unsigned char   c;
+	unsigned char  *p;
+#ifdef MULTIBYTE_CHAR
+	int             kflg;
+
+	kflg = 0;
+#endif
+	for (p = path; (c = *p) != 0; p++) {
+#ifdef MULTIBYTE_CHAR
+		if (kflg) {
+			kflg = 0;
+		}
+		else if (MULTIBYTE_FIRST_P(c)) {
+			kflg = 1;
+		}
+		else
+#endif
+		if (c == '\\' || c == DELIM || c == DELIM2) {
+			*p = delim;
+			path = p + 1;
+		}
+	}
+	return path;
+}
+
+/* ------------------------------------------------------------------------ */
+/* If TRUE, archive file name is msdos SFX file name. */
+boolean
+archive_is_msdos_sfx1(name)
+	char           *name;
+{
+	int             len = strlen(name);
+
+	return ((len >= 4) &&
+		(strucmp(".COM", name + len - 4) == 0 ||
+		 strucmp(".EXE", name + len - 4) == 0)) ||
+		((len >= 2) &&
+		 (strucmp(".x", name + len - 2) == 0));
+}
+
+/* ------------------------------------------------------------------------ */
+/* skip SFX header */
+boolean
+skip_msdos_sfx1_code(fp)
+	FILE           *fp;
+{
+	unsigned char   buffer[MAXSFXCODE];
+	unsigned char  *p, *q;
+	int             n;
+
+	n = fread(buffer, sizeof(char), MAXSFXCODE, fp);
+
+	for (p = buffer + 2, q = buffer + n - /* 5 */ (I_HEADER_LEVEL+1)-2; p < q; p++) {
+		/* found "-l??-" keyword (as METHOD type string) */
+		if (p[0] == '-' && p[1] == 'l' && p[4] == '-') {
+			/* size and checksum validate check */
+			if ( (p[I_HEADER_LEVEL-2] == 0 || p[I_HEADER_LEVEL-2] == 0)
+				&& p[I_HEADER_SIZE-2] > 20
+				&& p[I_HEADER_CHECKSUM-2] == calc_sum(p, p[-2])) {
+					fseek(fp, ((p - 2) - buffer) - n, SEEK_CUR);
+				return TRUE;
+			} else if (p[I_HEADER_LEVEL-2] == 2 && p[I_HEADER_SIZE-2] >= 24
+					   && p[I_ATTRIBUTE-2] == 0x20) {
+				fseek(fp, ((p - 2) - buffer) - n, SEEK_CUR);
+				return TRUE;
+			}
+		}
+	}
+
+	fseek(fp, -n, SEEK_CUR);
+	return FALSE;
+}
+
+/*
+ * strdup(3)
+ */
+
+/* ------------------------------------------------------------------------ */
+#ifdef NOSTRDUP
+char           *
+strdup(buf)
+	char           *buf;
+{
+	char           *p;
+
+	if ((p = (char *) malloc(strlen(buf) + 1)) == NULL)
+		return NULL;
+	strcpy(p, buf);
+	return p;
+}
+#endif
+
+/*
+ * memmove( char *dst , char *src , size_t cnt )
+ */
+
+/* ------------------------------------------------------------------------ */
+#if defined(NOBSTRING) && !defined(__STDC__)
+void           *
+memmove(dst, src, cnt)
+	register char  *dst, *src;
+	register int    cnt;
+{
+	if (dst == src)
+		return dst;
+	if (src > dst) {
+		while (--cnt >= 0)
+			*dst++ = *src++;
+	}
+	else {
+		dst += cnt;
+		src += cnt;
+		while (--cnt >= 0)
+			*--dst = *--src;
+	}
+	return dst;
+}
+#endif
+
+/*
+ * rename - change the name of file 91.11.02 by Tomohiro Ishikawa
+ * (ishikawa@gaia.cow.melco.CO.JP) 92.01.20 little modified (added #ifdef) by
+ * Masaru Oki 92.01.28 added mkdir() and rmdir() by Tomohiro Ishikawa
+ */
+
+#if defined(NOFTRUNCATE) && !defined(_MINIX)
+
+/* ------------------------------------------------------------------------ */
+int
+rename(from, to)
+	char           *from, *to;
+{
+	struct stat     s1, s2;
+	extern int      errno;
+
+	if (stat(from, &s1) < 0)
+		return (-1);
+	/* is 'FROM' file a directory? */
+	if ((s1.st_mode & S_IFMT) == S_IFDIR) {
+		errno = ENOTDIR;
+		return (-1);
+	}
+	if (stat(to, &s2) >= 0) {	/* 'TO' exists! */
+		/* is 'TO' file a directory? */
+		if ((s2.st_mode & S_IFMT) == S_IFDIR) {
+			errno = EISDIR;
+			return (-1);
+		}
+		if (unlink(to) < 0)
+			return (-1);
+	}
+	if (link(from, to) < 0)
+		return (-1);
+	if (unlink(from) < 0)
+		return (-1);
+	return (0);
+}
+#endif				/* NOFTRUNCATE */
+/* ------------------------------------------------------------------------ */
+
+#ifdef	NOMKDIR
+#ifndef	MKDIRPATH
+#define	MKDIRPATH	"/bin/mkdir"
+#endif
+#ifndef	RMDIRPATH
+#define	RMDIRPATH	"/bin/rmdir"
+#endif
+int
+rmdir(path)
+	char           *path;
+{
+	int             stat, rtn = 0;
+	char           *cmdname;
+	if ((cmdname = (char *) malloc(strlen(RMDIRPATH) + 1 + strlen(path) + 1))
+	    == 0)
+		return (-1);
+	strcpy(cmdname, RMDIRPATH);
+	*(cmdname + strlen(RMDIRPATH)) = ' ';
+	strcpy(cmdname + strlen(RMDIRPATH) + 1, path);
+	if ((stat = system(cmdname)) < 0)
+		rtn = -1;	/* fork or exec error */
+	else if (stat) {	/* RMDIR command error */
+		errno = EIO;
+		rtn = -1;
+	}
+	free(cmdname);
+	return (rtn);
+}
+
+/* ------------------------------------------------------------------------ */
+int
+mkdir(path, mode)
+	char           *path;
+	int             mode;
+{
+	int             child, stat;
+	char           *cmdname, *cmdpath = MKDIRPATH;
+	if ((cmdname = (char *) strrchr(cmdpath, '/')) == (char *) 0)
+		cmdname = cmdpath;
+	if ((child = fork()) < 0)
+		return (-1);	/* fork error */
+	else if (child) {	/* parent process */
+		while (child != wait(&stat))	/* ignore signals */
+			continue;
+	}
+	else {			/* child process */
+		int             maskvalue;
+		maskvalue = umask(0);	/* get current umask() value */
+		umask(maskvalue | (0777 & ~mode));	/* set it! */
+		execl(cmdpath, cmdname, path, (char *) 0);
+		/* never come here except execl is error */
+		return (-1);
+	}
+	if (stat != 0) {
+		errno = EIO;	/* cannot get error num. */
+		return (-1);
+	}
+	return (0);
+}
+#endif
+
+/*
+ * strucmp modified: Oct 29 1991 by Masaru Oki
+ */
+
+#ifndef USESTRCASECMP
+static int
+my_toupper(n)
+	register int    n;
+{
+	if (n >= 'a' && n <= 'z')
+		return n & (~('a' - 'A'));
+	return n;
+}
+
+/* ------------------------------------------------------------------------ */
+int
+strucmp(s, t)
+	register char  *s, *t;
+{
+	while (my_toupper(*s++) == my_toupper(*t++))
+		if (!*s || !*t)
+			break;
+	if (!*s && !*t)
+		return 0;
+	return 1;
+}
+#endif
+
+/* ------------------------------------------------------------------------ */
+#ifdef NOMEMSET
+/* Public Domain memset(3) */
+char           *
+memset(s, c, n)
+	char           *s;
+	int             c, n;
+{
+	char           *p = s;
+	while (n--)
+		*p++ = (char) c;
+	return s;
+}
+#endif
+
+/* Local Variables: */
+/* mode:c */
+/* tab-width:4 */
+/* compile-command:"gcc -c util.c" */
+/* End: */
--- lha-1.14i.orig/debian/org/lhext.c
+++ lha-1.14i/debian/org/lhext.c
@@ -0,0 +1,425 @@
+/* ------------------------------------------------------------------------ */
+/* LHa for UNIX    															*/
+/*				lhext.c -- LHarc extract									*/
+/*																			*/
+/*		Copyright (C) MCMLXXXIX Yooichi.Tagawa								*/
+/*		Modified          		Nobutaka Watazaki							*/
+/*																			*/
+/*  Ver. 0.00  Original								1988.05.23  Y.Tagawa	*/
+/*  Ver. 1.00  Fixed								1989.09.22  Y.Tagawa	*/
+/*  Ver. 0.03  LHa for UNIX							1991.12.17  M.Oki		*/
+/*  Ver. 1.12  LHa for UNIX							1993.10.01	N.Watazaki	*/
+/*  Ver. 1.13b Symbolic Link Update Bug Fix			1994.06.21	N.Watazaki	*/
+/*	Ver. 1.14  Source All chagned					1995.01.14	N.Watazaki	*/
+/*  Ver. 1.14e bugfix                               1999.04.30  T.Okamoto   */
+/* ------------------------------------------------------------------------ */
+#include "lha.h"
+/* ------------------------------------------------------------------------ */
+static int      skip_flg = FALSE;	/* FALSE..No Skip , TRUE..Skip */
+static char	   *methods[] =
+{
+	LZHUFF0_METHOD, LZHUFF1_METHOD, LZHUFF2_METHOD, LZHUFF3_METHOD,
+	LZHUFF4_METHOD, LZHUFF5_METHOD, LZHUFF6_METHOD, LZHUFF7_METHOD,
+	LARC_METHOD, LARC5_METHOD, LARC4_METHOD,
+	LZHDIRS_METHOD,
+	NULL
+};
+
+/* ------------------------------------------------------------------------ */
+static          boolean
+inquire_extract(name)
+	char           *name;
+{
+	struct stat     stbuf;
+
+	skip_flg = FALSE;
+	if (stat(name, &stbuf) >= 0) {
+		if (!is_regularfile(&stbuf)) {
+			error("Already exist (not a file)", name);
+			return FALSE;
+		}
+
+		if (noexec) {
+			printf("EXTRACT %s but file is exist.\n", name);
+			return FALSE;
+		}
+		else if (!force) {
+			if (!isatty(0))
+				return FALSE;
+
+			switch (inquire("OverWrite ?(Yes/[No]/All/Skip)", name, "YyNnAaSs\n")) {
+			case 0:
+			case 1:/* Y/y */
+				break;
+			case 2:
+			case 3:/* N/n */
+			case 8:/* Return */
+				return FALSE;
+			case 4:
+			case 5:/* A/a */
+				force = TRUE;
+				break;
+			case 6:
+			case 7:/* S/s */
+				skip_flg = TRUE;
+				break;
+			}
+		}
+	}
+	if (noexec)
+		printf("EXTRACT %s\n", name);
+
+	return TRUE;
+}
+
+/* ------------------------------------------------------------------------ */
+static          boolean
+make_parent_path(name)
+	char           *name;
+{
+	char            path[FILENAME_LENGTH];
+	struct stat     stbuf;
+	register char  *p;
+
+	/* make parent directory name into PATH for recursive call */
+	strcpy(path, name);
+	for (p = path + strlen(path); p > path; p--)
+		if (p[-1] == '/') {
+			*--p = '\0';
+			break;
+		}
+
+	if (p == path) {
+		message("Why?", "ROOT");
+		return FALSE;	/* no more parent. */
+	}
+
+	if (GETSTAT(path, &stbuf) >= 0) {
+		if (is_directory(&stbuf))
+			return TRUE;
+		error("Not a directory", path);
+		return FALSE;
+	}
+	errno = 0;
+
+	if (verbose)
+		printf("Making directory \"%s\".\n", path);
+
+	if (mkdir(path, 0777) >= 0)	/* try */
+		return TRUE;	/* successful done. */
+	errno = 0;
+
+	if (!make_parent_path(path))
+		return FALSE;
+
+	if (mkdir(path, 0777) < 0) {	/* try again */
+		message("Cannot make directory", path);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/* ------------------------------------------------------------------------ */
+static FILE    *
+open_with_make_path(name)
+	char           *name;
+{
+	FILE           *fp;
+
+	if ((fp = fopen(name, WRITE_BINARY)) == NULL) {
+		errno = 0;
+		if (!make_parent_path(name) ||
+		    (fp = fopen(name, WRITE_BINARY)) == NULL)
+			error("Cannot extract", name);
+		errno = 0;
+	}
+	return fp;
+}
+
+/* ------------------------------------------------------------------------ */
+static void
+adjust_info(name, hdr)
+	char           *name;
+	LzHeader       *hdr;
+{
+	time_t          utimebuf[2];
+
+	/* adjust file stamp */
+	utimebuf[0] = utimebuf[1] = hdr->unix_last_modified_stamp;
+
+	if ((hdr->unix_mode & UNIX_FILE_TYPEMASK) != UNIX_FILE_SYMLINK)
+		utime(name, utimebuf);
+
+	if (hdr->extend_type == EXTEND_UNIX
+	    || hdr->extend_type == EXTEND_OS68K
+	    || hdr->extend_type == EXTEND_XOSK) {
+#ifdef NOT_COMPATIBLE_MODE
+		Please need your modification in this space.
+#else
+		if ((hdr->unix_mode & UNIX_FILE_TYPEMASK) != UNIX_FILE_SYMLINK)
+			chmod(name, hdr->unix_mode);
+#endif
+		if (!getuid()) {
+#ifndef HAVE_NO_LCHOWN
+			if ((hdr->unix_mode & UNIX_FILE_TYPEMASK) == UNIX_FILE_SYMLINK)
+				lchown(name, hdr->unix_uid, hdr->unix_gid);
+			else
+#endif /* HAVE_NO_LCHWON */
+				chown(name, hdr->unix_uid, hdr->unix_gid);
+		}
+		errno = 0;
+	}
+}
+
+/* ------------------------------------------------------------------------ */
+static void
+extract_one(afp, hdr)
+	FILE           *afp;	/* archive file */
+	LzHeader       *hdr;
+{
+	FILE           *fp;	/* output file */
+	struct stat     stbuf;
+	char            name[257];
+	int             crc;
+	int             method;
+	boolean         save_quiet, save_verbose, up_flag;
+	char           *q = hdr->name, c;
+
+	if (ignore_directory && rindex(hdr->name, '/')) {
+		q = (char *) rindex(hdr->name, '/') + 1;
+	}
+	else {
+		if (*q == '/') {
+			q++;
+			/*
+			 * if OSK then strip device name
+			 */
+			if (hdr->extend_type == EXTEND_OS68K
+			    || hdr->extend_type == EXTEND_XOSK) {
+				do
+					c = (*q++);
+				while (c && c != '/');
+				if (!c || !*q)
+					q = ".";	/* if device name only */
+			}
+		}
+	}
+
+	if (extract_directory)
+		sprintf(name, "%s/%s", extract_directory, q);
+	else
+		strcpy(name, q);
+
+
+	/* LZHDIRS_METHODを持つヘッダをチェックする */
+	/* 1999.4.30 t.okamoto */
+	for (method = 0;; method++) {
+		if (methods[method] == NULL) {
+			error("Unknown method skiped ...", name);
+			return;
+		}
+		if (bcmp(hdr->method, methods[method], 5) == 0)
+			break;
+	}
+
+	if ((hdr->unix_mode & UNIX_FILE_TYPEMASK) == UNIX_FILE_REGULAR
+		&& method != LZHDIRS_METHOD_NUM) {
+#if 0
+		for (method = 0;; method++) {
+			if (methods[method] == NULL) {
+				error("Unknown method skiped ...", name);
+				return;
+			}
+			if (bcmp(hdr->method, methods[method], 5) == 0)
+				break;
+		}
+#endif
+
+		reading_filename = archive_name;
+		writting_filename = name;
+		if (output_to_stdout || verify_mode) {
+			if (noexec) {
+				printf("%s %s\n", verify_mode ? "VERIFY" : "EXTRACT", name);
+				if (afp == stdin) {
+					int             i = hdr->packed_size;
+					while (i--)
+						fgetc(afp);
+				}
+				return;
+			}
+
+			save_quiet = quiet;
+			save_verbose = verbose;
+			if (!quiet && output_to_stdout) {
+				printf("::::::::\n%s\n::::::::\n", name);
+				quiet = TRUE;
+				verbose = FALSE;
+			}
+			else if (verify_mode) {
+				quiet = FALSE;
+				verbose = TRUE;
+			}
+
+			crc = decode_lzhuf
+				(afp, stdout, hdr->original_size, hdr->packed_size, name, method);
+			quiet = save_quiet;
+			verbose = save_verbose;
+		}
+		else {
+			if (skip_flg == FALSE)  {
+				up_flag = inquire_extract(name);
+				if (up_flag == FALSE && force == FALSE) {
+					return;
+				}
+			}
+
+			if (skip_flg == TRUE) {	/* if skip_flg */
+				if (stat(name, &stbuf) == 0 && force != TRUE) {
+					if (stbuf.st_mtime >= hdr->unix_last_modified_stamp) {
+						if (quiet != TRUE)
+							printf("%s : Skipped...\n", name);
+						return;
+					}
+				}
+			}
+			if (noexec) {
+				if (afp == stdin) {
+					int i = hdr->packed_size;
+					while (i--)
+						fgetc(afp);
+				}
+				return;
+			}
+
+			signal(SIGINT, interrupt);
+			signal(SIGHUP, interrupt);
+
+			unlink(name);
+			errno = 0;
+			remove_extracting_file_when_interrupt = TRUE;
+
+			if ((fp = open_with_make_path(name)) != NULL) {
+				crc = decode_lzhuf
+					(afp, fp, hdr->original_size, hdr->packed_size, name, method);
+				fclose(fp);
+			}
+			remove_extracting_file_when_interrupt = FALSE;
+			signal(SIGINT, SIG_DFL);
+			signal(SIGHUP, SIG_DFL);
+
+			if (!fp)
+				return;
+		}
+
+		errno = 0;
+		if (hdr->has_crc && crc != hdr->crc)
+			error("CRC error", name);
+	}
+	else if ((hdr->unix_mode & UNIX_FILE_TYPEMASK) == UNIX_FILE_DIRECTORY
+			 || (hdr->unix_mode & UNIX_FILE_TYPEMASK) == UNIX_FILE_SYMLINK
+			 || method == LZHDIRS_METHOD_NUM) {
+		/* ↑これで、Symblic Link は、大丈夫か？ */
+		if (!ignore_directory && !verify_mode) {
+			if (noexec) {
+				if (quiet != TRUE)
+					printf("EXTRACT %s (directory)\n", name);
+				return;
+			}
+			/* NAME has trailing SLASH '/', (^_^) */
+			if ((hdr->unix_mode & UNIX_FILE_TYPEMASK) == UNIX_FILE_SYMLINK) {
+				char            buf[256], *bb1, *bb2;
+				int             l_code;
+				strcpy(buf, name);
+				bb1 = strtok(buf, "|");
+				bb2 = strtok(NULL, "|");
+
+#ifdef S_IFLNK
+				if (skip_flg == FALSE)  {
+					up_flag = inquire_extract(name);
+					if (up_flag == FALSE && force == FALSE) {
+						return;
+					}
+				} else {
+					if (GETSTAT(bb1, &stbuf) == 0 && force != TRUE) {
+						if (stbuf.st_mtime >= hdr->unix_last_modified_stamp) {
+							if (quiet != TRUE)
+								printf("%s : Skipped...\n", bb1);
+							return;
+						}
+					}
+				}
+
+				unlink(bb1);
+				l_code = symlink(bb2, bb1);
+				if (l_code < 0) {
+					if (quiet != TRUE)
+						warning("Can't make Symbolic Link : ");
+				}
+				if (quiet != TRUE) {
+					printf("Symbolic Link %s -> %s\n", bb1, bb2);
+				}
+				strcpy(name, bb1);	/* Symbolic's name set */
+#else
+				sprintf(buf, "%s -> %s", bb1, bb2);
+				warning("Can't make Symbolic Link", buf);
+				return;
+#endif
+			} else { /* make directory */
+				if (!output_to_stdout && !make_parent_path(name))
+					return;
+			}
+		}
+	}
+	else {
+		error("Unknown information", name);
+	}
+
+	if (!output_to_stdout)
+		adjust_info(name, hdr);
+}
+
+/* ------------------------------------------------------------------------ */
+/* EXTRACT COMMAND MAIN														*/
+/* ------------------------------------------------------------------------ */
+void
+cmd_extract()
+{
+	LzHeader        hdr;
+	long            pos;
+	FILE           *afp;
+
+	/* open archive file */
+	if ((afp = open_old_archive()) == NULL)
+		fatal_error(archive_name);
+
+	if (archive_is_msdos_sfx1(archive_name))
+		skip_msdos_sfx1_code(afp);
+
+	/* extract each files */
+	while (get_header(afp, &hdr)) {
+		if (need_file(hdr.name)) {
+			pos = ftell(afp);
+			extract_one(afp, &hdr);
+			fseek(afp, pos + hdr.packed_size, SEEK_SET);
+		} else {
+			if (afp != stdin)
+				fseek(afp, hdr.packed_size, SEEK_CUR);
+			else {
+				int             i = hdr.packed_size;
+				while (i--)
+					fgetc(afp);
+			}
+		}
+	}
+
+	/* close archive file */
+	fclose(afp);
+
+	return;
+}
+
+/* Local Variables: */
+/* mode:c */
+/* tab-width:4 */
+/* End: */
--- lha-1.14i.orig/debian/org/lha_macro.h
+++ lha-1.14i/debian/org/lha_macro.h
@@ -0,0 +1,420 @@
+/* ------------------------------------------------------------------------ */
+/* LHa for UNIX    Archiver Driver	macro define							*/
+/*																			*/
+/*		Modified          		Nobutaka Watazaki							*/
+/*																			*/
+/*	Ver. 1.14	Soruce All chagned				1995.01.14	N.Watazaki		*/
+/*	Ver. 1.14g	modified   						2000.05.06	T.OKAMOTO		*/
+/* ------------------------------------------------------------------------ */
+
+#define LHA_VERSION "lha for unix version 1.14i"
+
+/* Most of System V, define SYSTIME_HAS_NO_TM */
+#ifdef	SYSTIME_HAS_NO_TM
+#include <time.h>
+#else
+#include <sys/time.h>
+#endif	/* SYSTIME_HAS_NO_TM */
+
+/* ------------------------------------------------------------------------ */
+/*	Directory Access Stuff													*/
+/* ------------------------------------------------------------------------ */
+#ifndef NODIRECTORY
+#ifdef SYSV_SYSTEM_DIR
+
+#include <dirent.h>
+
+#define DIRENTRY	struct dirent
+#define NAMLEN(p)	strlen (p->d_name)
+
+#else	/* not SYSV_SYSTEM_DIR */
+
+#ifdef NONSYSTEM_DIR_LIBRARY
+#include "lhdir.h"
+#else
+#include <sys/dir.h>
+#endif	/* not NONSYSTEM_DIR_LIBRARY */
+
+#define DIRENTRY		struct direct
+#define NAMLEN(p)		p->d_namlen
+
+#endif	/* not SYSV_SYSTEM_DIR */
+#endif  /* NODIRECTORY */
+
+/* ------------------------------------------------------------------------ */
+/*	Other Define															*/
+/* ------------------------------------------------------------------------ */
+/* Not support 'void' */
+#ifdef NOVOID
+#define void
+#endif
+
+#ifndef SEEK_SET
+#define SEEK_SET		0
+#define SEEK_CUR		1
+#define SEEK_END		2
+#endif	/* SEEK_SET
+
+
+/* non-integral functions */
+extern struct tm *localtime();
+extern char    *getenv();
+
+#ifndef _MINIX
+#ifndef __STDC__
+extern char    *malloc();
+extern char    *realloc();
+#endif
+#endif
+
+/* external variables */
+extern int      errno;
+
+#define	FALSE			0
+#define TRUE			1
+typedef int				boolean;
+
+/* used by qsort() for alphabetic-sort */
+#define STRING_COMPARE(a,b)		strcmp((a),(b))
+
+#define FILENAME_LENGTH	1024
+
+/* ------------------------------------------------------------------------ */
+/* YOUR CUSTOMIZIES															*/
+/* ------------------------------------------------------------------------ */
+
+#ifndef ARCHIVENAME_EXTENTION
+#define ARCHIVENAME_EXTENTION	".lzh"
+#endif
+#ifndef BACKUPNAME_EXTENTION
+#define BACKUPNAME_EXTENTION	".bak"
+#endif
+#ifndef TMP_FILENAME_TEMPLATE
+#define TMP_FILENAME_TEMPLATE	"/tmp/lhXXXXXX"
+#endif
+
+#define SJC_FIRST_P(c)			\
+  (((unsigned char)(c) >= 0x80) &&	\
+   (((unsigned char)(c) < 0xa0) ||	\
+    ((unsigned char)(c) >= 0xe0) &&	\
+    ((unsigned char)(c) < 0xfd)))
+#define SJC_SECOND_P(c)			\
+  (((unsigned char)(c) >= 0x40) &&	\
+   ((unsigned char)(c) < 0xfd) &&	\
+   ((unsigned char)(c) != 0x7f))
+
+#ifdef MULTIBYTE_CHAR
+#define MULTIBYTE_FIRST_P	SJC_FIRST_P
+#define MULTIBYTE_SECOND_P	SJC_SECOND_P
+#endif				/* MULTIBYTE_CHAR */
+
+/* ------------------------------------------------------------------------ */
+/*	LHa File Definitions													*/
+/* ------------------------------------------------------------------------ */
+#ifdef S_IFLNK
+#define GETSTAT lstat
+#else
+#define GETSTAT stat
+#endif
+
+#ifdef LHA_MAIN_SRC
+#define EXTERN
+#else
+#define EXTERN				extern
+#endif	/* LHA_MAIN_SRC */
+
+#define LZHUFF0_METHOD			"-lh0-"
+#define LZHUFF1_METHOD			"-lh1-"
+#define LZHUFF2_METHOD			"-lh2-"
+#define LZHUFF3_METHOD			"-lh3-"
+#define LZHUFF4_METHOD			"-lh4-"
+#define LZHUFF5_METHOD			"-lh5-"
+#define LZHUFF6_METHOD			"-lh6-"
+#define LZHUFF7_METHOD			"-lh7-"
+#define LARC_METHOD				"-lzs-"
+#define LARC5_METHOD			"-lz5-"
+#define LARC4_METHOD			"-lz4-"
+#define LZHDIRS_METHOD			"-lhd-"
+
+#define METHOD_TYPE_STRAGE		5
+
+/* Added N.Watazaki ..V */
+#define LZHUFF0_METHOD_NUM		0
+#define LZHUFF1_METHOD_NUM		1
+#define LZHUFF2_METHOD_NUM		2
+#define LZHUFF3_METHOD_NUM		3
+#define LZHUFF4_METHOD_NUM		4
+#define LZHUFF5_METHOD_NUM		5
+#define LZHUFF6_METHOD_NUM		6
+#define LZHUFF7_METHOD_NUM		7
+#define LARC_METHOD_NUM			8
+#define LARC5_METHOD_NUM		9
+#define LARC4_METHOD_NUM		10
+#define LZHDIRS_METHOD_NUM		11
+/* Added N.Watazaki ..^ */
+
+#define I_HEADER_SIZE			0
+#define I_HEADER_CHECKSUM		1
+#define I_METHOD				2
+#define I_PACKED_SIZE			7
+#define I_ORIGINAL_SIZE			11
+#define I_LAST_MODIFIED_STAMP	15
+#define I_ATTRIBUTE				19
+#define I_HEADER_LEVEL			20
+#define I_NAME_LENGTH			21
+#define I_NAME					22
+
+#define I_CRC						22	/* + name_length */
+#define I_EXTEND_TYPE				24	/* + name_length */
+#define I_MINOR_VERSION				25	/* + name_length */
+#define I_UNIX_LAST_MODIFIED_STAMP	26	/* + name_length */
+#define I_UNIX_MODE					30	/* + name_length */
+#define I_UNIX_UID					32	/* + name_length */
+#define I_UNIX_GID					34	/* + name_length */
+#define I_UNIX_EXTEND_BOTTOM		36	/* + name_length */
+
+#define I_GENERIC_HEADER_BOTTOM		I_EXTEND_TYPE
+
+#define EXTEND_GENERIC			0
+#define EXTEND_UNIX				'U'
+#define EXTEND_MSDOS			'M'
+#define EXTEND_MACOS			'm'
+#define EXTEND_OS9				'9'
+#define EXTEND_OS2				'2'
+#define EXTEND_OS68K			'K'
+#define EXTEND_OS386			'3'	/* OS-9000??? */
+#define EXTEND_HUMAN			'H'
+#define EXTEND_CPM				'C'
+#define EXTEND_FLEX				'F'
+#define EXTEND_RUNSER			'R'
+
+/* this OS type is not official */
+
+#define EXTEND_TOWNSOS			'T'
+#define EXTEND_XOSK				'X'
+
+/*---------------------------------------------------------------------------*/
+
+#define GENERIC_ATTRIBUTE				0x20
+#define GENERIC_DIRECTORY_ATTRIBUTE		0x10
+#define HEADER_LEVEL0					0x00
+#define HEADER_LEVEL1					0x01
+#define HEADER_LEVEL2					0x02
+
+#define CURRENT_UNIX_MINOR_VERSION		0x00
+
+#define DELIM		('/')
+#define DELIM2		(0xff)
+#define DELIMSTR	"/"
+
+#define OSK_RW_RW_RW			0000033
+#define OSK_FILE_REGULAR		0000000
+#define OSK_DIRECTORY_PERM		0000200
+#define OSK_SHARED_PERM			0000100
+#define OSK_OTHER_EXEC_PERM		0000040
+#define OSK_OTHER_WRITE_PERM	0000020
+#define OSK_OTHER_READ_PERM		0000010
+#define OSK_OWNER_EXEC_PERM		0000004
+#define OSK_OWNER_WRITE_PERM	0000002
+#define OSK_OWNER_READ_PERM		0000001
+
+#define UNIX_FILE_TYPEMASK		0170000
+#define UNIX_FILE_REGULAR		0100000
+#define UNIX_FILE_DIRECTORY		0040000
+#define UNIX_FILE_SYMLINK		0120000
+#define UNIX_SETUID				0004000
+#define UNIX_SETGID				0002000
+#define UNIX_STYCKYBIT			0001000
+#define UNIX_OWNER_READ_PERM	0000400
+#define UNIX_OWNER_WRITE_PERM	0000200
+#define UNIX_OWNER_EXEC_PERM	0000100
+#define UNIX_GROUP_READ_PERM	0000040
+#define UNIX_GROUP_WRITE_PERM	0000020
+#define UNIX_GROUP_EXEC_PERM	0000010
+#define UNIX_OTHER_READ_PERM	0000004
+#define UNIX_OTHER_WRITE_PERM	0000002
+#define UNIX_OTHER_EXEC_PERM	0000001
+#define UNIX_RW_RW_RW			0000666
+
+#define LZHEADER_STRAGE			4096
+
+#define MAX_INDICATOR_COUNT		64
+
+typedef short   				node;
+
+/* ------------------------------------------------------------------------ */
+/*	Slide relation															*/
+/* ------------------------------------------------------------------------ */
+#if defined(__STDC__) || defined(AIX)
+
+#include <limits.h>
+
+#else
+
+#ifndef CHAR_BIT
+#define CHAR_BIT  8
+#endif
+
+#ifndef UCHAR_MAX
+#define UCHAR_MAX				((1<<(sizeof(unsigned char)*8))-1)
+#endif
+
+#ifndef USHRT_MAX
+#define USHRT_MAX				((1<<(sizeof(unsigned short)*8))-1)
+#endif
+
+#ifndef SHRT_MAX
+#define SHRT_MAX				((1<<(sizeof(short)*8-1))-1)
+#endif
+
+#ifndef SHRT_MIN
+#define SHRT_MIN				(SHRT_MAX-USHRT_MAX)
+#endif
+
+#ifndef ULONG_MAX
+#define ULONG_MAX	((1<<(sizeof(unsigned long)*8))-1)
+#endif
+
+#ifndef LONG_MAX
+#define LONG_MAX	((1<<(sizeof(long)*8-1))-1)
+#endif
+
+#ifndef LONG_MIN
+#define LONG_MIN	(LONG_MAX-ULONG_MAX)
+#endif
+
+#endif	/* not __STDC__ */
+
+/* ------------------------------------------------------------------------ */
+/*	FILE Attribute															*/
+/* ------------------------------------------------------------------------ */
+#define is_directory(statp)		(((statp)->st_mode & S_IFMT) == S_IFDIR)
+#define is_symlink(statp)		(((statp)->st_mode & S_IFMT) == S_IFLNK)
+#define is_regularfile(statp)	(((statp)->st_mode & S_IFMT) == S_IFREG)
+
+#ifdef MSDOS
+#define WRITE_BINARY	"wb"
+#define READ_BINARY		"rb"
+#else
+#define WRITE_BINARY	"w"
+#define READ_BINARY		"r"
+#endif
+
+/* ------------------------------------------------------------------------ */
+/*	Memory and String function												*/
+/* ------------------------------------------------------------------------ */
+#include <string.h>
+
+#ifdef NOINDEX
+#define index			strchr
+#define rindex			strrchr
+#endif	/* NOINDEX */
+
+#ifdef NOBSTRING
+#define bcmp(a,b,n)		memcmp ((a),(b),(n))
+#define bzero(d,n)		memset((d),0,(n))
+#define bcopy(s,d,n)	memmove((d),(s),(n))
+#endif	/* NOBSTRING */
+
+#ifdef USESTRCASECMP
+#define strucmp(p,q)	strcasecmp((p),(q))
+#endif
+
+/* ------------------------------------------------------------------------ */
+/* Individual macro define													*/
+/* ------------------------------------------------------------------------ */
+
+/* from crcio.c */
+#define CRCPOLY			0xA001		/* CRC-16 */
+#define UPDATE_CRC(c)	crc = crctable[(crc ^ (c)) & 0xFF] ^ (crc >> CHAR_BIT)
+
+/* dhuf.c */
+#define N_CHAR      (256 + 60 - THRESHOLD + 1)
+#define TREESIZE_C  (N_CHAR * 2)
+#define TREESIZE_P  (128 * 2)
+#define TREESIZE    (TREESIZE_C + TREESIZE_P)
+#define ROOT_C      0
+#define ROOT_P      TREESIZE_C
+
+/* header.c */
+#define setup_get(PTR)	(get_ptr = (PTR))
+#define get_byte()		(*get_ptr++ & 0xff)
+#define put_ptr			get_ptr
+#define setup_put(PTR)	(put_ptr = (PTR))
+#define put_byte(c)		(*put_ptr++ = (char)(c))
+
+/* huf.c */
+#define NP			(MAX_DICBIT + 1)
+#define NT			(USHRT_BIT + 3)
+#if 0
+#define PBIT		4		/* smallest integer such that (1 << PBIT) > * NP */
+#define TBIT 		5		/* smallest integer such that (1 << TBIT) > * NT */
+#endif
+
+#define PBIT		5		/* smallest integer such that (1 << PBIT) > * NP */
+#define TBIT 		5		/* smallest integer such that (1 << TBIT) > * NT */
+
+#define NC 			(UCHAR_MAX + MAXMATCH + 2 - THRESHOLD)
+
+/*		#if NT > NP #define NPT NT #else #define NPT NP #endif	*/
+#define NPT			0x80
+
+/* larc.c */
+#define MAGIC0		18
+#define MAGIC5		19
+
+/* lharc.c */
+#define CMD_UNKNOWN	0
+#define CMD_EXTRACT	1
+#define CMD_ADD		2
+#define CMD_LIST	3
+#define CMD_DELETE	4
+
+#define STREQU(a,b)	(((a)[0] == (b)[0]) ? (strcmp ((a),(b)) == 0) : FALSE)
+
+/* shuf.c */
+#define N1			286				/* alphabet size */
+#define N2			(2 * N1 - 1)	/* # of nodes in Huffman tree */
+#define EXTRABITS	8				/* >= log2(F-THRESHOLD+258-N1) */
+#define BUFBITS		16				/* >= log2(MAXBUF) */
+#define LENFIELD	4				/* bit size of length field for tree output */
+
+/* util.c */
+#define BUFFERSIZE	2048
+#define MAXSFXCODE	1024*64
+
+#ifndef NULL
+#define NULL		(char *)0
+#endif
+
+/* slide.c */
+/*
+#define PERCOLATE  1
+#define NIL        0
+#define HASH(p, c) ((p) + ((c) << hash1) + hash2)
+*/
+
+/* slide.c */
+#ifdef SUPPORT_LH7
+#define MAX_DICBIT			16      /* lh7 use 16bits */
+#endif
+
+#ifndef SUPPORT_LH7
+#define MAX_DICBIT			15      /* lh6 use 15bits */
+#endif
+
+#define MAX_DICSIZ			(1 << MAX_DICBIT)
+#define MATCHBIT			8	/* bits for MAXMATCH - THRESHOLD */
+#define MAXMATCH			256	/* formerly F (not more than UCHAR_MAX + 1) */
+#define THRESHOLD			3	/* choose optimal value */
+
+/* from huf.c */
+
+/* alphabet = {0, 1, 2, ..., NC - 1} */
+#define CBIT				9	/* $\lfloor \log_2 NC \rfloor + 1$ */
+#define USHRT_BIT			16	/* (CHAR_BIT * sizeof(ushort)) */
+
+/* Local Variables: */
+/* mode:c */
+/* tab-width:4 */
+/* End: */
--- lha-1.14i.orig/debian/org/lhlist.c
+++ lha-1.14i/debian/org/lhlist.c
@@ -0,0 +1,348 @@
+/* ------------------------------------------------------------------------ */
+/* LHa for UNIX    															*/
+/*				lhlist.c -- LHarc list										*/
+/*																			*/
+/*		Copyright (C) MCMLXXXIX Yooichi.Tagawa								*/
+/*		Modified          		Nobutaka Watazaki							*/
+/*																			*/
+/*  Ver. 0.00	Original						1988.05.23  Y.Tagawa		*/
+/*  Ver. 1.00	Fixed							1989.09.22  Y.Tagawa		*/
+/*  Ver. 1.01	Bug Fix for month name			1989.12.25  Y.Tagawa		*/
+/*  Ver. 1.10	Changed list format				1993.10.01	N.Watazaki		*/
+/*	Ver. 1.14	Source All chagned				1995.01.14	N.Watazaki		*/
+/*	Ver. 1.14e	Bug Fix for many problems		1999.05.25  T.Okamoto       */
+/* ------------------------------------------------------------------------ */
+#include "lha.h"
+
+/* ------------------------------------------------------------------------ */
+static long     packed_size_total;
+static long     original_size_total;
+static int      list_files;
+
+/* ------------------------------------------------------------------------ */
+/* Print Stuff																*/
+/* ------------------------------------------------------------------------ */
+/* need 14 or 22 (when verbose_listing is TRUE) column spaces */
+static void
+print_size(packed_size, original_size)
+	long            packed_size, original_size;
+{
+	if (verbose_listing)
+		printf("%7d ", packed_size);
+
+	printf("%7d ", original_size);
+
+	if (original_size == 0L)
+		printf("******");
+	else	/* Changed N.Watazaki */
+		printf("%5.1f%%", packed_size * 100.0 / original_size);
+}
+
+/* ------------------------------------------------------------------------ */
+/* need 12 or 17 (when verbose_listing is TRUE) column spaces */
+static void
+print_stamp(t)
+	time_t          t;
+{
+	static boolean  got_now = FALSE;
+	static time_t   now;
+	static unsigned int threshold;
+	static char     t_month[12 * 3 + 1] = "JanFebMarAprMayJunJulAugSepOctNovDec";
+	struct tm      *p;
+
+	if (t == 0) {
+		printf("            ");	/* 12 spaces */
+		return;
+	}
+
+	if (!got_now) {
+		now = time((time_t *) 0);
+		p = localtime(&now);
+		threshold = p->tm_year * 12 + p->tm_mon - 6;
+		got_now = TRUE;
+	}
+
+	p = localtime(&t);
+
+	if (p->tm_year * 12 + p->tm_mon > threshold)
+		printf("%.3s %2d %02d:%02d",
+		&t_month[p->tm_mon * 3], p->tm_mday, p->tm_hour, p->tm_min);
+	else
+		printf("%.3s %2d  %04d",
+		    &t_month[p->tm_mon * 3], p->tm_mday, p->tm_year + 1900);
+}
+
+/* ------------------------------------------------------------------------ */
+static void
+print_bar()
+{
+	char           *p, *q;
+	/* 17+1+(0 or 7+1)+7+1+6+1+(0 or 1+4)+(12 or 17)+1+20 */
+	/* 12345678901234567_  1234567_123456  _123456789012   1234 */
+
+	if (verbose_listing) {
+		p = "- ------ ---------- ";
+		q = " -------------";
+	}
+	else {
+		p = " ";
+		q = " --------------------";
+	}
+
+	if (verbose)
+		q = "";
+
+	printf("---------- ----------- ------- ------%s------------%s\n", p, q);
+}
+
+/* ------------------------------------------------------------------------ */
+/*																			*/
+/* ------------------------------------------------------------------------ */
+static void
+list_header()
+{
+	char           *p, *q;
+
+	if (verbose_listing) {
+		p = "PACKED    SIZE  RATIO METHOD CRC";
+		q = "          NAME";
+	}
+	else {
+		p = "  SIZE  RATIO";
+		q = "           NAME";
+	}
+
+	if (verbose)
+		q = "";
+
+	printf(" PERMSSN    UID  GID    %s     STAMP%s\n", p, q);
+#if 0
+	printf(" PERMSSN  UID GID %s   SIZE  RATIO%s %s    STAMP%s%s\n",
+	       verbose_listing ? " PACKED " : "",	/* 8,0 */
+	       verbose_listing ? "  CRC" : "",	/* 5,0 */
+	       verbose_listing ? "  " : "",	/* 2,0 */
+	       verbose_listing ? "      " : "   ",	/* 6,3 */
+	       verbose ? "" : " NAME");
+#endif
+	print_bar();
+}
+
+/* ------------------------------------------------------------------------ */
+static void
+list_one(hdr)
+	register LzHeader *hdr;
+{
+	register int    mode;
+	register char  *p;
+	char            method[6];
+	char modebits[11];
+
+	if (verbose)
+		printf("%s\n", hdr->name);
+
+	strncpy(method, hdr->method, 5);
+	method[5] = '\0';
+
+	switch (mode = hdr->extend_type) {
+	case EXTEND_UNIX:
+		mode = hdr->unix_mode;
+
+		if (mode & UNIX_FILE_DIRECTORY)
+			modebits[0] = 'd';
+		else if ((mode & UNIX_FILE_SYMLINK) == UNIX_FILE_SYMLINK)
+			modebits[0] = 'l';
+		else
+			modebits[0] = '-';
+		modebits[1] = ((mode & UNIX_OWNER_READ_PERM) ? 'r' : '-');
+		modebits[2] = ((mode & UNIX_OWNER_WRITE_PERM) ? 'w' : '-');
+		modebits[3] = (mode & UNIX_SETUID) ? 's' :
+			((mode & UNIX_OWNER_EXEC_PERM) ? 'x' : '-');
+		modebits[4] = ((mode & UNIX_GROUP_READ_PERM) ? 'r' : '-');
+		modebits[5] = ((mode & UNIX_GROUP_WRITE_PERM) ? 'w' : '-');
+		modebits[6] = (mode & UNIX_SETGID) ? 's' :
+			((mode & UNIX_GROUP_EXEC_PERM) ? 'x' : '-');
+		modebits[7] = ((mode & UNIX_OTHER_READ_PERM) ? 'r' : '-');
+		modebits[8] = ((mode & UNIX_OTHER_WRITE_PERM) ? 'w' : '-');
+		modebits[9] = (mode & UNIX_STYCKYBIT) ? 't' :
+			((mode & UNIX_OTHER_EXEC_PERM) ? 'x' : '-');
+		modebits[10] = 0;
+
+		printf("%s %5d/%-5d ", modebits,
+		       hdr->unix_uid, hdr->unix_gid);
+		break;
+	case EXTEND_OS68K:
+	 /**/ case EXTEND_XOSK:/**/
+		mode = hdr->unix_mode;
+		printf("%c%c%c%c%c%c%c%c %5d/%-5d",
+		       ((mode & OSK_DIRECTORY_PERM) ? 'd' : '-'),
+		       ((mode & OSK_SHARED_PERM) ? 's' : '-'),
+		       ((mode & OSK_OTHER_EXEC_PERM) ? 'e' : '-'),
+		       ((mode & OSK_OTHER_WRITE_PERM) ? 'w' : '-'),
+		       ((mode & OSK_OTHER_READ_PERM) ? 'r' : '-'),
+		       ((mode & OSK_OWNER_EXEC_PERM) ? 'e' : '-'),
+		       ((mode & OSK_OWNER_WRITE_PERM) ? 'w' : '-'),
+		       ((mode & OSK_OWNER_READ_PERM) ? 'r' : '-'),
+		       hdr->unix_uid, hdr->unix_gid);
+		break;
+	default:
+		switch (hdr->extend_type) {	/* max 18 characters */
+		case EXTEND_GENERIC:
+			p = "[generic]";
+			break;
+		case EXTEND_CPM:
+			p = "[CP/M]";
+			break;
+		case EXTEND_FLEX:
+			p = "[FLEX]";
+			break;
+		case EXTEND_OS9:
+			p = "[OS-9]";
+			break;
+		case EXTEND_OS68K:
+			p = "[OS-9/68K]";
+			break;
+		case EXTEND_MSDOS:
+			p = "[MS-DOS]";
+			break;
+		case EXTEND_MACOS:
+			p = "[Mac OS]";
+			break;
+		case EXTEND_OS2:
+			p = "[OS/2]";
+			break;
+		case EXTEND_HUMAN:
+			p = "[Human68K]";
+			break;
+		case EXTEND_OS386:
+			p = "[OS-386]";
+			break;
+		case EXTEND_RUNSER:
+			p = "[Runser]";
+			break;
+#ifdef EXTEND_TOWNSOS
+			/* This ID isn't fixed */
+		case EXTEND_TOWNSOS:
+			p = "[TownsOS]";
+			break;
+#endif
+			/* Ouch!  Please customize it's ID.  */
+		default:
+			p = "[unknown]";
+			break;
+		}
+		printf("%-23.23s", p);
+		break;
+	}
+
+	print_size(hdr->packed_size, hdr->original_size);
+
+	if (verbose_listing)
+		if (hdr->has_crc)
+			printf(" %s %04x", method, hdr->crc);
+		else
+			printf(" %s ****", method);
+
+	printf(" ");
+	print_stamp(hdr->unix_last_modified_stamp);
+
+	if (!verbose)
+		if ((mode & UNIX_FILE_SYMLINK) != UNIX_FILE_SYMLINK)
+			printf(" %s", hdr->name);
+		else {
+			char            buf[256], *b1, *b2;
+			strcpy(buf, hdr->name);
+			b1 = strtok(buf, "|");
+			b2 = strtok(NULL, "|");
+			printf(" %s -> %s", b1, b2);
+		}
+
+	if (verbose)
+		printf(" [%d]", hdr->header_level);
+	printf("\n");
+
+}
+
+/* ------------------------------------------------------------------------ */
+static void
+list_tailer()
+{
+	struct stat     stbuf;
+
+	print_bar();
+
+	printf(" Total %9d file%c ",
+	       list_files, (list_files == 1) ? ' ' : 's');
+	print_size(packed_size_total, original_size_total);
+	printf(" ");
+
+	if (verbose_listing)
+		printf("           ");
+
+	if (stat(archive_name, &stbuf) < 0)
+		print_stamp((time_t) 0);
+	else
+		print_stamp(stbuf.st_mtime);
+
+	printf("\n");
+}
+
+/* ------------------------------------------------------------------------ */
+/* LIST COMMAND MAIN														*/
+/* ------------------------------------------------------------------------ */
+void
+cmd_list()
+{
+	FILE           *afp;
+	LzHeader        hdr;
+	int             i;
+
+	/* initialize total count */
+	packed_size_total = 0L;
+	original_size_total = 0L;
+	list_files = 0;
+
+	/* open archive file */
+	if ((afp = open_old_archive()) == NULL) {
+		error(archive_name, "");
+		exit(1);
+	}
+	if (archive_is_msdos_sfx1(archive_name))
+		skip_msdos_sfx1_code(afp);
+
+	/* print header message */
+	if (!quiet)
+		list_header();
+
+	/* print each file information */
+	while (get_header(afp, &hdr)) {
+		if (need_file(hdr.name)) {
+			list_one(&hdr);
+			list_files++;
+			packed_size_total += hdr.packed_size;
+			original_size_total += hdr.original_size;
+		}
+
+		if (afp != stdin)
+			fseek(afp, hdr.packed_size, SEEK_CUR);
+		else {
+			i = hdr.packed_size;
+			while (i--)
+				fgetc(afp);
+		}
+	}
+
+	/* close archive file */
+	fclose(afp);
+
+	/* print tailer message */
+	if (!quiet)
+		list_tailer();
+
+	return;
+}
+
+/* Local Variables: */
+/* mode:c */
+/* tab-width:4 */
+/* compile-command:"gcc -c lhlist.c" */
+/* End: */
--- lha-1.14i.orig/debian/changelog
+++ lha-1.14i/debian/changelog
@@ -0,0 +1,178 @@
+lha (1.14i-10.1) unstable; urgency=high
+
+  * Security NMU for vulnerabilities inherited from GNU Gzip:
+    [CVE-2006-4335 CVE-2006-4337 CVE-2006-4338]
+
+ -- Moritz Muehlenhoff <jmm@debian.org>  Wed, 13 Dec 2006 20:21:32 +0100
+
+lha (1.14i-10) unstable; urgency=high
+
+  * debian/patch.redhat-sec2: Add one more security patch to fix:
+      - CAN-2004-0771 (-w working directory option buffer overflow)
+        http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2004-0771
+      - CAN-2004-0769 (buffer overflow can be executed arbitrary code
+        via long pathnames in headers, another issue of bug fixed in -9)
+        http://cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2004-0769
+      - CAN-2004-0745 (execute arbitrary commands via a directory with
+        shell metacharacters in its name.)
+        http://cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2004-0745
+      - CAN-2004-0694 (reserved number)
+        http://cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2004-0694
+    taken from RedHat patch.  (Closes: #279870)
+  * man/lha.n: Fix typo "flie" instead of "file".  (Closes: #277545)
+
+ -- GOTO Masanori <gotom@debian.org>  Sat, 13 Nov 2004 15:31:22 +0900
+
+lha (1.14i-9) unstable; urgency=high
+
+  * debian/patch.header-overflow: Add fix another lha buffer overflow
+    problem.  It warns when hitting an archive which includes
+    long directory name with option l, v, x.  See:
+      http://lw.ftw.zamosc.pl/lha-exploit.txt
+      http://www.securityfocus.com/archive/1/363418
+      http://bugs.gentoo.org/show_bug.cgi?id=51285
+    Thanks to Lukasz Wojtow <lw@wszia.edu.pl> for pointing this problem.
+
+ -- GOTO Masanori <gotom@debian.org>  Wed, 16 Jun 2004 09:51:06 +0900
+
+lha (1.14i-8) unstable; urgency=high
+
+  * debian/patch.CAN-2004-0234_0235: Add fix CAN-2004-0235 symlink part
+    patches.  (Closes: #247355, #247357)
+
+ -- GOTO Masanori <gotom@debian.org>  Sat,  8 May 2004 02:24:57 +0900
+
+lha (1.14i-7) unstable; urgency=high
+
+  * debian/patch.CAN-2004-ulf: Add to fix CAN-2004-0234 (buffer overflows),
+    CAN-2004-0235 (directory traversal).  See:
+    http://marc.theaimsgroup.com/?l=full-disclosure&m=108345064008698&w=2
+  * debian/control: Change my mail address.
+
+ -- GOTO Masanori <gotom@debian.org>  Thu,  6 May 2004 15:13:14 +0900
+
+lha (1.14i-6) unstable; urgency=low
+
+  * debian/copyright: Added more copyright license statement, translated
+    by Osamu Aoki <debian@aokiconsulting.com>.
+  * debian/copyright: Added good summary of upstream author, investigated by
+    Osamu Aoki <debian@aokiconsulting.com> and 
+    Tatsuya Kinoshita <tats@iris.ne.jp>.
+  * debian/header-e.doc: Added English version of header.doc (LHa header
+    structure format document) translated by Osamu Aoki
+    <debian@aokiconsulting.com>.
+
+ -- GOTO Masanori <gotom@debian.or.jp>  Tue, 27 Aug 2002 13:08:22 +0900
+
+lha (1.14i-5) unstable; urgency=low
+
+  * debian/patch.multibyte: Add multibyte character mode option 'y'.
+    You can use multibyte filename especially SHIFTJIS code 
+    with this option.
+
+ -- GOTO Masanori <gotom@debian.or.jp>  Fri, 19 Jul 2002 16:57:11 +0900
+
+lha (1.14i-4) unstable; urgency=low
+
+  * debian/copyright: add original/translated license statement
+    (closes: Bug#144582).
+
+ -- GOTO Masanori <gotom@debian.or.jp>  Wed,  1 May 2002 09:53:24 +0900
+
+lha (1.14i-3) unstable; urgency=low
+
+  * fix lha reports a wrong version number (closes: Bug#135199).
+
+ -- GOTO Masanori <gotom@debian.or.jp>  Sun,  3 Mar 2002 21:38:46 +0900
+
+lha (1.14i-2) unstable; urgency=low
+
+  * Applied the patch not to get compiling warning message.
+    Patched by Paul Slootman <paul@wurtel.net>. (Closes: #109634).
+
+ -- GOTO Masanori <gotom@debian.or.jp>  Thu, 23 Aug 2001 00:26:53 +0900
+
+lha (1.14i-1) unstable; urgency=low
+
+  * New upstream release (Closes: #62256).
+  * New maintainer.
+  * Updated Standards-version 3.5.2.
+  * Use build this package with dh_*.
+  * New upstream version is ready for -lh7- format (Closes: #67592).
+  * Japanese manual is now included (Closes: #49245).
+  * Unclosed Bugs (No copyright file is included) 
+    has just re-closed (Closes: #48748).
+
+ -- GOTO Masanori <gotom@debian.or.jp>  Sun, 22 Jul 2001 13:11:50 +0900
+
+lha (1.14e-2) unstable; urgency=low
+
+  * Moved /usr/man/* and /usr/doc/* under /usr/share. Closes: #80759.
+  * Updated Standards-version, fixed lintian warnings.
+
+ -- Steve McIntyre <stevem@chiark.greenend.org.uk>  Sun, 21 Jan 2001 17:35:52 +0000
+
+lha (1.14e-0) unstable; urgency=low
+
+  * New upstream release. Thanks to Jiro Iwamoto <iwamot@maroon.plala.or.jp> for pointing this out.
+
+ -- Steve McIntyre <stevem@chiark.greenend.org.uk>  Sun, 25 Jul 1999 23:05:24 +0100
+
+lha (1.14d-1) unstable; urgency=low
+
+  * Fixed manpage - no need to specify "-b" for command line help. Closes bug #33328.
+
+ -- Steve McIntyre <stevem@chiark.greenend.org.uk>  Sun, 14 Feb 1999 16:24:44 +0000
+
+lha (1.14d-0) unstable; urgency=low
+
+  * New upstream release. Thanks to Tomohiro KUBOTA <kubota@kubota.rcpom.osaka-u.ac.jp> for pointing this out.
+
+ -- Steve McIntyre <stevem@chiark.greenend.org.uk>  Sat, 16 Jan 1999 21:54:37 +0000
+
+lha (1.14c-1) frozen unstable; urgency=low
+
+  * New man page, supplied by Martin Schulze <joey@finlandia.Infodrom.North.DE>. Fixes Bug#27195.
+
+ -- Steve McIntyre <stevem@chiark.greenend.org.uk>  Sun, 18 Oct 1998 13:53:12 +0100
+
+lha (1.14c-0) unstable; urgency=low
+
+  * New upstream release. Thanks to Atsushi KAMOSHIDA <kamop@debian.or.jp> for pointing this out.
+
+ -- Steve McIntyre <stevem@chiark.greenend.org.uk>  Sat, 15 Aug 1998 14:16:19 +0100
+
+lha (1.00-6) unstable; urgency=low
+
+  * New maintainer.
+
+ -- Steve McIntyre <stevem@chiark.greenend.org.uk>  Mon, 12 Jan 1998 00:09:12 +0000
+
+lha (1.00-5) unstable; urgency=low, closes=16756
+
+  * Corrected Standards-Version to 2.3.0.1 (Bug#16756)
+
+ -- Martin Schulze <joey@finlandia.infodrom.north.de>  Fri, 9 Jan 1998 02:08:03 +0100
+
+lha (1.00-4) unstable; urgency=low
+
+  * Compiled against libc6 (Bug#11696)
+
+ -- Martin Schulze <joey@finlandia.infodrom.north.de>  Wed, 31 Dec 1997 20:51:38 +0100
+
+lha (1.00-3) unstable; urgency=low
+
+  * Corrected manpage (Bug#7980)
+  
+  * New maintainer address
+
+ -- Martin Schulze <joey@namib.north.de>  Mon, 28 Apr 1997 13:10:10 +0200
+
+lha (1.00-2) unstable; urgency=low
+
+  * Installed ChangeLog files
+  
+  * Converted into new packaging scheme
+
+ -- Martin Schulze <joey@namib.north.de>  Sun, 23 Feb 1997 12:22:13 +0100
+
--- lha-1.14i.orig/debian/lha.1
+++ lha-1.14i/debian/lha.1
@@ -0,0 +1,139 @@
+		  .\" lha - LZH un-archiver
+.\" Copyright (c) 1996  Martin Schulze <joey@namib.north.de>
+.\" 
+.\" This manual page is free software; you can redistribute it and/or modify
+.\" it under the terms of the GNU General Public License as published by
+.\" the Free Software Foundation; either version 2 of the License, or
+.\" (at your option) any later version.
+.\" 
+.\" This program is distributed in the hope that it will be useful,
+.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
+.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+.\" GNU General Public License for more details.
+.\" 
+.\" You should have received a copy of the GNU General Public License
+.\" along with this program; if not, write to the Free Software
+.\" Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+.\"
+.\" This manpage is written especially for Debian GNU/Linux.
+.\"
+.\" LHarc    for UNIX  V 1.02  Copyright(C) 1989  Y.Tagawa     
+.\" LHx      for MSDOS V C2.01 Copyright(C) 1990  H.Yoshizaki  
+.\" LHx(arc) for OSK   V 2.01  Modified     1990  Momozou      
+.\" LHa      for UNIX  V 1.00  Copyright(C) 1992  Masaru Oki   
+.\" 
+.\" Additions by Joerg Boehnke <joerg@oggi.oche.de>
+.\" 
+.TH LHA 1 "22 Sept, 1998" "Debian GNU/Linux" "Archiver"
+.SH NAME
+LHa \- LZH un-archiver
+.SH SYNOPSIS
+.B lha
+.B key
+[
+.B -
+]
+.B {axelvudmcp}
+[
+.B qvnfodizg012
+]
+[
+.B w=<dir>
+]
+.I archive_file
+[
+.I flie
+\&.\|.\|. ]
+.br
+.B lha
+.I archive_file
+.SH DESCRIPTION
+The
+.B lha
+program displays or extracts the contents of a LZH archive.
+
+For a list of commands, please refer to the executable.  It will
+display a list of valid commands and modifiers if you omit any
+parameter.
+
+.TP
+commands:
+                           
+.B a
+Add(or replace) to archive
+
+.B x,e
+EXtract from archive
+    
+.B l,v
+List / Verbose List        
+         
+.B u        
+Update newer files to archive  
+
+.B d
+Delete from archive        
+         
+.B m
+Move to archive (means 'ad')   
+
+.B c        
+re-Construct new archive       
+
+.B p        
+Print to STDOUT from archive   
+
+.B t        
+Test file CRC in archive
+
+.TP
+options: 
+                                
+.B q
+quiet                                
+
+.B v
+verbose                              
+
+.B n
+not execute                          
+
+.B f
+force (over write at extract)        
+
+.B t
+FILES are TEXT file                  
+
+.B o 
+use LHarc compatible method (a/u)    
+
+.B w=<dir>
+specify extract directory (x/e) 
+
+.B d
+delete FILES after (a/u/c)           
+
+.B i
+ignore directory path (x/e)          
+
+.B z
+files not compress (a/u)             
+
+.B g  
+[Generic] format (for compatibility) 
+
+.B 0/1/2 
+header level (a/u)                
+
+.B e  
+TEXT code convert from/to EUC        
+
+.B y
+filename multibyte convert
+
+.SH BUGS
+
+This manpage is poor, it really should be improved, but the original
+is in Japanese.
+
+Try lha without any command line arguments to get help
--- lha-1.14i.orig/debian/rules
+++ lha-1.14i/debian/rules
@@ -0,0 +1,115 @@
+#!/usr/bin/make -f
+# Sample debian/rules that uses debhelper.
+# GNU copyright 1997 to 1999 by Joey Hess.
+
+# Uncomment this to turn on verbose mode.
+#export DH_VERBOSE=1
+
+# This is the debhelper compatability version to use.
+export DH_COMPAT=3
+
+configure: configure-stamp
+configure-stamp:
+	dh_testdir
+	# Add here commands to configure the package.
+	
+	patch -p0 < debian/patch.paul
+	patch -p0 < debian/patch.multibyte
+	patch -p0 < debian/patch.CAN-2004-0234_0235
+	patch -p0 < debian/patch.header-overflow
+	patch -p1 < debian/patch.redhat-sec2
+	patch -p1 < debian/patch.CVE-2006-4335-CVE-2006-4337-CVE-2006-4338
+
+	touch configure-stamp
+
+build: configure-stamp build-stamp
+build-stamp:
+	dh_testdir
+
+	# Add here commands to compile the package.
+	$(MAKE)
+	#/usr/bin/docbook-to-man debian/lha.sgml > lha.1
+
+	touch build-stamp
+
+clean:
+	dh_testdir
+	dh_testroot
+	rm -f build-stamp configure-stamp
+
+	# Add here commands to clean up after the build process.
+	-$(MAKE) clean
+
+	# delete copied docs.
+	rm -f MACHINES MACHINES2 PROBLEMS README
+	rm -f header.doc debian/lha.euc.1.gz debian/lha.1.gz
+	cp debian/org/lha.h src/lha.h
+	cp debian/org/header.c src/header.c
+	cp debian/org/lharc.c src/lharc.c
+	cp debian/org/util.c src/util.c
+	cp debian/org/lhext.c src/lhext.c
+	cp debian/org/lhlist.c src/lhlist.c
+	cp debian/org/lha_macro.h src/lha_macro.h
+
+	dh_clean
+
+install: build
+	dh_testdir
+	dh_testroot
+	dh_clean -k
+	dh_installdirs
+
+	# Add here commands to install the package into debian/lha.
+	# $(MAKE) install BINDIR=$(CURDIR)/debian/lha/usr/bin \
+	#		MANDIR=$(CURDIR)/debian/lha/usr/share/man \
+	#		MANSECT=1
+	install -m 755 src/lha $(CURDIR)/debian/lha/usr/bin
+
+	# Copy the filenames without the .euc extension
+	cp MACHINES.euc MACHINES 
+	cp MACHINES2.euc MACHINES2
+	cp PROBLEMS.euc PROBLEMS 
+	cp README.euc README 
+	cp header.doc.euc header.doc
+
+	gzip -9 -c man/lha.n > debian/lha.euc.1.gz
+	gzip -9 -c debian/lha.1 > debian/lha.1.gz
+	install -m 644 debian/lha.euc.1.gz $(CURDIR)/debian/lha/usr/share/man/ja/man1/lha.1.gz
+	install -m 644 debian/lha.1.gz $(CURDIR)/debian/lha/usr/share/man/man1/lha.1.gz
+
+# Build architecture-independent files here.
+binary-indep: build install
+# We have nothing to do by default.
+
+# Build architecture-dependent files here.
+binary-arch: build install
+	dh_testdir
+	dh_testroot
+#	dh_installdebconf	
+	dh_installdocs
+	dh_installexamples
+	dh_installmenu
+#	dh_installlogrotate
+#	dh_installemacsen
+#	dh_installpam
+#	dh_installmime
+#	dh_installinit
+#	dh_installcron
+#	dh_installman
+#	dh_installinfo
+#	dh_undocumented
+	dh_installchangelogs CHANGES.euc
+	dh_link
+	dh_strip
+	dh_compress
+	dh_fixperms
+#	dh_makeshlibs
+	dh_installdeb
+#	dh_perl
+	dh_shlibdeps
+	dh_gencontrol
+	dh_md5sums
+	dh_builddeb
+
+binary: binary-indep binary-arch
+.PHONY: build clean binary-indep binary-arch binary install configure
--- lha-1.14i.orig/debian/dirs
+++ lha-1.14i/debian/dirs
@@ -0,0 +1,3 @@
+usr/bin
+usr/share/man/man1
+usr/share/man/ja/man1/
--- lha-1.14i.orig/debian/copyright
+++ lha-1.14i/debian/copyright
@@ -0,0 +1,172 @@
+This package was debianized by Atsushi KAMOSHIDA kamop@post1.com on
+Sun, 13 Apr 1997 17:52:59 +0900.
+
+It was downloaded from http://www2m.biglobe.ne.jp/~dolphin/lha/lha.htm
+
+Upstream Authors: 
+
+      LHarc 0.01-1.00:   Yooichi Tagawa (LHa code taken from here, 1988-1989)
+     	  Nikkei-mix ID: y.tagawa (Now this is defunct BBS, Licensing term
+     	  in manual page come from his licence for lharc)
+     	  His new web page seems to be www2s.biglibe.ne.jp/~yex/
+     	  yooedit2001@yahoo.co.jp is the contact e-mail address for another
+     	  software.  Page updated at least July/2001
+     	  
+      LHa   0.01-1.00:   Masaru Oki     (LHa original author, 1991-1992)
+     	  E-Mail address: oki@netbsd.org
+     
+      LHa   1.10-1.14:   Nobutaka Watazaki (Last official release? 1993-1995)
+	  ALICE-NET       ALS00595    Nasty
+	  E-Mail          JBD02514@niftyserve.or.jp
+	  E-Mail          femcs@mbox.kyoto-inet.or.jp
+	  NIFTY-Serve     JBD02514
+	  E-Mail address: watazaki@shimadzu.co.jp
+	  E-Mail address: watazaki@shimadzusd.co.jp
+     	  
+      Lha   1.14a-1.14e: Tsugio Okamoto <tsugio@muc.biglobe.ne.jp> (1996-2000)
+     
+
+Copyright:
+
+Original Source Code License Statement:
+
+   /*    Copyright (C) MCMLXXXIX Yooichi.Tagawa                      */
+   /*    Modified                Nobutaka Watazaki                   */
+   /*                   Thanks to H.Yoshizaki. (MS-DOS LHarc)        */
+
+
+Original Authors License Statement (from man/lha.man, in Japanese
+EUC-JP):
+
+   再配布について
+       以下の条件で、再配布、転載、改変を許可します。
+
+       1.     著作権表示を削除しないこと。
+
+       2.     配布内容については、
+
+              a.     配布の際に存在する内容(すなわち ソー ス コー
+                     ド、 ド キュメント、プログラマーへの手引きな
+                     ど)が再配布されたものの中に必ず存在 す る こ
+                     と。 改 変されているならば、それを明示したド
+                     キュメントを用意すること。
+
+              b.     LHa に対する付加価値が付けられて再配布される
+                     場合にはそれらもできるだけ含めるよう努力する
+                     こと。また、その際には付加価値が付けられてい
+                     ることを明示したドキュメントを用意すること。
+
+              c.     バイナリのみの配布は許されない。(付加価値 の
+                     ものも含む)
+
+       3.     最新版の配布に務めること。(義務はない)
+
+              注.    なお、ネットでの配付は自由であるが、ネットに
+                     アクセスできない方（雑誌および、 CDROM な ど
+                     に よる）配付は、配付前にこちらに EMail をお
+                     願いします。配付前に出来ない際には、後日必ず
+                     EMail をお願いします。
+
+       4.      このプログラムの存在や使用したことによって生じた損
+              害は全く保証しない。
+
+       5.     作者は、このプログラムに不備があっても、それを訂 正
+              する義務を負わない。
+
+       6.      このプログラムの一部、または全部を他のプログラムに
+              組み込んで利用してもかまわない。この場合、そのプ ロ
+              グラムは LHa ではなく、 LHa と名乗ってはいけない。
+
+       7.      商利用に関しては、上記の条件に加え、下記の条件のも
+              とにこれを認める。
+
+              a.     このプログラムをメインとする商利用は禁 止 す
+                     る。
+
+              b.     商利用の相手がこのプログラムの使用者として不
+                     適切と判断した場合には配布しない。
+
+              c.     インストールの手段として使用する場合、このプ
+                     ログラムを使うことを相手に強制しない。この場
+                     合、商利用者が作業を行う。また、そのときの損
+                     害は、商利用者が全責任を負う。
+
+              d.     商利用を付加価値として行いこのプログラムを使
+                     用する場合、商利用者は、そのサポートを行う。
+
+
+Original Authors License Statement (from man/lha.man, translated by
+Osamu Aoki <debian@aokiconsulting.com>):
+
+   Permission is given for redistribution, copy, and modification provided
+   following conditions are met.
+   
+   1. Do not remove copyright clause.
+   2. Distribution shall conform:
+    a. The content of redistribution (i.e., source code, documentation,
+       and reference guide for programmers) shall include original contents.
+       If contents are modified, the document clearly indicating
+       the fact of modification must be included.
+    b. If LHa is redistributed with added values, you must put your best
+       effort to include them (Translator comment: If read literally,
+       original Japanese was unclear what "them" means here.  But
+       undoubtedly this "them" means source code for the added value
+       portion and this is a typical Japanese sloppy writing style to
+       abbreviate as such)  Also the document clearly indicating that
+       added value was added must be included. 
+    c. Binary only distribution is not allowed (including added value
+       ones.)
+   3. You need to put effort to distribute the latest version (This is not
+      your duty).
+   
+      NB: Distribution on Internet is free.  Please notify me by e-mail or
+      other means prior to the distribution if distribution is done through
+      non-Internet media (Magazine, CDROM etc.)  If not, make sure to Email
+      me later.
+   
+   4. Any damage caused by the existence and use of this program will not
+      be compensated.
+   
+   5. Author will not be responsible to correct errors even if program is
+      defective.
+   
+   6. This program, either as a part of this or as a whole of this, may be
+      included into other programs.  In this case, that program is not LHa
+      and can not call itself LHa.
+   
+   7. For commercial use, in addition to above conditions, following
+      condition needs to be met.
+   
+      a.  The program whose content is mainly this program can not be used
+          commercially.
+      b.  If the recipient of commercial use deems inappropriate as a
+          program user, you must not distribute.
+      c.  If used as a method for the installation, you must not force
+          others to use this program.  In this case, commercial user will
+          perform its work while taking full responsibility of its outcome.
+      d.  If added value is done under the commercial use by using this
+          program, commercial user shall provide its support.
+
+
+(Osamu Aoki also comments:
+   Here "commercial" may be interpreted as "for-fee".  "Added value" seems
+   to mean "feature enhancement".  )
+
+
+License Statement by Tsugio Okamoto (in Japanese EUC-JP):
+
+   なお、ネットでの配付は自由ですが、ネットにアクセスできない方（雑誌および、
+   CD-ROM などによる）への配付は、配付前にこちらに Inter-Net の方にE-Mail
+   を お願いします。 どこそこに、掲載するという旨があれば結構ですので。
+   また、それも出来ない際には、後日 E-Mail を必ずお願いします。
+
+
+Translated License Statement by Tsugio Okamoto (translated by
+GOTO Masanori <gotom@debian.org>):
+
+   It's free to distribute on the network, but if you distribute for
+   the people who cannot access the network (by magazine or CD-ROM),
+   please send E-Mail (Inter-Net address) to the author before the
+   distribution. That's well where this software is appeard.
+   If you cannot do, you must send me the E-Mail later.
+
--- lha-1.14i.orig/debian/control
+++ lha-1.14i/debian/control
@@ -0,0 +1,13 @@
+Source: lha
+Section: non-free/utils
+Priority: optional
+Maintainer: GOTO Masanori <gotom@debian.org>
+Build-Depends: debhelper (>> 4.0.0)
+Standards-Version: 3.6.0
+
+Package: lha
+Architecture: any
+Depends: ${shlibs:Depends}
+Description: lzh archiver
+ The famous lzh archiver, known from DOS.  When mixing DOS and Unix
+ you might need it.  (Especially for fido <--> rfc conversions.)
--- lha-1.14i.orig/debian/docs
+++ lha-1.14i/debian/docs
@@ -0,0 +1,10 @@
+README.euc
+change-114e.txt
+change-114g.txt
+change-114h.txt
+change-114i.txt
+MACHINES
+MACHINES2
+PROBLEMS
+header.doc
+debian/header-e.doc
--- lha-1.14i.orig/debian/patch.paul
+++ lha-1.14i/debian/patch.paul
@@ -0,0 +1,10 @@
+--- src/lha.h	Thu Oct  5 19:35:38 2000
++++ src/lha.h	Wed Aug 22 15:49:55 2001
+@@ -16,6 +16,7 @@
+ #include <sys/types.h>
+ #include <sys/file.h>
+ #include <sys/stat.h>
++#include <stdlib.h>
+ 
+ #include <signal.h>
+
--- lha-1.14i.orig/debian/header-e.doc
+++ lha-1.14i/debian/header-e.doc
@@ -0,0 +1,189 @@
+/* header.doc (In English) */
+Header structure used in LHa for UNIX              Mar. 2, 1992, Masaru Oki.
+(Translated by Osamu Aoki)
+
+----------------------------------------------------------------
+This version, as a transitional mreasure, uses level-1 as default value while
+offering 3 types of header types. In the future, I plan to use level-2 which
+has no limit on number of characters for the path mname.
+
+  A. Spec for header
+
+Basic part
+-----------------------------------------------------------------------------
+        level-0                 level-1                 level-2
+-----------------------------------------------------------------------------
+      1 header size           1 header size           2 total header size
+      1 header sum            1 header sum
+      5 method ID             5 method ID             5 method ID
+      4 packed size           4 skip size             4 packed size
+      4 original size         4 original size         4 original size
+      2 time                  2 time                  4 time(UNIX type)
+      2 date                  2 date
+      1 attribute             1 0x20                  1 RESERVED
+      1 level 0x00            1 level 0x01            1 level 0x02
+      1 name length           1 name length
+      ? pathname              ? filename
+      2 file crc              2 file crc              2 file crc
+      . ........              1 OS ID 'U'             1 OS ID 'U'
+                              . ........
+                              2 next-header size      2 next-header size
+    *************************************************************************
+     24 + ?                  27 + ?                  26
+
+Extension part
+-----------------------------------------------------------------------------
+                              1 ext-type              1 ext-type
+                              . ........              . ........
+                              2 next-header size      2 next-header size
+  
+-----------------------------------------------------------------------------
+
+    a. Types of header
+
+      level-0 header
+          Same format as conventional LHarc, LArc.  Separator for directory
+	  name is '\' as default.
+
+      level-1 header
+          This header is used as default. Archive type -lh0 made with -x0 can
+	  be unfrozen by LHarc but there will be no checking on CRC.
+
+      level-2 header
+          Header for supporting long file names.  I would like to standarize
+	  on this format in the future.  Please follow this if you wish to
+	  make utilities related ti LH.
+
+    b. method ID for freeze/unfreeze
+
+      * these methods are freeze/unfreeze, others are unfreeze only
+
+      -lh0- * no compression
+
+      -lh1- * 4k sliding dictionary(max 60 bytes) + dynamic Huffman
+              + fixed encoding of position
+
+      -lh2-   8k sliding dictionary(max 256 bytes) + dynamic Huffman
+
+      -lh3-   8k sliding dictionary(max 256 bytes) + static Huffman
+
+      -lh4- * 4k sliding dictionary(max 256 bytes) + static Huffman
+              + improved encoding of position and trees
+
+      -lh5- * 8k sliding dictionary(max 256 bytes) + static Huffman
+              + improved encoding of position and trees
+
+      -lh6-   32k sliding dictionary(max 256 bytes) + static Huffman
+			  + improved encoding of position and trees
+
+      -lh7-   64k sliding dictionary(max 256 bytes) + static Huffman
+			  + improved encoding of position and trees
+
+      -lzs-   2k sliding dictionary(max 17 bytes)
+
+      -lz4-   no compression
+
+      -lz5-   4k sliding dictionary(max 17 bytes)
+
+    c. About OS ID
+
+      Following OS ID are reserved.
+
+        MS-DOS  'M'
+        OS/2    '2'
+        OS9     '9'
+        OS/68K  'K'
+        OS/386  '3'
+        HUMAN   'H'
+        UNIX    'U'
+        CP/M    'C'
+        FLEX    'F'
+        Mac     'm'
+        Runser  'R'
+
+  B. Extension
+
+    a. OS independent (0x00 - 0x3f)
+
+        common header
+         1 0x00
+         2 header crc
+       ( 1 information )
+         2 next-header size
+
+        filename header
+         1 0x01
+         ? filename
+         2 next-header size
+
+        dirname header
+         1 0x02
+         ? dirname
+         2 next-header size
+
+        comment header
+         1 0x3f
+         ? comments
+         2 next-header size
+
+(Above portion, from lhx.doc by Mr. Yoshizaki)
+----------------------------------------------------------------
+LHa for UNIX : specification for extension header
+
+* Category of machine specific information (Information to be recorded)
+	Followings are UNIX specific information which requires to be recorded
+	(1) Permission
+	(2) GID,UID
+	(3) Group name, User name
+	(4) Last change time (UNIX time)
+
+* Type of machine specific information (ext-type)
+	First 1 byte of extension header contain value to distinguish types of
+	the infoemation. Foe UNIX specific information,  0x50 - 0x54 will be
+	used.
+
+* Method to store 
+	Above categories (1) - (4) will be different type.
+	
+
+	(1) Pemission
+		size	value
+		1	0x50
+		2	Valur of permission
+		2	next-header size
+
+	(2)GID,UID
+		size	value
+		1	0x51
+		2	GID
+		2	UID
+		2	next-header size
+
+	(3)-1 Group name
+		1	0x52
+		?	Group name string
+		2	next-header size
+
+	(3)-2 user name
+		1	0x53
+		?	User name string
+		2	next-header size
+
+	(4) Last change time (for header_level1)
+		1	0x54
+		4	UNIX time
+		2	next-header size
+
+* Implimentation of LHa for UNIX ver 1.14 (Watazaki)
+	Above (3) is not supported
+	Group name and user name specified by (3) is not used to make an
+	archive thus ignored during expansion.
+	Also (4) is contained only in level-1 archive.
+----------------------------------------------------------------
+That's all folks :)
+
+Partially modified by
+Nobutaka Watazaki
+watazaki@shimadzu.co.jp
+
+
--- lha-1.14i.orig/debian/patch.CAN-2004-0234_0235
+++ lha-1.14i/debian/patch.CAN-2004-0234_0235
@@ -0,0 +1,85 @@
+--- src/header.c.old	2000-10-05 19:36:03.000000000 +0200
++++ src/header.c	2004-04-17 23:55:54.000000000 +0200
+@@ -538,6 +538,10 @@
+ 				/*
+ 				 * filename
+ 				 */
++				if (header_size >= 256) {
++				  fprintf(stderr, "Possible buffer overflow hack attack, type #1\n");
++				  exit(109);
++				}
+ 				for (i = 0; i < header_size - 3; i++)
+ 					hdr->name[i] = (char) get_byte();
+ 				hdr->name[header_size - 3] = '\0';
+@@ -547,6 +551,10 @@
+ 				/*
+ 				 * directory
+ 				 */
++				if (header_size >= FILENAME_LENGTH) {
++				  fprintf(stderr, "Possible buffer overflow hack attack, type #2\n");
++				  exit(110);
++				}
+ 				for (i = 0; i < header_size - 3; i++)
+ 					dirname[i] = (char) get_byte();
+ 				dirname[header_size - 3] = '\0';
+--- src/lhext.c.old	2000-10-04 16:57:38.000000000 +0200
++++ src/lhext.c	2004-04-18 01:27:44.000000000 +0200
+@@ -190,8 +190,13 @@
+ 		q = (char *) rindex(hdr->name, '/') + 1;
+ 	}
+ 	else {
++		if (is_directory_traversal(q)) {
++		  fprintf(stderr, "Possible directory traversal hack attempt in %s\n", q);
++		  exit(111);
++		}
++
+ 		if (*q == '/') {
+-			q++;
++			while (*q == '/') { q++; }
+ 			/*
+ 			 * if OSK then strip device name
+ 			 */
+@@ -419,6 +424,33 @@
+ 	return;
+ }
+ 
++int
++is_directory_traversal(char *string)
++{
++  unsigned int type = 0; /* 0 = new, 1 = only dots, 2 = other chars than dots */
++  char *temp;
++
++  temp = string;
++
++  while (*temp != 0) {
++    if (temp[0] == '/') {
++      if (type == 1) { return 1; }
++      type = 0;
++      temp++;
++      continue;
++    }
++
++    if ((temp[0] == '.') && (type < 2))
++      type = 1;
++    if (temp[0] != '.')
++      type = 2;
++
++    temp++;
++  } /* while */
++
++  return (type == 1);
++}
++
+ /* Local Variables: */
+ /* mode:c */
+ /* tab-width:4 */
+--- src/lhext.c.symlink	2000-10-04 10:57:38.000000000 -0400
++++ src/lhext.c	2003-05-19 22:55:57.000000000 -0400
+@@ -351,6 +351,7 @@ extract_one(afp, hdr)
+ 				}
+ 
+ 				unlink(bb1);
++				make_parent_path(bb1);
+ 				l_code = symlink(bb2, bb1);
+ 				if (l_code < 0) {
+ 					if (quiet != TRUE)
--- lha-1.14i.orig/debian/patch.header-overflow
+++ lha-1.14i/debian/patch.header-overflow
@@ -0,0 +1,21 @@
+--- src/header.c	2002-07-19 17:23:58.000000000 +0900
++++ src/header.c	2004-06-16 09:49:23.000000000 +0900
+@@ -648,8 +648,17 @@
+ 	}
+ 
+ 	if (dir_length) {
++		if ((dir_length + name_length) > sizeof(dirname)) {
++			fprintf(stderr, "Insufficient buffer size\n");
++			exit(112);
++		}
+ 		strcat(dirname, hdr->name);
+-		strcpy(hdr->name, dirname);
++
++		if ((dir_length + name_length) > sizeof(hdr->name)) {
++			fprintf(stderr, "Insufficient buffer size\n");
++			exit(112);
++		}
++		strncpy(hdr->name, dirname, sizeof(hdr->name));
+ 		name_length += dir_length;
+ 	}
+ 
--- lha-1.14i.orig/debian/patch.redhat-sec2
+++ lha-1.14i/debian/patch.redhat-sec2
@@ -0,0 +1,196 @@
+diff -urNp lha-114i.orig/src/lha_macro.h lha-114i/src/lha_macro.h
+--- lha-114i.orig/src/lha_macro.h	2004-08-03 15:53:56.000000000 -0500
++++ lha-114i/src/lha_macro.h	2004-08-03 15:54:05.000000000 -0500
+@@ -53,7 +53,7 @@
+ #define SEEK_SET		0
+ #define SEEK_CUR		1
+ #define SEEK_END		2
+-#endif	/* SEEK_SET
++#endif	/* SEEK_SET */
+ 
+ 
+ /* non-integral functions */
+diff -urNp lha-114i.orig/src/lharc.c lha-114i/src/lharc.c
+--- lha-114i.orig/src/lharc.c	2004-08-03 15:53:56.000000000 -0500
++++ lha-114i/src/lharc.c	2004-08-03 15:54:05.000000000 -0500
+@@ -830,9 +830,10 @@ find_files(name, v_filec, v_filev)
+ 	DIRENTRY       *dp;
+ 	struct stat     tmp_stbuf, arc_stbuf, fil_stbuf;
+ 
+-	strcpy(newname, name);
++	strncpy(newname, name, sizeof(newname));
++	newname[sizeof(newname)-1] = 0;
+ 	len = strlen(name);
+-	if (len > 0 && newname[len - 1] != '/')
++	if (len > 0 && newname[len - 1] != '/' && len < (sizeof(newname)-1))
+ 		newname[len++] = '/';
+ 
+ 	dirp = opendir(name);
+@@ -846,6 +847,11 @@ find_files(name, v_filec, v_filev)
+ 
+ 	for (dp = readdir(dirp); dp != NULL; dp = readdir(dirp)) {
+ 		n = NAMLEN(dp);
++		if (len >= (sizeof(newname)-1) ||
++				(len+n) >= (sizeof(newname)-1) ||
++					 n  <= 0                   ||
++				(len+n) <= 0)
++			break;
+ 		strncpy(newname + len, dp->d_name, n);
+ 		newname[len + n] = '\0';
+ 		if (GETSTAT(newname, &fil_stbuf) < 0)
+@@ -903,7 +909,8 @@ build_temporary_name()
+ 		strcpy(temporary_name, TMP_FILENAME_TEMPLATE);
+ 	}
+ 	else {
+-		sprintf(temporary_name, "%s/lhXXXXXX", extract_directory);
++		snprintf(temporary_name, sizeof(temporary_name),
++			"%s/lhXXXXXX", extract_directory);
+ 	}
+ #ifdef MKSTEMP
+ 	mkstemp(temporary_name);
+@@ -913,10 +920,16 @@ build_temporary_name()
+ #else
+ 	char           *p, *s;
+ 
+-	strcpy(temporary_name, archive_name);
++	strncpy(temporary_name, archive_name, sizeof(temporary_name));
++	temporary_name[sizeof(temporary_name)-1] = 0;
+ 	for (p = temporary_name, s = (char *) 0; *p; p++)
+ 		if (*p == '/')
+ 			s = p;
++
++	if( sizeof(temporary_name) - ((size_t) (s-temporary_name)) - 1
++		<= strlen("lhXXXXXX"))
++			exit(-1);
++
+ 	strcpy((s ? s + 1 : temporary_name), "lhXXXXXX");
+ #ifdef MKSTEMP
+ 	mkstemp(temporary_name);
+@@ -1052,7 +1065,8 @@ open_old_archive()
+ 
+ 	if (open_old_archive_1(archive_name, &fp))
+ 		return fp;
+-	sprintf(expanded_archive_name, "%s.lzh", archive_name);
++	snprintf(expanded_archive_name, sizeof(expanded_archive_name),
++		"%s.lzh", archive_name);
+ 	if (open_old_archive_1(expanded_archive_name, &fp)) {
+ 		archive_name = expanded_archive_name;
+ 		return fp;
+@@ -1061,7 +1075,8 @@ open_old_archive()
+ 	 * if ( (errno&0xffff)!=E_PNNF ) { archive_name =
+ 	 * expanded_archive_name; return NULL; }
+ 	 */
+-	sprintf(expanded_archive_name, "%s.lzs", archive_name);
++	snprintf(expanded_archive_name, sizeof(expanded_archive_name),
++		"%s.lzs", archive_name);
+ 	if (open_old_archive_1(expanded_archive_name, &fp)) {
+ 		archive_name = expanded_archive_name;
+ 		return fp;
+diff -urNp lha-114i.orig/src/lhext.c lha-114i/src/lhext.c
+--- lha-114i.orig/src/lhext.c	2004-08-03 15:53:56.000000000 -0500
++++ lha-114i/src/lhext.c	2004-08-03 15:55:40.000000000 -0500
+@@ -82,7 +82,8 @@ make_parent_path(name)
+ 	register char  *p;
+ 
+ 	/* make parent directory name into PATH for recursive call */
+-	strcpy(path, name);
++	memset(path, 0, sizeof(path));
++	strncpy(path, name, sizeof(path)-1);
+ 	for (p = path + strlen(path); p > path; p--)
+ 		if (p[-1] == '/') {
+ 			*--p = '\0';
+@@ -212,9 +213,11 @@ extract_one(afp, hdr)
+ 	}
+ 
+ 	if (extract_directory)
+-		sprintf(name, "%s/%s", extract_directory, q);
+-	else
+-		strcpy(name, q);
++		snprintf(name, sizeof(name), "%s/%s", extract_directory, q);
++	else {
++		strncpy(name, q, sizeof(name));
++		name[sizeof(name) - 1] = '\0';
++	}
+ 
+ 
+ 	/* LZHDIRS_METHOD鐃緒申鐃緒申鐃縦ヘッワ申鐃緒申鐃緒申鐃緒申鐃獣ワ申鐃緒申鐃緒申 */
+@@ -335,7 +338,8 @@ extract_one(afp, hdr)
+ 			if ((hdr->unix_mode & UNIX_FILE_TYPEMASK) == UNIX_FILE_SYMLINK) {
+ 				char            buf[256], *bb1, *bb2;
+ 				int             l_code;
+-				strcpy(buf, name);
++				strncpy(buf, name, sizeof(buf));
++				buf[sizeof(buf)-1] = 0;
+ 				bb1 = strtok(buf, "|");
+ 				bb2 = strtok(NULL, "|");
+ 
+@@ -365,9 +369,10 @@ extract_one(afp, hdr)
+ 				if (quiet != TRUE) {
+ 					printf("Symbolic Link %s -> %s\n", bb1, bb2);
+ 				}
+-				strcpy(name, bb1);	/* Symbolic's name set */
++				strncpy(name, bb1, 255);	/* Symbolic's name set */
++				name[255] = 0;
+ #else
+-				sprintf(buf, "%s -> %s", bb1, bb2);
++				sprintf(buf, sizeof(buf), "%s -> %s", bb1, bb2);
+ 				warning("Can't make Symbolic Link", buf);
+ 				return;
+ #endif
+diff -urNp lha-114i.orig/src/lhlist.c lha-114i/src/lhlist.c
+--- lha-114i.orig/src/lhlist.c	2004-08-03 15:53:56.000000000 -0500
++++ lha-114i/src/lhlist.c	2004-08-03 15:54:05.000000000 -0500
+@@ -250,7 +250,8 @@ list_one(hdr)
+ 			printf(" %s", hdr->name);
+ 		else {
+ 			char            buf[256], *b1, *b2;
+-			strcpy(buf, hdr->name);
++			strncpy(buf, hdr->name, sizeof(buf));
++			buf[sizeof(buf)-1] = 0;
+ 			b1 = strtok(buf, "|");
+ 			b2 = strtok(NULL, "|");
+ 			printf(" %s -> %s", b1, b2);
+diff -urNp lha-114i.orig/src/util.c lha-114i/src/util.c
+--- lha-114i.orig/src/util.c	2004-08-03 15:53:56.000000000 -0500
++++ lha-114i/src/util.c	2004-08-03 15:54:05.000000000 -0500
+@@ -276,21 +276,27 @@ rmdir(path)
+ 	char           *path;
+ {
+ 	int             stat, rtn = 0;
+-	char           *cmdname;
+-	if ((cmdname = (char *) malloc(strlen(RMDIRPATH) + 1 + strlen(path) + 1))
+-	    == 0)
++	pid_t           child;
++
++
++	/* XXX thomas: shell meta chars in path could exec commands */
++	/* therefore we should avoid using system() */
++	if ((child = fork()) < 0)
++		return (-1);    /* fork error */
++	else if (child) {       /* parent process */
++		while (child != wait(&stat))    /* ignore signals */
++			continue;
++	}
++	else {                  /* child process */
++		execl(RMDIRPATH, "rmdir", path, (char *) 0);
++		/* never come here except execl is error */
+ 		return (-1);
+-	strcpy(cmdname, RMDIRPATH);
+-	*(cmdname + strlen(RMDIRPATH)) = ' ';
+-	strcpy(cmdname + strlen(RMDIRPATH) + 1, path);
+-	if ((stat = system(cmdname)) < 0)
+-		rtn = -1;	/* fork or exec error */
+-	else if (stat) {	/* RMDIR command error */
+-		errno = EIO;
+-		rtn = -1;
+ 	}
+-	free(cmdname);
+-	return (rtn);
++	if (stat != 0) {
++		errno = EIO;    /* cannot get error num. */
++		return (-1);
++	}
++	return (0);
+ }
+ 
+ /* ------------------------------------------------------------------------ */
--- lha-1.14i.orig/debian/patch.CVE-2006-4335-CVE-2006-4337-CVE-2006-4338
+++ lha-1.14i/debian/patch.CVE-2006-4335-CVE-2006-4337-CVE-2006-4338
@@ -0,0 +1,137 @@
+diff -aur lha-1.14i.orig/src/huf.c lha-1.14i/src/huf.c
+--- lha-1.14i.orig/src/huf.c	2000-10-05 19:35:49.000000000 +0200
++++ lha-1.14i/src/huf.c	2006-12-11 10:07:31.000000000 +0100
+@@ -332,7 +332,7 @@
+ 	}
+ 	else {
+ 		i = 0;
+-		while (i < n) {
++		while (i < MIN(n, NPT)) {
+ 			c = bitbuf >> (16 - 3);
+ 			if (c == 7) {
+ 				unsigned short  mask = 1 << (16 - 4);
+@@ -345,7 +345,7 @@
+ 			pt_len[i++] = c;
+ 			if (i == i_special) {
+ 				c = getbits(2);
+-				while (--c >= 0)
++				while (--c >= 0 && i < NPT)
+ 					pt_len[i++] = 0;
+ 			}
+ 		}
+@@ -370,7 +370,7 @@
+ 			c_table[i] = c;
+ 	} else {
+ 		i = 0;
+-		while (i < n) {
++		while (i < MIN(n,NC)) {
+ 			c = pt_table[bitbuf >> (16 - 8)];
+ 			if (c >= NT) {
+ 				unsigned short  mask = 1 << (16 - 9);
+@@ -380,7 +380,7 @@
+ 					else
+ 						c = left[c];
+ 					mask >>= 1;
+-				} while (c >= NT);
++				} while (c >= NT && (mask || c != left[c])); /* CVE-2006-4338 */
+ 			}
+ 			fillbuf(pt_len[c]);
+ 			if (c <= 2) {
+@@ -427,7 +427,7 @@
+ 			else
+ 				j = left[j];
+ 			mask >>= 1;
+-		} while (j >= NC);
++		} while (j >= NC && (mask || j != left[j])); /* CVE-2006-4338 */
+ 		fillbuf(c_len[j] - 12);
+ 	}
+ 	return j;
+@@ -451,7 +451,7 @@
+ 			else
+ 				j = left[j];
+ 			mask >>= 1;
+-		} while (j >= np);
++		} while (j >= np && (mask || j != left[j])); /* CVE-2006-4338 */
+ 		fillbuf(pt_len[j] - 8);
+ 	}
+ 	if (j != 0)
+Only in lha-1.14i/src: huf.c~
+diff -aur lha-1.14i.orig/src/lha_macro.h lha-1.14i/src/lha_macro.h
+--- lha-1.14i.orig/src/lha_macro.h	2006-12-11 09:43:54.000000000 +0100
++++ lha-1.14i/src/lha_macro.h	2006-12-11 09:55:42.000000000 +0100
+@@ -408,6 +408,8 @@
+ #define MAXMATCH			256	/* formerly F (not more than UCHAR_MAX + 1) */
+ #define THRESHOLD			3	/* choose optimal value */
+ 
++#define MIN(a,b) ((a) <= (b) ? (a) : (b))
++
+ /* from huf.c */
+ 
+ /* alphabet = {0, 1, 2, ..., NC - 1} */
+Only in lha-1.14i/src: lha_macro.h~
+diff -aur lha-1.14i.orig/src/maketbl.c lha-1.14i/src/maketbl.c
+--- lha-1.14i.orig/src/maketbl.c	2000-10-04 16:57:38.000000000 +0200
++++ lha-1.14i/src/maketbl.c	2006-12-11 09:59:51.000000000 +0100
+@@ -32,8 +32,15 @@
+ 	}
+ 
+ 	/* count */
+-	for (i = 0; i < nchar; i++)
+-		count[bitlen[i]]++;
++	for (i = 0; i < nchar; i++) {
++		if (bitlen[i] > 16) {
++		/* CVE-2006-4335 */
++		error("Bad table (case a)");
++		exit(1);
++	}
++	else
++		count[bitlen[i]]++;
++	}
+ 
+ 	/* calculate first code */
+ 	total = 0;
+@@ -41,8 +48,11 @@
+ 		start[i] = total;
+ 		total += weight[i] * count[i];
+ 	}
+-	if ((total & 0xffff) != 0)
+-		error("make_table()", "Bad table (5)\n");
++
++	if ((total & 0xffff) != 0 || tablebits > 16) { /* 16 for weight below */
++		error("make_table(): Bad table (case b)");
++		exit(1);
++	}
+ 
+ 	/* shift data for make table. */
+ 	m = 16 - tablebits;
+@@ -53,7 +63,7 @@
+ 
+ 	/* initialize */
+ 	j = start[tablebits + 1] >> m;
+-	k = 1 << tablebits;
++	k = MIN(1 << tablebits, 4096);
+ 	if (j != 0)
+ 		for (i = j; i < k; i++)
+ 			table[i] = 0;
+@@ -66,12 +76,19 @@
+ 		l = start[k] + weight[k];
+ 		if (k <= tablebits) {
+ 			/* code in table */
++		l = MIN(l, 4096);
+ 			for (i = start[k]; i < l; i++)
+ 				table[i] = j;
+ 		}
+ 		else {
+ 			/* code not in table */
+-			p = &table[(i = start[k]) >> m];
++			i = start[k];
++			if ((i >> m) > 4096) {
++			/* CVE-2006-4337 */
++			error("Bad table (case c)");
++			exit(1);
++			}
++			p = &table[i >> m];
+ 			i <<= tablebits;
+ 			n = k - tablebits;
+ 			/* make tree (n length) */
+Only in lha-1.14i/src: maketbl.c~
