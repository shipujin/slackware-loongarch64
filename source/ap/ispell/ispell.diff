--- ./local.h.orig	Fri Jun  8 13:44:56 2001
+++ ./local.h	Fri Jun  8 13:51:33 2001
@@ -0,0 +1,112 @@
+/*
+ * $Id: local.h.samp,v 1.18 2001/05/30 21:14:47 geoff Exp $
+ */
+
+/*
+ * Copyright 1992, 1993, 1999, Geoff Kuenning, Claremont, CA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All modifications to the source code must be clearly marked as
+ *    such.  Binary redistributions based on modified source code
+ *    must be clearly marked as modified versions in the documentation
+ *    and/or other materials provided with the distribution.
+ * 4. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgment:
+ *      This product includes software developed by Geoff Kuenning and
+ *      other unpaid contributors.
+ * 5. The name of Geoff Kuenning may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY GEOFF KUENNING AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL GEOFF KUENNING OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * This file is a sample local.h file.  It shows what I believe nearly every
+ * site will want to include in their local.h.  You will probably want to
+ * expand this file;  see "config.X" to learn of #defines that you might
+ * like to add to.
+ */
+
+/*
+ * $Log: local.h.samp,v $
+ * Revision 1.18  2001/05/30 21:14:47  geoff
+ * Invert the fcntl/mkstemp options so they will default to being used.
+ *
+ * Revision 1.17  2001/05/30 21:04:25  geoff
+ * Add HAS_FCNTL_H and HAS_MKSTEMP.  Also give better comments on the USG
+ * option.
+ *
+ * Revision 1.16  1999/01/08 04:34:43  geoff
+ * Get rid of ELISPDIR and TEXINFODIR
+ *
+ * Revision 1.15  1999/01/07  01:57:57  geoff
+ * Update the copyright.
+ *
+ * Revision 1.14  1995/01/08  23:23:56  geoff
+ * Do some minor clarification of the instructional comments.
+ *
+ * Revision 1.13  1994/05/17  06:37:25  geoff
+ * Add one more item of warning advice to the comments.
+ *
+ * Revision 1.12  1994/02/07  06:00:00  geoff
+ * Add a warning about shell processing restrictions
+ *
+ * Revision 1.11  1994/01/25  07:11:50  geoff
+ * Get rid of all old RCS log lines in preparation for the 3.1 release.
+ *
+ */
+
+/*
+ * WARNING WARNING WARNING
+ *
+ * This file is *NOT* a normal C header file!  Although it uses C
+ * syntax and is included in C programs, it is also processed by shell
+ * scripts that are very stupid about format.
+ *
+ * Do not try to use #if constructs to configure this file for more
+ * than one configuration.  Do not place whitespace after the "#" in
+ * "#define".  Do not attempt to disable lines by commenting them out.
+ * Do not use backslashes to reduce the length of long lines.
+ * None of these things will work the way you expect them to.
+ *
+ * WARNING WARNING WARNING
+ */
+
+#define MINIMENU	/* Display a mini-menu at the bottom of the screen */
+#undef NO8BIT		/* Remove this if you use ISO character sets */
+#define USG		/* Define on System V or if term.c won't compile */
+#undef NO_FCNTL_H	/* Define if you get compile errors on fcntl.h */
+#undef NO_MKSTEMP	/* Define if you get compile or link errors */
+#define CFLAGS  "-O2 -Wall -I ."
+
+/*
+ * Important directory paths
+ */
+#define BINDIR	"/usr/bin"
+#define LIBDIR	"/usr/lib/ispell"
+#define MAN1DIR	"/usr/man/man1"
+#define MAN4DIR	"/usr/man/man4"
+
+/*
+ * Place any locally-required #include statements here
+ */
--- ./string.h.orig	Fri Jun  8 13:49:03 2001
+++ ./string.h	Fri Jun  8 13:50:38 2001
@@ -0,0 +1,366 @@
+/* Copyright (C) 1991,92,93,95,96,97,98,99,2000,2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/*
+ *	ISO C99 Standard: 7.21 String handling	<string.h>
+ */
+
+#ifndef	_STRING_H
+#define	_STRING_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Get size_t and NULL from <stddef.h>.  */
+#define	__need_size_t
+#define	__need_NULL
+#include <stddef.h>
+
+
+/* Copy N bytes of SRC to DEST.  */
+extern void *memcpy (void *__restrict __dest,
+		     __const void *__restrict __src, size_t __n) __THROW;
+/* Copy N bytes of SRC to DEST, guaranteeing
+   correct behavior for overlapping strings.  */
+extern void *memmove (void *__dest, __const void *__src, size_t __n)
+     __THROW;
+
+/* Copy no more than N bytes of SRC to DEST, stopping when C is found.
+   Return the position in DEST one byte past where C was copied,
+   or NULL if C was not found in the first N bytes of SRC.  */
+#if defined __USE_SVID || defined __USE_BSD || defined __USE_XOPEN
+extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
+		      int __c, size_t __n)
+     __THROW;
+#endif /* SVID.  */
+
+
+/* Set N bytes of S to C.  */
+extern void *memset (void *__s, int __c, size_t __n) __THROW;
+
+/* Compare N bytes of S1 and S2.  */
+extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
+     __THROW __attribute_pure__;
+
+/* Search N bytes of S for C.  */
+extern void *memchr (__const void *__s, int __c, size_t __n)
+      __THROW __attribute_pure__;
+
+#ifdef __USE_GNU
+/* Search in S for C.  This is similar to `memchr' but there is no
+   length limit.  */
+extern void *rawmemchr (__const void *__s, int __c) __THROW __attribute_pure__;
+
+/* Search N bytes of S for the final occurrence of C.  */
+extern void *memrchr (__const void *__s, int __c, size_t __n)
+      __THROW __attribute_pure__;
+#endif
+
+
+/* Copy SRC to DEST.  */
+extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
+     __THROW;
+/* Copy no more than N characters of SRC to DEST.  */
+extern char *strncpy (char *__restrict __dest,
+		      __const char *__restrict __src, size_t __n) __THROW;
+
+/* Append SRC onto DEST.  */
+extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
+     __THROW;
+/* Append no more than N characters from SRC onto DEST.  */
+extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
+		      size_t __n) __THROW;
+
+/* Compare S1 and S2.  */
+extern int strcmp (__const char *__s1, __const char *__s2)
+     __THROW __attribute_pure__;
+/* Compare N characters of S1 and S2.  */
+extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
+     __THROW __attribute_pure__;
+
+/* Compare the collated forms of S1 and S2.  */
+extern int strcoll (__const char *__s1, __const char *__s2)
+     __THROW __attribute_pure__;
+/* Put a transformation of SRC into no more than N bytes of DEST.  */
+extern size_t strxfrm (char *__restrict __dest,
+		       __const char *__restrict __src, size_t __n) __THROW;
+
+#ifdef __USE_GNU
+/* The following functions are equivalent to the both above but they
+   take the locale they use for the collation as an extra argument.
+   This is not standardsized but something like will come.  */
+# include <xlocale.h>
+
+/* Compare the collated forms of S1 and S2 using rules from L.  */
+extern int __strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
+     __THROW __attribute_pure__;
+/* Put a transformation of SRC into no more than N bytes of DEST.  */
+extern size_t __strxfrm_l (char *__dest, __const char *__src, size_t __n,
+			   __locale_t __l) __THROW;
+#endif
+
+#if defined __USE_SVID || defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+/* Duplicate S, returning an identical malloc'd string.  */
+extern char *strdup (__const char *__s) __THROW __attribute_malloc__;
+#endif
+
+/* Return a malloc'd copy of at most N bytes of STRING.  The
+   resultant string is terminated even if no null terminator
+   appears before STRING[N].  */
+#if defined __USE_GNU
+extern char *strndup (__const char *__string, size_t __n)
+     __THROW __attribute_malloc__;
+#endif
+
+#if defined __USE_GNU && defined __GNUC__
+/* Duplicate S, returning an identical alloca'd string.  */
+# define strdupa(s)							      \
+  (__extension__							      \
+    ({									      \
+      __const char *__old = (s);					      \
+      size_t __len = strlen (__old) + 1;				      \
+      char *__new = (char *) __builtin_alloca (__len);			      \
+      (char *) memcpy (__new, __old, __len);				      \
+    }))
+
+/* Return an alloca'd copy of at most N bytes of string.  */
+# define strndupa(s, n)							      \
+  (__extension__							      \
+    ({									      \
+      __const char *__old = (s);					      \
+      size_t __len = strnlen (__old, (n));				      \
+      char *__new = (char *) __builtin_alloca (__len + 1);		      \
+      __new[__len] = '\0';						      \
+      (char *) memcpy (__new, __old, __len);				      \
+    }))
+#endif
+
+/* Find the first occurrence of C in S.  */
+extern char *strchr (__const char *__s, int __c) __THROW __attribute_pure__;
+/* Find the last occurrence of C in S.  */
+extern char *strrchr (__const char *__s, int __c) __THROW __attribute_pure__;
+
+#ifdef __USE_GNU
+/* This funciton is similar to `strchr'.  But it returns a pointer to
+   the closing NUL byte in case C is not found in S.  */
+extern char *strchrnul (__const char *__s, int __c) __THROW __attribute_pure__;
+#endif
+
+/* Return the length of the initial segment of S which
+   consists entirely of characters not in REJECT.  */
+extern size_t strcspn (__const char *__s, __const char *__reject)
+     __THROW __attribute_pure__;
+/* Return the length of the initial segment of S which
+   consists entirely of characters in ACCEPT.  */
+extern size_t strspn (__const char *__s, __const char *__accept)
+     __THROW __attribute_pure__;
+/* Find the first occurrence in S of any character in ACCEPT.  */
+extern char *strpbrk (__const char *__s, __const char *__accept)
+     __THROW __attribute_pure__;
+/* Find the first occurrence of NEEDLE in HAYSTACK.  */
+extern char *strstr (__const char *__haystack, __const char *__needle)
+     __THROW __attribute_pure__;
+
+#ifdef __USE_GNU
+/* Similar to `strstr' but this function ignores the case of both strings.  */
+extern char *strcasestr (__const char *__haystack, __const char *__needle)
+     __THROW __attribute_pure__;
+#endif
+
+/* Divide S into tokens separated by characters in DELIM.  */
+extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
+     __THROW;
+
+/* Divide S into tokens separated by characters in DELIM.  Information
+   passed between calls are stored in SAVE_PTR.  */
+extern char *__strtok_r (char *__restrict __s,
+			 __const char *__restrict __delim,
+			 char **__restrict __save_ptr) __THROW;
+#if defined __USE_POSIX || defined __USE_MISC
+extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
+		       char **__restrict __save_ptr) __THROW;
+#endif
+
+#ifdef __USE_GNU
+/* Find the first occurrence of NEEDLE in HAYSTACK.
+   NEEDLE is NEEDLELEN bytes long;
+   HAYSTACK is HAYSTACKLEN bytes long.  */
+extern void *memmem (__const void *__haystack, size_t __haystacklen,
+		     __const void *__needle, size_t __needlelen)
+     __THROW __attribute_pure__;
+
+/* Copy N bytes of SRC to DEST, return pointer to bytes after the
+   last written byte.  */
+extern void *__mempcpy (void *__restrict __dest,
+			__const void *__restrict __src, size_t __n) __THROW;
+extern void *mempcpy (void *__restrict __dest,
+		      __const void *__restrict __src, size_t __n) __THROW;
+#endif
+
+
+/* Return the length of S.  */
+extern size_t strlen (__const char *__s) __THROW __attribute_pure__;
+
+#ifdef	__USE_GNU
+/* Find the length of STRING, but scan at most MAXLEN characters.
+   If no '\0' terminator is found in that many characters, return MAXLEN.  */
+extern size_t strnlen (__const char *__string, size_t __maxlen)
+     __THROW __attribute_pure__;
+#endif
+
+
+/* Return a string describing the meaning of the `errno' code in ERRNUM.  */
+extern char *strerror (int __errnum) __THROW;
+#ifdef	__USE_MISC
+/* Reentrant version of `strerror'.  If a temporary buffer is required, at
+   most BUFLEN bytes of BUF will be used.  */
+extern char *strerror_r (int __errnum, char *__buf, size_t __buflen) __THROW;
+#endif
+
+/* We define this function always since `bzero' is sometimes needed when
+   the namespace rules does not allow this.  */
+extern void __bzero (void *__s, size_t __n) __THROW;
+
+#undef __USE_BSD
+#if defined __USE_BSD
+/* Copy N bytes of SRC to DEST (like memmove, but args reversed).  */
+extern void bcopy (__const void *__src, void *__dest, size_t __n) __THROW;
+
+/* Set N bytes of S to 0.  */
+extern void bzero (void *__s, size_t __n) __THROW;
+
+/* Compare N bytes of S1 and S2 (same as memcmp).  */
+extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
+     __THROW __attribute_pure__;
+
+/* Find the first occurrence of C in S (same as strchr).  */
+extern char *index (__const char *__s, int __c) __THROW __attribute_pure__;
+
+/* Find the last occurrence of C in S (same as strrchr).  */
+extern char *rindex (__const char *__s, int __c) __THROW __attribute_pure__;
+
+/* Return the position of the first bit set in I, or 0 if none are set.
+   The least-significant bit is position 1, the most-significant 32.  */
+extern int ffs (int __i) __THROW __attribute__ ((__const__));
+
+/* The following two functions are non-standard but necessary for non-32 bit
+   platforms.  */
+# ifdef	__USE_GNU
+extern int ffsl (long int __l) __THROW __attribute__ ((__const__));
+#  ifdef __GNUC__
+__extension__ extern int ffsll (long long int __ll)
+     __THROW __attribute__ ((__const__));
+#  endif
+# endif
+
+/* Compare S1 and S2, ignoring case.  */
+extern int strcasecmp (__const char *__s1, __const char *__s2)
+     __THROW __attribute_pure__;
+
+/* Compare no more than N chars of S1 and S2, ignoring case.  */
+extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
+     __THROW __attribute_pure__;
+#endif /* Use BSD.  */
+
+#ifdef	__USE_GNU
+/* Again versions of a few functions which use the given locale instead
+   of the global one.  */
+extern int __strcasecmp_l (__const char *__s1, __const char *__s2,
+			   __locale_t __loc) __THROW __attribute_pure__;
+
+extern int __strncasecmp_l (__const char *__s1, __const char *__s2,
+			    size_t __n, __locale_t __loc)
+     __THROW __attribute_pure__;
+#endif
+
+#ifdef	__USE_BSD
+/* Return the next DELIM-delimited token from *STRINGP,
+   terminating it with a '\0', and update *STRINGP to point past it.  */
+extern char *strsep (char **__restrict __stringp,
+		     __const char *__restrict __delim) __THROW;
+#endif
+
+#ifdef	__USE_GNU
+/* Compare S1 and S2 as strings holding name & indices/version numbers.  */
+extern int strverscmp (__const char *__s1, __const char *__s2)
+     __THROW __attribute_pure__;
+
+/* Return a string describing the meaning of the signal number in SIG.  */
+extern char *strsignal (int __sig) __THROW;
+
+/* Copy SRC to DEST, returning the address of the terminating '\0' in DEST.  */
+extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
+     __THROW;
+extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
+     __THROW;
+
+/* Copy no more than N characters of SRC to DEST, returning the address of
+   the last character written into DEST.  */
+extern char *__stpncpy (char *__restrict __dest,
+			__const char *__restrict __src, size_t __n) __THROW;
+extern char *stpncpy (char *__restrict __dest,
+		      __const char *__restrict __src, size_t __n) __THROW;
+
+/* Sautee STRING briskly.  */
+extern char *strfry (char *__string) __THROW;
+
+/* Frobnicate N bytes of S.  */
+extern void *memfrob (void *__s, size_t __n) __THROW;
+
+# ifndef basename
+/* Return the file name within directory of FILENAME.  We don't
+   declare the function if the `basename' macro is available (defined
+   in <libgen.h>) which makes the XPG version of this function
+   available.  */
+extern char *basename (__const char *__filename) __THROW;
+# endif
+#endif
+
+
+#if defined __GNUC__ && __GNUC__ >= 2
+# if defined __OPTIMIZE__ && !defined __OPTIMIZE_SIZE__ && !defined __cplusplus
+/* When using GNU CC we provide some optimized versions of selected
+   functions from this header.  There are two kinds of optimizations:
+
+   - machine-dependent optimizations, most probably using inline
+     assembler code; these might be quite expensive since the code
+     size can increase significantly.
+     These optimizations are not used unless the symbol
+	__USE_STRING_INLINES
+     is defined before including this header.
+
+   - machine-independent optimizations which do not increase the
+     code size significantly and which optimize mainly situations
+     where one or more arguments are compile-time constants.
+     These optimizations are used always when the compiler is
+     taught to optimize.
+
+   One can inhibit all optimizations by defining __NO_STRING_INLINES.  */
+
+/* Get the machine-dependent optimizations (if any).  */
+#  include <bits/string.h>
+
+/* These are generic optimizations which do not add too much inline code.  */
+#  include <bits/string2.h>
+# endif
+#endif
+
+__END_DECLS
+
+#endif /* string.h  */
